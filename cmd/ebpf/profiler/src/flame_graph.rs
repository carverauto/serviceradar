// Module for handling flame graph data format and utilities

use crate::ebpf_profiler::StackTrace;
use std::collections::HashMap;

pub struct FlameGraphFormatter {
    traces: Vec<StackTrace>,
}

impl FlameGraphFormatter {
    pub fn new(traces: Vec<StackTrace>) -> Self {
        Self { traces }
    }

    /// Convert stack traces to folded stack format suitable for flame graph generation
    pub fn to_folded_format(&self) -> String {
        let mut output = String::new();
        
        for trace in &self.traces {
            output.push_str(&trace.to_folded_format());
            output.push('\n');
        }
        
        output
    }

    /// Generate metadata header for the flame graph data
    pub fn generate_metadata(&self, pid: i32, duration_seconds: i32) -> String {
        let total_samples: u64 = self.traces.iter().map(|t| t.count).sum();
        let unique_stacks = self.traces.len();
        
        let timestamp = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs();

        format!(
            "# ServiceRadar eBPF Profiler Results\n\
             # PID: {}\n\
             # Duration: {}s\n\
             # Timestamp: {}\n\
             # Total samples: {}\n\
             # Unique stacks: {}\n\
             # Generated by: ServiceRadar eBPF Profiler v{}\n\n",
            pid,
            duration_seconds,
            timestamp,
            total_samples,
            unique_stacks,
            env!("CARGO_PKG_VERSION")
        )
    }

    /// Generate complete flame graph data with header and folded stacks
    pub fn generate_complete_output(&self, pid: i32, duration_seconds: i32) -> Vec<u8> {
        let metadata = self.generate_metadata(pid, duration_seconds);
        let folded_data = self.to_folded_format();
        
        let mut result = metadata.into_bytes();
        result.extend_from_slice(folded_data.as_bytes());
        result
    }

    /// Aggregate traces by function to show top consumers
    pub fn get_function_statistics(&self) -> Vec<FunctionStats> {
        let mut function_counts: HashMap<String, u64> = HashMap::new();
        
        // Count occurrences of each function across all stack traces
        for trace in &self.traces {
            for frame in &trace.frames {
                *function_counts.entry(frame.clone()).or_insert(0) += trace.count;
            }
        }
        
        // Convert to sorted list
        let mut stats: Vec<FunctionStats> = function_counts
            .into_iter()
            .map(|(function, count)| FunctionStats { function, count })
            .collect();
        
        stats.sort_by(|a, b| b.count.cmp(&a.count));
        stats
    }

    /// Get summary statistics about the profiling session
    pub fn get_summary(&self) -> ProfilingSummary {
        let total_samples: u64 = self.traces.iter().map(|t| t.count).sum();
        let unique_stacks = self.traces.len();
        
        let max_depth = self.traces
            .iter()
            .map(|t| t.frames.len())
            .max()
            .unwrap_or(0);
        
        let avg_depth = if unique_stacks > 0 {
            self.traces.iter().map(|t| t.frames.len()).sum::<usize>() as f64 / unique_stacks as f64
        } else {
            0.0
        };

        ProfilingSummary {
            total_samples,
            unique_stacks,
            max_stack_depth: max_depth,
            avg_stack_depth: avg_depth,
            top_functions: self.get_function_statistics().into_iter().take(10).collect(),
        }
    }
}

#[derive(Debug, Clone)]
pub struct FunctionStats {
    pub function: String,
    pub count: u64,
}

#[derive(Debug)]
pub struct ProfilingSummary {
    pub total_samples: u64,
    pub unique_stacks: usize,
    pub max_stack_depth: usize,
    pub avg_stack_depth: f64,
    pub top_functions: Vec<FunctionStats>,
}

impl ProfilingSummary {
    pub fn to_string(&self) -> String {
        let mut output = String::new();
        output.push_str(&format!("Profiling Summary:\n"));
        output.push_str(&format!("  Total samples: {}\n", self.total_samples));
        output.push_str(&format!("  Unique stacks: {}\n", self.unique_stacks));
        output.push_str(&format!("  Max stack depth: {}\n", self.max_stack_depth));
        output.push_str(&format!("  Avg stack depth: {:.1}\n", self.avg_stack_depth));
        output.push_str(&format!("  Top functions:\n"));
        
        for (i, func) in self.top_functions.iter().enumerate() {
            let percentage = if self.total_samples > 0 {
                (func.count as f64 / self.total_samples as f64) * 100.0
            } else {
                0.0
            };
            output.push_str(&format!(
                "    {}: {} ({} samples, {:.1}%)\n",
                i + 1, func.function, func.count, percentage
            ));
        }
        
        output
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn create_test_traces() -> Vec<StackTrace> {
        vec![
            StackTrace {
                frames: vec!["main".to_string(), "foo".to_string(), "bar".to_string()],
                count: 10,
            },
            StackTrace {
                frames: vec!["main".to_string(), "foo".to_string(), "baz".to_string()],
                count: 20,
            },
            StackTrace {
                frames: vec!["main".to_string(), "other".to_string()],
                count: 5,
            },
        ]
    }

    #[test]
    fn test_flame_graph_formatter_creation() {
        let traces = create_test_traces();
        let formatter = FlameGraphFormatter::new(traces);
        assert_eq!(formatter.traces.len(), 3);
    }

    #[test]
    fn test_to_folded_format() {
        let traces = create_test_traces();
        let formatter = FlameGraphFormatter::new(traces);
        let folded = formatter.to_folded_format();
        
        assert!(folded.contains("main;foo;bar 10"));
        assert!(folded.contains("main;foo;baz 20"));
        assert!(folded.contains("main;other 5"));
    }

    #[test]
    fn test_generate_metadata() {
        let traces = create_test_traces();
        let formatter = FlameGraphFormatter::new(traces);
        let metadata = formatter.generate_metadata(123, 10);
        
        assert!(metadata.contains("# PID: 123"));
        assert!(metadata.contains("# Duration: 10s"));
        assert!(metadata.contains("# Total samples: 35")); // 10 + 20 + 5
        assert!(metadata.contains("# Unique stacks: 3"));
        assert!(metadata.contains("ServiceRadar eBPF Profiler"));
    }

    #[test]
    fn test_generate_complete_output() {
        let traces = create_test_traces();
        let formatter = FlameGraphFormatter::new(traces);
        let output = formatter.generate_complete_output(123, 10);
        let output_str = String::from_utf8(output).unwrap();
        
        // Should contain both metadata and folded data
        assert!(output_str.contains("# PID: 123"));
        assert!(output_str.contains("main;foo;bar 10"));
    }

    #[test]
    fn test_function_statistics() {
        let traces = create_test_traces();
        let formatter = FlameGraphFormatter::new(traces);
        let stats = formatter.get_function_statistics();
        
        // main appears in all traces: 10 + 20 + 5 = 35
        // foo appears in first two traces: 10 + 20 = 30
        // bar appears in first trace: 10
        // baz appears in second trace: 20
        // other appears in third trace: 5
        
        assert_eq!(stats.len(), 5);
        assert_eq!(stats[0].function, "main");
        assert_eq!(stats[0].count, 35);
        assert_eq!(stats[1].function, "foo");
        assert_eq!(stats[1].count, 30);
    }

    #[test]
    fn test_profiling_summary() {
        let traces = create_test_traces();
        let formatter = FlameGraphFormatter::new(traces);
        let summary = formatter.get_summary();
        
        assert_eq!(summary.total_samples, 35);
        assert_eq!(summary.unique_stacks, 3);
        assert_eq!(summary.max_stack_depth, 3); // main;foo;bar has 3 frames
        assert_eq!(summary.avg_stack_depth, (3 + 3 + 2) as f64 / 3.0); // (3+3+2)/3 = 2.67
        assert_eq!(summary.top_functions.len(), 5);
    }

    #[test]
    fn test_summary_to_string() {
        let traces = create_test_traces();
        let formatter = FlameGraphFormatter::new(traces);
        let summary = formatter.get_summary();
        let summary_str = summary.to_string();
        
        assert!(summary_str.contains("Total samples: 35"));
        assert!(summary_str.contains("Unique stacks: 3"));
        assert!(summary_str.contains("Max stack depth: 3"));
        assert!(summary_str.contains("Top functions:"));
        assert!(summary_str.contains("main"));
    }

    #[test]
    fn test_empty_traces() {
        let traces = vec![];
        let formatter = FlameGraphFormatter::new(traces);
        let summary = formatter.get_summary();
        
        assert_eq!(summary.total_samples, 0);
        assert_eq!(summary.unique_stacks, 0);
        assert_eq!(summary.max_stack_depth, 0);
        assert_eq!(summary.avg_stack_depth, 0.0);
        assert!(summary.top_functions.is_empty());
    }
}