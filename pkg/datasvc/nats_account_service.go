/*
 * Copyright 2025 Carver Automation Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package datasvc

import (
	"context"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sync"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	"github.com/carverauto/serviceradar/pkg/nats/accounts"
	"github.com/carverauto/serviceradar/proto"
)

// NATSAccountServer implements the NATSAccountService gRPC interface.
// This is a stateless service that performs NATS JWT/NKeys cryptographic operations.
// Account state (seeds, JWTs) is stored by the caller (Elixir/CNPG with AshCloak).
type NATSAccountServer struct {
	proto.UnimplementedNATSAccountServiceServer

	mu       sync.RWMutex
	operator *accounts.Operator
	signer   *accounts.AccountSigner

	// natsStore provides NATS connection for pushing JWTs to resolver
	natsStore *NATSStore

	// systemAccountSeed is stored after bootstrap for JWT push operations
	systemAccountSeed string

	// resolverBasePath is the base directory for NATS JWT resolver files
	// When set, account JWTs are written to this directory for file-based resolver
	resolverBasePath string

	// operatorConfigPath is where operator.conf is written for NATS to include
	operatorConfigPath string
}

// NewNATSAccountServer creates a new NATSAccountServer with the given operator.
// The server is stateless - it only holds the operator key for signing operations.
// If operator is nil, the server will start in uninitialized state and require bootstrap.
func NewNATSAccountServer(operator *accounts.Operator) *NATSAccountServer {
	server := &NATSAccountServer{
		operator: operator,
	}
	if operator != nil {
		server.signer = accounts.NewAccountSigner(operator)
	}
	return server
}

// SetNATSStore sets the NATS store for JWT push operations.
// Must be called before PushAccountJWT can work.
func (s *NATSAccountServer) SetNATSStore(store *NATSStore) {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.natsStore = store
}

// SetResolverPaths configures the paths for file-based JWT resolver.
// operatorConfigPath: where to write operator.conf for NATS to include
// resolverBasePath: base directory for account JWT files
func (s *NATSAccountServer) SetResolverPaths(operatorConfigPath, resolverBasePath string) {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.operatorConfigPath = operatorConfigPath
	s.resolverBasePath = resolverBasePath
}

// WriteOperatorConfig writes the operator configuration file for NATS.
// This includes the operator JWT and system account configuration.
// Must be called after BootstrapOperator to enable JWT-based account resolution.
func (s *NATSAccountServer) WriteOperatorConfig() error {
	s.mu.RLock()
	defer s.mu.RUnlock()

	if s.operatorConfigPath == "" {
		return fmt.Errorf("operator config path not set")
	}

	if s.operator == nil || !s.operator.IsInitialized() {
		return fmt.Errorf("operator not initialized")
	}

	// Ensure parent directory exists
	configDir := filepath.Dir(s.operatorConfigPath)
	if err := os.MkdirAll(configDir, 0755); err != nil {
		return fmt.Errorf("failed to create operator config directory: %w", err)
	}

	// Create resolver directory
	if s.resolverBasePath != "" {
		if err := os.MkdirAll(s.resolverBasePath, 0755); err != nil {
			return fmt.Errorf("failed to create resolver directory: %w", err)
		}
	}

	// Build operator.conf content
	operatorJWT := s.operator.JWT()
	systemAccountPubKey := s.operator.SystemAccountPublicKey()

	var config string
	if operatorJWT != "" {
		config = fmt.Sprintf(`# NATS Operator Configuration (auto-generated by datasvc)
# This file is included by nats-server.conf to enable JWT-based multi-tenancy

# Operator JWT (inline)
operator: %s

`, operatorJWT)
	}

	if systemAccountPubKey != "" {
		config += fmt.Sprintf(`# System account for $SYS subject access
system_account: %s

`, systemAccountPubKey)
	}

	if s.resolverBasePath != "" {
		config += fmt.Sprintf(`# Full resolver for account JWT storage
resolver: {
  type: full
  dir: "%s"
  allow_delete: true
  interval: "2m"
}
`, s.resolverBasePath)
	}

	// Write the config file
	if err := os.WriteFile(s.operatorConfigPath, []byte(config), 0644); err != nil {
		return fmt.Errorf("failed to write operator config: %w", err)
	}

	log.Printf("Wrote operator config to %s", s.operatorConfigPath)

	// If we have a system account JWT, write it to the resolver
	if s.resolverBasePath != "" && systemAccountPubKey != "" {
		systemJWT := s.operator.SystemAccountJWT()
		if systemJWT != "" {
			jwtPath := filepath.Join(s.resolverBasePath, systemAccountPubKey+".jwt")
			if err := os.WriteFile(jwtPath, []byte(systemJWT), 0644); err != nil {
				return fmt.Errorf("failed to write system account JWT: %w", err)
			}
			log.Printf("Wrote system account JWT to %s", jwtPath)
		}
	}

	return nil
}

// WriteAccountJWT writes an account JWT to the file-based resolver directory.
// This allows the NATS server to pick up new accounts without restart.
func (s *NATSAccountServer) WriteAccountJWT(accountPublicKey, accountJWT string) error {
	s.mu.RLock()
	resolverPath := s.resolverBasePath
	s.mu.RUnlock()

	if resolverPath == "" {
		return fmt.Errorf("resolver path not configured")
	}

	if accountPublicKey == "" || accountJWT == "" {
		return fmt.Errorf("account public key and JWT are required")
	}

	// Ensure resolver directory exists
	if err := os.MkdirAll(resolverPath, 0755); err != nil {
		return fmt.Errorf("failed to create resolver directory: %w", err)
	}

	// Write the JWT file
	jwtPath := filepath.Join(resolverPath, accountPublicKey+".jwt")
	if err := os.WriteFile(jwtPath, []byte(accountJWT), 0644); err != nil {
		return fmt.Errorf("failed to write account JWT: %w", err)
	}

	log.Printf("Wrote account JWT to %s", jwtPath)
	return nil
}

// BootstrapOperator initializes the NATS operator for the platform.
// This can either generate a new operator key pair or import an existing seed.
// Should be called once during initial platform setup.
func (s *NATSAccountServer) BootstrapOperator(
	_ context.Context,
	req *proto.BootstrapOperatorRequest,
) (*proto.BootstrapOperatorResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	// Check if already initialized
	if s.operator != nil && s.operator.IsInitialized() {
		return nil, status.Error(codes.AlreadyExists, "operator already initialized")
	}

	operatorName := req.GetOperatorName()
	if operatorName == "" {
		operatorName = "serviceradar"
	}

	// Bootstrap the operator (generates new or imports existing)
	operator, result, err := accounts.BootstrapOperator(
		operatorName,
		req.GetExistingOperatorSeed(),
		req.GetGenerateSystemAccount(),
	)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "failed to bootstrap operator: %v", err)
	}

	// Update the server state
	s.operator = operator
	s.signer = accounts.NewAccountSigner(operator)

	// Store system account seed for JWT push operations
	if result.SystemAccountSeed != "" {
		s.systemAccountSeed = result.SystemAccountSeed
	}

	// Write operator config for NATS resolver (if paths are configured)
	if s.operatorConfigPath != "" {
		if err := s.writeOperatorConfigLocked(); err != nil {
			log.Printf("Warning: failed to write operator config: %v", err)
			// Don't fail bootstrap - config can be written later
		}
	}

	return &proto.BootstrapOperatorResponse{
		OperatorPublicKey:       result.OperatorPublicKey,
		OperatorSeed:            result.OperatorSeed, // Only set if newly generated
		OperatorJwt:             result.OperatorJWT,
		SystemAccountPublicKey:  result.SystemAccountPublicKey,
		SystemAccountSeed:       result.SystemAccountSeed,
		SystemAccountJwt:        result.SystemAccountJWT,
	}, nil
}

// writeOperatorConfigLocked writes the operator config without acquiring locks.
// Must be called with s.mu held.
func (s *NATSAccountServer) writeOperatorConfigLocked() error {
	if s.operatorConfigPath == "" {
		return fmt.Errorf("operator config path not set")
	}

	if s.operator == nil || !s.operator.IsInitialized() {
		return fmt.Errorf("operator not initialized")
	}

	// Ensure parent directory exists
	configDir := filepath.Dir(s.operatorConfigPath)
	if err := os.MkdirAll(configDir, 0755); err != nil {
		return fmt.Errorf("failed to create operator config directory: %w", err)
	}

	// Create resolver directory
	if s.resolverBasePath != "" {
		if err := os.MkdirAll(s.resolverBasePath, 0755); err != nil {
			return fmt.Errorf("failed to create resolver directory: %w", err)
		}
	}

	// Build operator.conf content
	operatorJWT := s.operator.JWT()
	systemAccountPubKey := s.operator.SystemAccountPublicKey()

	var config string
	if operatorJWT != "" {
		config = fmt.Sprintf(`# NATS Operator Configuration (auto-generated by datasvc)
# This file is included by nats-server.conf to enable JWT-based multi-tenancy

# Operator JWT (inline)
operator: %s

`, operatorJWT)
	}

	if systemAccountPubKey != "" {
		config += fmt.Sprintf(`# System account for $SYS subject access
system_account: %s

`, systemAccountPubKey)
	}

	if s.resolverBasePath != "" {
		config += fmt.Sprintf(`# Full resolver for account JWT storage
resolver: {
  type: full
  dir: "%s"
  allow_delete: true
  interval: "2m"
}
`, s.resolverBasePath)
	}

	// Write the config file
	if err := os.WriteFile(s.operatorConfigPath, []byte(config), 0644); err != nil {
		return fmt.Errorf("failed to write operator config: %w", err)
	}

	log.Printf("Wrote operator config to %s", s.operatorConfigPath)

	// If we have a system account JWT, write it to the resolver
	if s.resolverBasePath != "" && systemAccountPubKey != "" {
		systemJWT := s.operator.SystemAccountJWT()
		if systemJWT != "" {
			jwtPath := filepath.Join(s.resolverBasePath, systemAccountPubKey+".jwt")
			if err := os.WriteFile(jwtPath, []byte(systemJWT), 0644); err != nil {
				return fmt.Errorf("failed to write system account JWT: %w", err)
			}
			log.Printf("Wrote system account JWT to %s", jwtPath)
		}
	}

	return nil
}

// GetOperatorInfo returns the current operator status and public key.
// Used to verify the operator is initialized before tenant operations.
func (s *NATSAccountServer) GetOperatorInfo(
	_ context.Context,
	_ *proto.GetOperatorInfoRequest,
) (*proto.GetOperatorInfoResponse, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	if s.operator == nil || !s.operator.IsInitialized() {
		return &proto.GetOperatorInfoResponse{
			IsInitialized: false,
		}, nil
	}

	return &proto.GetOperatorInfoResponse{
		OperatorPublicKey:       s.operator.PublicKey(),
		OperatorName:            s.operator.Name(),
		IsInitialized:           true,
		SystemAccountPublicKey:  s.operator.SystemAccountPublicKey(),
	}, nil
}

// ensureInitialized checks if the operator is initialized and returns the signer.
// Must be called with at least a read lock held.
func (s *NATSAccountServer) ensureInitialized() (*accounts.AccountSigner, error) {
	if s.operator == nil || s.signer == nil {
		return nil, status.Error(codes.FailedPrecondition, "operator not initialized - call BootstrapOperator first")
	}
	return s.signer, nil
}

// CreateTenantAccount generates new account NKeys and a signed account JWT.
// The returned account_seed should be stored encrypted by the caller (Elixir/AshCloak).
func (s *NATSAccountServer) CreateTenantAccount(
	_ context.Context,
	req *proto.CreateTenantAccountRequest,
) (*proto.CreateTenantAccountResponse, error) {
	s.mu.RLock()
	signer, err := s.ensureInitialized()
	s.mu.RUnlock()
	if err != nil {
		return nil, err
	}

	if req.GetTenantSlug() == "" {
		return nil, status.Error(codes.InvalidArgument, "tenant_slug is required")
	}

	// Convert proto limits to domain model
	var limits *accounts.AccountLimits
	if req.GetLimits() != nil {
		limits = protoToAccountLimits(req.GetLimits())
	}

	// Convert proto subject mappings to domain model
	var mappings []accounts.SubjectMapping
	for _, m := range req.GetSubjectMappings() {
		mappings = append(mappings, accounts.SubjectMapping{
			From: m.GetFrom(),
			To:   m.GetTo(),
		})
	}

	result, err := signer.CreateTenantAccount(req.GetTenantSlug(), limits, mappings)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "failed to create tenant account: %v", err)
	}

	return &proto.CreateTenantAccountResponse{
		AccountPublicKey: result.AccountPublicKey,
		AccountSeed:      result.AccountSeed, // Caller stores this encrypted
		AccountJwt:       result.AccountJWT,
	}, nil
}

// GenerateUserCredentials creates NATS user credentials for a tenant's account.
// Requires the account_seed (from Elixir storage) to sign the user JWT.
func (s *NATSAccountServer) GenerateUserCredentials(
	_ context.Context,
	req *proto.GenerateUserCredentialsRequest,
) (*proto.GenerateUserCredentialsResponse, error) {
	if req.GetTenantSlug() == "" {
		return nil, status.Error(codes.InvalidArgument, "tenant_slug is required")
	}
	if req.GetAccountSeed() == "" {
		return nil, status.Error(codes.InvalidArgument, "account_seed is required")
	}
	if req.GetUserName() == "" {
		return nil, status.Error(codes.InvalidArgument, "user_name is required")
	}

	// Convert proto credential type to domain model
	credType := protoToCredentialType(req.GetCredentialType())

	// Convert proto permissions to domain model
	var permissions *accounts.UserPermissions
	if req.GetPermissions() != nil {
		permissions = protoToUserPermissions(req.GetPermissions())
	}

	creds, err := accounts.GenerateUserCredentials(
		req.GetTenantSlug(),
		req.GetAccountSeed(),
		req.GetUserName(),
		credType,
		permissions,
		req.GetExpirationSeconds(),
	)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "failed to generate user credentials: %v", err)
	}

	var expiresAtUnix int64
	if !creds.ExpiresAt.IsZero() {
		expiresAtUnix = creds.ExpiresAt.Unix()
	}

	return &proto.GenerateUserCredentialsResponse{
		UserPublicKey:    creds.UserPublicKey,
		UserJwt:          creds.UserJWT,
		CredsFileContent: creds.CredsFileContent,
		ExpiresAtUnix:    expiresAtUnix,
	}, nil
}

// SignAccountJWT regenerates an account JWT with updated claims.
// Use this when revocations or limits change. Requires account_seed from Elixir storage.
func (s *NATSAccountServer) SignAccountJWT(
	_ context.Context,
	req *proto.SignAccountJWTRequest,
) (*proto.SignAccountJWTResponse, error) {
	s.mu.RLock()
	signer, err := s.ensureInitialized()
	s.mu.RUnlock()
	if err != nil {
		return nil, err
	}

	if req.GetTenantSlug() == "" {
		return nil, status.Error(codes.InvalidArgument, "tenant_slug is required")
	}
	if req.GetAccountSeed() == "" {
		return nil, status.Error(codes.InvalidArgument, "account_seed is required")
	}

	// Convert proto limits to domain model
	var limits *accounts.AccountLimits
	if req.GetLimits() != nil {
		limits = protoToAccountLimits(req.GetLimits())
	}

	// Convert proto subject mappings to domain model
	var mappings []accounts.SubjectMapping
	for _, m := range req.GetSubjectMappings() {
		mappings = append(mappings, accounts.SubjectMapping{
			From: m.GetFrom(),
			To:   m.GetTo(),
		})
	}

	accountPublicKey, accountJWT, err := signer.SignAccountJWT(
		req.GetTenantSlug(),
		req.GetAccountSeed(),
		limits,
		mappings,
		req.GetRevokedUserKeys(),
	)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "failed to sign account JWT: %v", err)
	}

	return &proto.SignAccountJWTResponse{
		AccountPublicKey: accountPublicKey,
		AccountJwt:       accountJWT,
	}, nil
}

// Helper functions for proto conversion

func protoToAccountLimits(p *proto.AccountLimits) *accounts.AccountLimits {
	if p == nil {
		return nil
	}
	return &accounts.AccountLimits{
		MaxConnections:       p.GetMaxConnections(),
		MaxSubscriptions:     p.GetMaxSubscriptions(),
		MaxPayloadBytes:      p.GetMaxPayloadBytes(),
		MaxDataBytes:         p.GetMaxDataBytes(),
		MaxExports:           p.GetMaxExports(),
		MaxImports:           p.GetMaxImports(),
		AllowWildcardExports: p.GetAllowWildcardExports(),
	}
}

func protoToCredentialType(t proto.UserCredentialType) accounts.UserCredentialType {
	switch t {
	case proto.UserCredentialType_USER_CREDENTIAL_TYPE_COLLECTOR:
		return accounts.CredentialTypeCollector
	case proto.UserCredentialType_USER_CREDENTIAL_TYPE_SERVICE:
		return accounts.CredentialTypeService
	case proto.UserCredentialType_USER_CREDENTIAL_TYPE_ADMIN:
		return accounts.CredentialTypeAdmin
	default:
		return accounts.CredentialTypeCollector
	}
}

func protoToUserPermissions(p *proto.UserPermissions) *accounts.UserPermissions {
	if p == nil {
		return nil
	}
	return &accounts.UserPermissions{
		PublishAllow:   p.GetPublishAllow(),
		PublishDeny:    p.GetPublishDeny(),
		SubscribeAllow: p.GetSubscribeAllow(),
		SubscribeDeny:  p.GetSubscribeDeny(),
		AllowResponses: p.GetAllowResponses(),
		MaxResponses:   p.GetMaxResponses(),
	}
}

// PushAccountJWT pushes an account JWT to the NATS resolver.
// This makes the account immediately available without NATS restart.
// Uses file-based resolver (writes JWT to resolver directory) for simplicity.
func (s *NATSAccountServer) PushAccountJWT(
	_ context.Context,
	req *proto.PushAccountJWTRequest,
) (*proto.PushAccountJWTResponse, error) {
	if req.GetAccountPublicKey() == "" {
		return nil, status.Error(codes.InvalidArgument, "account_public_key is required")
	}
	if req.GetAccountJwt() == "" {
		return nil, status.Error(codes.InvalidArgument, "account_jwt is required")
	}

	// Use file-based resolver - write JWT to resolver directory
	err := s.WriteAccountJWT(req.GetAccountPublicKey(), req.GetAccountJwt())
	if err != nil {
		return &proto.PushAccountJWTResponse{
			Success: false,
			Message: "failed to write JWT to resolver: " + err.Error(),
		}, nil
	}

	return &proto.PushAccountJWTResponse{
		Success: true,
		Message: "JWT written to resolver directory successfully",
	}, nil
}
