/*
 * Copyright 2025 Carver Automation Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package edgeonboarding

import (
	"bytes"
	"errors"
	"fmt"
	"text/template"
)

var (
	// ErrOperatorJWTRequired is returned when no operator JWT is provided for config generation.
	ErrOperatorJWTRequired = errors.New("operator JWT is required")
	// ErrSystemAccountPublicKeyRequired is returned when no system account public key is provided.
	ErrSystemAccountPublicKeyRequired = errors.New("system account public key is required")
)

// NATSServerConfig contains parameters for generating nats-server configuration.
type NATSServerConfig struct {
	// ServerName is the name of the NATS server instance
	ServerName string

	// ListenPort is the main client connection port (default: 4222)
	ListenPort int

	// OperatorJWTPath is the path to the operator JWT file
	OperatorJWTPath string

	// SystemAccountPublicKey is the public key of the system account
	SystemAccountPublicKey string

	// ResolverDir is the directory where the JWT resolver stores account JWTs
	ResolverDir string

	// TLSEnabled enables TLS for client connections
	TLSEnabled bool

	// TLSCertPath is the path to the server certificate
	TLSCertPath string

	// TLSKeyPath is the path to the server private key
	TLSKeyPath string

	// TLSCAPath is the path to the CA certificate for client verification
	TLSCAPath string

	// TLSVerify enables mutual TLS (client certificate verification)
	TLSVerify bool

	// JetStreamEnabled enables JetStream for persistence
	JetStreamEnabled bool

	// JetStreamStoreDir is the directory for JetStream storage
	JetStreamStoreDir string

	// JetStreamMaxMemory is the maximum memory for JetStream (in bytes, 0 = default)
	JetStreamMaxMemory int64

	// JetStreamMaxFile is the maximum file storage for JetStream (in bytes, 0 = default)
	JetStreamMaxFile int64

	// ClusterEnabled enables NATS clustering
	ClusterEnabled bool

	// ClusterName is the name of the NATS cluster
	ClusterName string

	// ClusterPort is the port for cluster communication
	ClusterPort int

	// ClusterRoutes are the routes to other cluster members
	ClusterRoutes []string

	// LeafNodeEnabled enables leaf node connections
	LeafNodeEnabled bool

	// LeafNodePort is the port for leaf node connections
	LeafNodePort int

	// HTTPMonitorPort is the port for the HTTP monitoring endpoint (0 = disabled)
	HTTPMonitorPort int

	// LogFile is the path to the log file (empty = stdout)
	LogFile string

	// Debug enables debug logging
	Debug bool

	// Trace enables trace logging
	Trace bool

	// MaxPayload is the maximum message payload size (default: 1MB)
	MaxPayload int

	// PingInterval is the interval for client pings (in seconds)
	PingInterval int

	// MaxPingsOut is the maximum outstanding pings before disconnect
	MaxPingsOut int
}

// DefaultNATSServerConfig returns a NATSServerConfig with sensible defaults.
func DefaultNATSServerConfig() *NATSServerConfig {
	return &NATSServerConfig{
		ServerName:       "serviceradar-nats",
		ListenPort:       4222,
		OperatorJWTPath:  "/etc/nats/operator.jwt",
		ResolverDir:      "/etc/nats/jwt",
		TLSEnabled:       true,
		TLSCertPath:      "/etc/nats/server.pem",
		TLSKeyPath:       "/etc/nats/server-key.pem",
		TLSCAPath:        "/etc/nats/ca.pem",
		TLSVerify:        true,
		JetStreamEnabled: true,
		JetStreamStoreDir: "/var/lib/nats/jetstream",
		JetStreamMaxMemory: 1 << 30, // 1GB
		JetStreamMaxFile:   10 << 30, // 10GB
		HTTPMonitorPort:   8222,
		MaxPayload:        1 << 20, // 1MB
		PingInterval:      120,
		MaxPingsOut:       2,
	}
}

const natsConfigTemplate = `# NATS Server Configuration
# Generated by serviceradar-cli bootstrap-nats
# WARNING: This file is auto-generated. Manual edits may be overwritten.

server_name: {{ .ServerName }}
port: {{ .ListenPort }}

# Operator and system account for multi-tenant JWT authentication
operator: {{ .OperatorJWTPath }}
system_account: {{ .SystemAccountPublicKey }}

# JWT resolver configuration
resolver: {
  type: full
  dir: {{ .ResolverDir }}
}
{{if .TLSEnabled}}
# TLS configuration
tls {
  cert_file: {{ .TLSCertPath }}
  key_file: {{ .TLSKeyPath }}
  ca_file: {{ .TLSCAPath }}
  verify: {{ .TLSVerify }}
}
{{end}}
{{if .JetStreamEnabled}}
# JetStream configuration for persistence
jetstream {
  store_dir: {{ .JetStreamStoreDir }}
  max_memory_store: {{ .JetStreamMaxMemory }}
  max_file_store: {{ .JetStreamMaxFile }}
}
{{end}}
{{if .ClusterEnabled}}
# Cluster configuration
cluster {
  name: {{ .ClusterName }}
  port: {{ .ClusterPort }}
  routes: [
{{range .ClusterRoutes}}    nats-route://{{ . }}
{{end}}  ]
}
{{end}}
{{if .LeafNodeEnabled}}
# Leaf node configuration
leafnodes {
  port: {{ .LeafNodePort }}
}
{{end}}
{{if gt .HTTPMonitorPort 0}}
# HTTP monitoring endpoint
http_port: {{ .HTTPMonitorPort }}
{{end}}
{{if .LogFile}}
# Logging
log_file: {{ .LogFile }}
{{end}}
{{if .Debug}}
debug: true
{{end}}
{{if .Trace}}
trace: true
{{end}}

# Connection settings
max_payload: {{ .MaxPayload }}
ping_interval: "{{ .PingInterval }}s"
max_pings_outstanding: {{ .MaxPingsOut }}
`

// GenerateNATSConfig generates a nats-server configuration file.
func GenerateNATSConfig(cfg *NATSServerConfig) ([]byte, error) {
	if cfg == nil {
		cfg = DefaultNATSServerConfig()
	}

	if cfg.SystemAccountPublicKey == "" {
		return nil, ErrSystemAccountPublicKeyRequired
	}

	tmpl, err := template.New("nats.conf").Parse(natsConfigTemplate)
	if err != nil {
		return nil, fmt.Errorf("parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, cfg); err != nil {
		return nil, fmt.Errorf("execute template: %w", err)
	}

	return buf.Bytes(), nil
}

// NATSBootstrapFiles represents the files generated during NATS bootstrap.
type NATSBootstrapFiles struct {
	// ConfigFile is the nats.conf content
	ConfigFile []byte

	// OperatorJWT is the operator JWT content
	OperatorJWT []byte

	// SystemAccountJWT is the system account JWT content
	SystemAccountJWT []byte

	// OperatorSeed is the operator seed (sensitive - only for initial setup)
	OperatorSeed string

	// SystemAccountSeed is the system account seed (sensitive - only for initial setup)
	SystemAccountSeed string
}

// NATSBootstrapRequest contains parameters for bootstrapping a NATS server.
type NATSBootstrapRequest struct {
	// OperatorName is the name for the NATS operator
	OperatorName string

	// ExistingOperatorSeed allows importing an existing operator seed
	ExistingOperatorSeed string

	// GenerateSystemAccount indicates whether to generate a system account
	GenerateSystemAccount bool

	// ConfigOverrides allows customizing the generated configuration
	ConfigOverrides *NATSServerConfig
}

// CollectorCredsConfig contains parameters for generating collector NATS credentials.
type CollectorCredsConfig struct {
	// TenantSlug is the tenant's slug for subject prefixing
	TenantSlug string

	// CollectorType is the type of collector (flowgger, trapd, netflow, otel)
	CollectorType string

	// UserName is the NATS user name
	UserName string

	// CredsContent is the .creds file content
	CredsContent string

	// ConfigContent is the collector-specific configuration
	ConfigContent string
}

// GenerateCollectorPermissions returns NATS permissions for a specific collector type.
func GenerateCollectorPermissions(tenantSlug, collectorType string) (publishAllow, subscribeAllow []string) {
	prefix := tenantSlug + "."

	switch collectorType {
	case "flowgger":
		publishAllow = []string{
			prefix + "logs.syslog.>",
		}
		subscribeAllow = []string{}

	case "trapd":
		publishAllow = []string{
			prefix + "logs.snmp.>",
		}
		subscribeAllow = []string{}

	case "netflow":
		publishAllow = []string{
			prefix + "netflow.>",
			prefix + "events.netflow.>",
		}
		subscribeAllow = []string{}

	case "otel":
		publishAllow = []string{
			prefix + "otel.traces.>",
			prefix + "otel.metrics.>",
			prefix + "logs.otel",
		}
		subscribeAllow = []string{}

	default:
		// Generic collector permissions
		publishAllow = []string{
			prefix + "events.>",
		}
		subscribeAllow = []string{}
	}

	return publishAllow, subscribeAllow
}
