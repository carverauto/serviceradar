# Copyright 2025 Carver Automation Corporation.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

name: Publish Release Artifacts

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag to publish (defaults to the event tag or VERSION file)."
        required: false
        type: string
      dry_run:
        description: "Run publish_packages in --dry_run mode."
        required: false
        type: boolean
        default: false
      append_notes:
        description: "Append notes when updating an existing release."
        required: false
        type: boolean
        default: false
      prerelease:
        description: "Mark the GitHub release as a prerelease."
        required: false
        type: boolean
        default: false
      draft:
        description: "Create the GitHub release as a draft."
        required: false
        type: boolean
        default: false
      overwrite_assets:
        description: "Replace assets on the release when filenames match."
        required: false
        type: boolean
        default: true

permissions:
  contents: write
  packages: write

jobs:
  publish:
    runs-on: oracle
    env:
      BUILDBUDDY_ORG_API_KEY: ${{ secrets.BUILDBUDDY_ORG_API_KEY }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Configure BuildBuddy remote cache
        if: ${{ env.BUILDBUDDY_ORG_API_KEY != '' }}
        run: |
          umask 077
          printf 'common --remote_header=x-buildbuddy-api-key=%s\n' "${BUILDBUDDY_ORG_API_KEY}" > .bazelrc.remote

      - name: Resolve release metadata
        id: release
        env:
          INPUT_TAG: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.tag || '' }}
          INPUT_DRY_RUN: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.dry_run || 'false' }}
          INPUT_APPEND_NOTES: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.append_notes || 'false' }}
          INPUT_PRERELEASE: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.prerelease || 'false' }}
          INPUT_DRAFT: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.draft || 'false' }}
          INPUT_OVERWRITE: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.overwrite_assets || 'true' }}
        run: |
          set -euo pipefail

          tag="$INPUT_TAG"
          if [[ -z "$tag" && "${GITHUB_REF}" == refs/tags/* ]]; then
            tag="${GITHUB_REF#refs/tags/}"
          fi
          if [[ -z "$tag" ]]; then
            tag="$(< VERSION)"
          fi
          if [[ -z "$tag" ]]; then
            echo "Unable to determine release tag" >&2
            exit 1
          fi

          version="${tag#v}"
          file_version="$(< VERSION)"
          file_version="${file_version%%[$'\r\n']*}"
          if [[ -n "$file_version" && "$file_version" != "$version" ]]; then
            echo "VERSION file ($file_version) does not match release tag ($version)" >&2
            exit 1
          fi

          echo "tag=${tag}" >> "$GITHUB_OUTPUT"
          echo "version=${version}" >> "$GITHUB_OUTPUT"
          echo "dry_run=${INPUT_DRY_RUN}" >> "$GITHUB_OUTPUT"
          echo "append_notes=${INPUT_APPEND_NOTES}" >> "$GITHUB_OUTPUT"
          echo "prerelease=${INPUT_PRERELEASE}" >> "$GITHUB_OUTPUT"
          echo "draft=${INPUT_DRAFT}" >> "$GITHUB_OUTPUT"
          echo "overwrite_assets=${INPUT_OVERWRITE}" >> "$GITHUB_OUTPUT"

      - name: Generate release notes from CHANGELOG
        id: notes
        env:
          VERSION: ${{ steps.release.outputs.version }}
        run: |
          set -euo pipefail
          notes_file="${RUNNER_TEMP}/release-notes.md"
          if scripts/extract-changelog.py "$VERSION" --output "$notes_file"; then
            echo "Using changelog entry for version $VERSION" >&2
          else
            echo "CHANGELOG entry not found for $VERSION, falling back to autogenerated notes" >&2
            {
              printf '# ServiceRadar %s\n\n' "$VERSION"
              printf 'Automated release generated by GitHub Actions.\n'
            } > "$notes_file"
          fi
          echo "path=${notes_file}" >> "$GITHUB_OUTPUT"
          echo "---- release notes preview ----"
          cat "$notes_file"
          echo "--------------------------------"

      - name: Build Kong vendor artifacts
        run: ./scripts/build-kong-vendor.sh

      - name: Publish Debian and RPM packages
        env:
          RELEASE_TAG: ${{ steps.release.outputs.tag }}
          NOTES_FILE: ${{ steps.notes.outputs.path }}
          DRY_RUN: ${{ steps.release.outputs.dry_run }}
          APPEND_NOTES: ${{ steps.release.outputs.append_notes }}
          PRERELEASE: ${{ steps.release.outputs.prerelease }}
          DRAFT: ${{ steps.release.outputs.draft }}
          OVERWRITE_ASSETS: ${{ steps.release.outputs.overwrite_assets }}
        run: |
          set -euo pipefail

          if [[ -z "$RELEASE_TAG" ]]; then
            echo "Release tag is empty" >&2
            exit 1
          fi

          declare -a args
          args+=("--tag" "$RELEASE_TAG")
          if [[ -n "$NOTES_FILE" ]]; then
            args+=("--notes_file" "$NOTES_FILE")
          fi
          if [[ "$DRY_RUN" == "true" ]]; then
            args+=("--dry_run")
          fi
          if [[ "$APPEND_NOTES" == "true" ]]; then
            args+=("--append_notes")
          fi
          if [[ "$PRERELEASE" == "true" ]]; then
            args+=("--prerelease")
          fi
          if [[ "$DRAFT" == "true" ]]; then
            args+=("--draft")
          fi
          if [[ "$OVERWRITE_ASSETS" != "true" ]]; then
            args+=("--overwrite_assets=${OVERWRITE_ASSETS}")
          fi

          bazel run --config=remote --stamp //release:publish_packages -- "${args[@]}"

      - name: Verify uploaded release assets via API
        env:
          RELEASE_TAG: ${{ steps.release.outputs.tag }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          api_url="https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/tags/${RELEASE_TAG}"
          response=$(curl -sSf -H "Accept: application/vnd.github+json" -H "Authorization: Bearer ${GITHUB_TOKEN}" "$api_url")
          printf 'Release asset summary for %s:\n' "$RELEASE_TAG"
          echo "$response" | jq '.assets[]? | {name, size, download_count}'
          deb_count=$(echo "$response" | jq '[.assets[]? | select(.name | endswith(".deb"))] | length')
          rpm_count=$(echo "$response" | jq '[.assets[]? | select(.name | endswith(".rpm"))] | length')
          pkg_count=$(echo "$response" | jq '[.assets[]? | select(.name | endswith(".pkg"))] | length')
          if (( deb_count == 0 )); then
            echo "No .deb assets detected for ${RELEASE_TAG}" >&2
            exit 1
          fi
          if (( rpm_count == 0 )); then
            echo "No .rpm assets detected for ${RELEASE_TAG}" >&2
            exit 1
          fi
          if (( pkg_count == 0 )); then
            echo "No .pkg assets detected for ${RELEASE_TAG}" >&2
            exit 1
          fi
          echo "Validated presence of ${deb_count} .deb, ${rpm_count} .rpm, and ${pkg_count} .pkg assets."
