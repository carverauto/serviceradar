"""Bazel-native OCI images."""

load("@rules_pkg//pkg:pkg.bzl", "pkg_tar")
load("@rules_oci//oci:defs.bzl", "oci_image", "oci_load")
load("//docker/images:push_targets.bzl", "declare_ghcr_push_targets")

exports_files([
    "export_rootfs_from_layout.py",
    "extract_rootfs.py",
    "overlay_deb_packages.py",
    "pg_config_rewrite.py",
    "pg_config_wrapper.sh",
])

package(default_visibility = ["//visibility:public"])

pkg_tar(
    name = "common_tools_amd64",
    files = {
        "@jq_linux_amd64//file": "usr/local/bin/jq",
        "@curl_linux_amd64//file": "usr/local/bin/curl",
        "@grpcurl_linux_amd64//:grpcurl": "usr/local/bin/grpcurl",
        "//cmd/tools/waitforport:wait-for-port": "usr/local/bin/wait-for-port",
    },
    modes = {
        "usr/local/bin/jq": "0755",
        "usr/local/bin/curl": "0755",
        "usr/local/bin/grpcurl": "0755",
        "usr/local/bin/wait-for-port": "0755",
    },
    package_dir = "/",
)

genrule(
    name = "apk_iputils_ping_rootfs_amd64",
    srcs = ["@alpine_iputils_ping_apk//file"],
    outs = ["apk_iputils_ping_rootfs_amd64.tar"],
    cmd = """
set -euo pipefail
APK=$(location @alpine_iputils_ping_apk//file)
TMP=$(@D)/iputils_ping_extract
rm -rf "$${TMP}"
mkdir -p "$${TMP}/extracted" "$${TMP}/rootfs"
tar -xzf "$${APK}" -C "$${TMP}/extracted"
DATA_TAR=`find "$${TMP}/extracted" -maxdepth 1 -type f -name 'data.tar.*' -print -quit`
if [ -n "$${DATA_TAR}" ]; then
  case "$${DATA_TAR}" in
    *.gz) tar -xzf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *.xz) tar -xJf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *.bz2) tar -xjf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *) tar -xf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
  esac
else
  shopt -s nullglob
  for entry in "$${TMP}/extracted"/*; do
    base=`basename "$${entry}"`
    case "$${base}" in
      .SIGN*|.PKGINFO) continue ;;
    esac
    cp -a "$${entry}" "$${TMP}/rootfs/"
  done
fi
tar -czf "$@" -C "$${TMP}/rootfs" .
""",
)

genrule(
    name = "apk_nmap_rootfs_amd64",
    srcs = ["@alpine_nmap_apk//file"],
    outs = ["apk_nmap_rootfs_amd64.tar"],
    cmd = """
set -euo pipefail
APK=$(location @alpine_nmap_apk//file)
TMP=$(@D)/nmap_extract
rm -rf "$${TMP}"
mkdir -p "$${TMP}/extracted" "$${TMP}/rootfs"
tar -xzf "$${APK}" -C "$${TMP}/extracted"
DATA_TAR=`find "$${TMP}/extracted" -maxdepth 1 -type f -name 'data.tar.*' -print -quit`
if [ -n "$${DATA_TAR}" ]; then
  case "$${DATA_TAR}" in
    *.gz) tar -xzf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *.xz) tar -xJf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *.bz2) tar -xjf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *) tar -xf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
  esac
else
  shopt -s nullglob
  for entry in "$${TMP}/extracted"/*; do
    base=`basename "$${entry}"`
    case "$${base}" in
      .SIGN*|.PKGINFO) continue ;;
    esac
    cp -a "$${entry}" "$${TMP}/rootfs/"
  done
fi
tar -czf "$@" -C "$${TMP}/rootfs" .
""",
)

genrule(
    name = "apk_netcat_rootfs_amd64",
    srcs = ["@alpine_netcat_openbsd_apk//file"],
    outs = ["apk_netcat_rootfs_amd64.tar"],
    cmd = """
set -euo pipefail
APK=$(location @alpine_netcat_openbsd_apk//file)
TMP=$(@D)/netcat_extract
rm -rf "$${TMP}"
mkdir -p "$${TMP}/extracted" "$${TMP}/rootfs"
tar -xzf "$${APK}" -C "$${TMP}/extracted"
DATA_TAR=`find "$${TMP}/extracted" -maxdepth 1 -type f -name 'data.tar.*' -print -quit`
if [ -n "$${DATA_TAR}" ]; then
  case "$${DATA_TAR}" in
    *.gz) tar -xzf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *.xz) tar -xJf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *.bz2) tar -xjf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *) tar -xf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
  esac
else
  shopt -s nullglob
  for entry in "$${TMP}/extracted"/*; do
    base=`basename "$${entry}"`
    case "$${base}" in
      .SIGN*|.PKGINFO) continue ;;
    esac
    cp -a "$${entry}" "$${TMP}/rootfs/"
  done
fi
tar -czf "$@" -C "$${TMP}/rootfs" .
""",
)

genrule(
    name = "apk_bash_rootfs_amd64",
    srcs = ["@alpine_bash_apk//file"],
    outs = ["apk_bash_rootfs_amd64.tar"],
    cmd = """
set -euo pipefail
APK=$(location @alpine_bash_apk//file)
TMP=$(@D)/bash_extract
rm -rf "$${TMP}"
mkdir -p "$${TMP}/extracted" "$${TMP}/rootfs"
tar -xzf "$${APK}" -C "$${TMP}/extracted"
DATA_TAR=`find "$${TMP}/extracted" -maxdepth 1 -type f -name 'data.tar.*' -print -quit`
if [ -n "$${DATA_TAR}" ]; then
  case "$${DATA_TAR}" in
    *.gz) tar -xzf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *.xz) tar -xJf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *.bz2) tar -xjf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *) tar -xf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
  esac
else
  shopt -s nullglob
  for entry in "$${TMP}/extracted"/*; do
    base=`basename "$${entry}"`
    case "$${base}" in
      .SIGN*|.PKGINFO) continue ;;
    esac
    cp -a "$${entry}" "$${TMP}/rootfs/"
  done
fi
tar -czf "$@" -C "$${TMP}/rootfs" .
""",
)

genrule(
    name = "apk_readline_rootfs_amd64",
    srcs = ["@alpine_readline_apk//file"],
    outs = ["apk_readline_rootfs_amd64.tar"],
    cmd = """
set -euo pipefail
APK=$(location @alpine_readline_apk//file)
TMP=$(@D)/readline_extract
rm -rf "$${TMP}"
mkdir -p "$${TMP}/extracted" "$${TMP}/rootfs"
tar -xzf "$${APK}" -C "$${TMP}/extracted"
DATA_TAR=`find "$${TMP}/extracted" -maxdepth 1 -type f -name 'data.tar.*' -print -quit`
if [ -n "$${DATA_TAR}" ]; then
  case "$${DATA_TAR}" in
    *.gz) tar -xzf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *.xz) tar -xJf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *.bz2) tar -xjf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *) tar -xf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
  esac
else
  shopt -s nullglob
  for entry in "$${TMP}/extracted"/*; do
    base=`basename "$${entry}"`
    case "$${base}" in
      .SIGN*|.PKGINFO) continue ;;
    esac
    cp -a "$${entry}" "$${TMP}/rootfs/"
  done
fi
tar -czf "$@" -C "$${TMP}/rootfs" .
""",
)

genrule(
    name = "apk_postgresql16_client_rootfs_amd64",
    srcs = ["@alpine_postgresql16_client_apk//file"],
    outs = ["apk_postgresql16_client_rootfs_amd64.tar"],
    cmd = """
set -euo pipefail
APK=$(location @alpine_postgresql16_client_apk//file)
TMP=$(@D)/postgresql16_client_extract
rm -rf "$${TMP}"
mkdir -p "$${TMP}/extracted" "$${TMP}/rootfs"
tar -xzf "$${APK}" -C "$${TMP}/extracted"
DATA_TAR=`find "$${TMP}/extracted" -maxdepth 1 -type f -name 'data.tar.*' -print -quit`
if [ -n "$${DATA_TAR}" ]; then
  case "$${DATA_TAR}" in
    *.gz) tar -xzf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *.xz) tar -xJf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *.bz2) tar -xjf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *) tar -xf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
  esac
else
  shopt -s nullglob
  for entry in "$${TMP}/extracted"/*; do
    base=`basename "$${entry}"`
    case "$${base}" in
      .SIGN*|.PKGINFO) continue ;;
    esac
    cp -a "$${entry}" "$${TMP}/rootfs/"
  done
fi
tar -czf "$@" -C "$${TMP}/rootfs" .
""",
)

genrule(
    name = "apk_libpq16_rootfs_amd64",
    srcs = ["@alpine_libpq16_apk//file"],
    outs = ["apk_libpq16_rootfs_amd64.tar"],
    cmd = """
set -euo pipefail
APK=$(location @alpine_libpq16_apk//file)
TMP=$(@D)/libpq16_extract
rm -rf "$${TMP}"
mkdir -p "$${TMP}/extracted" "$${TMP}/rootfs"
tar -xzf "$${APK}" -C "$${TMP}/extracted"
DATA_TAR=`find "$${TMP}/extracted" -maxdepth 1 -type f -name 'data.tar.*' -print -quit`
if [ -n "$${DATA_TAR}" ]; then
  case "$${DATA_TAR}" in
    *.gz) tar -xzf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *.xz) tar -xJf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *.bz2) tar -xjf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *) tar -xf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
  esac
else
  shopt -s nullglob
  for entry in "$${TMP}/extracted"/*; do
    base=`basename "$${entry}"`
    case "$${base}" in
      .SIGN*|.PKGINFO) continue ;;
    esac
    cp -a "$${entry}" "$${TMP}/rootfs/"
  done
fi
tar -czf "$@" -C "$${TMP}/rootfs" .
""",
)

genrule(
    name = "apk_glibc_rootfs_amd64",
    srcs = ["@alpine_glibc_apk//file"],
    outs = ["apk_glibc_rootfs_amd64.tar"],
    cmd = """
set -euo pipefail
APK=$(location @alpine_glibc_apk//file)
TMP=$(@D)/glibc_extract
rm -rf "$${TMP}"
mkdir -p "$${TMP}/extracted" "$${TMP}/rootfs"
tar -xzf "$${APK}" -C "$${TMP}/extracted"
DATA_TAR=`find "$${TMP}/extracted" -maxdepth 1 -type f -name 'data.tar.*' -print -quit`
if [ -n "$${DATA_TAR}" ]; then
  case "$${DATA_TAR}" in
    *.gz) tar -xzf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *.xz) tar -xJf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *.bz2) tar -xjf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *) tar -xf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
  esac
else
  shopt -s nullglob
  for entry in "$${TMP}/extracted"/*; do
    base=`basename "$${entry}"`
    case "$${base}" in
      .SIGN*|.PKGINFO) continue ;;
    esac
    cp -a "$${entry}" "$${TMP}/rootfs/"
  done
fi
# Ensure ld-linux is reachable from /lib64 for glibc binaries.
mkdir -p "$${TMP}/rootfs/lib64"
if [ -f "$${TMP}/rootfs/lib/ld-linux-x86-64.so.2" ] && [ ! -e "$${TMP}/rootfs/lib64/ld-linux-x86-64.so.2" ]; then
  ln -s ../lib/ld-linux-x86-64.so.2 "$${TMP}/rootfs/lib64/ld-linux-x86-64.so.2"
fi
tar -czf "$@" -C "$${TMP}/rootfs" .
""",
)

genrule(
    name = "apk_libncursesw_rootfs_amd64",
    srcs = ["@alpine_libncursesw_apk//file"],
    outs = ["apk_libncursesw_rootfs_amd64.tar"],
    cmd = """
set -euo pipefail
APK=$(location @alpine_libncursesw_apk//file)
TMP=$(@D)/libncursesw_extract
rm -rf "$${TMP}"
mkdir -p "$${TMP}/extracted" "$${TMP}/rootfs"
tar -xzf "$${APK}" -C "$${TMP}/extracted"
DATA_TAR=`find "$${TMP}/extracted" -maxdepth 1 -type f -name 'data.tar.*' -print -quit`
if [ -n "$${DATA_TAR}" ]; then
  case "$${DATA_TAR}" in
    *.gz) tar -xzf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *.xz) tar -xJf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *.bz2) tar -xjf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *) tar -xf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
  esac
else
  shopt -s nullglob
  for entry in "$${TMP}/extracted"/*; do
    base=`basename "$${entry}"`
    case "$${base}" in
      .SIGN*|.PKGINFO) continue ;;
    esac
    cp -a "$${entry}" "$${TMP}/rootfs/"
  done
fi
tar -czf "$@" -C "$${TMP}/rootfs" .
""",
)

genrule(
    name = "apk_ncurses_terminfo_base_rootfs_amd64",
    srcs = ["@alpine_ncurses_terminfo_base_apk//file"],
    outs = ["apk_ncurses_terminfo_base_rootfs_amd64.tar"],
    cmd = """
set -euo pipefail
APK=$(location @alpine_ncurses_terminfo_base_apk//file)
TMP=$(@D)/ncurses_terminfo_base_extract
rm -rf "$${TMP}"
mkdir -p "$${TMP}/extracted" "$${TMP}/rootfs"
tar -xzf "$${APK}" -C "$${TMP}/extracted"
DATA_TAR=`find "$${TMP}/extracted" -maxdepth 1 -type f -name 'data.tar.*' -print -quit`
if [ -n "$${DATA_TAR}" ]; then
  case "$${DATA_TAR}" in
    *.gz) tar -xzf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *.xz) tar -xJf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *.bz2) tar -xjf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
    *) tar -xf "$${DATA_TAR}" -C "$${TMP}/rootfs" ;;
  esac
else
  shopt -s nullglob
  for entry in "$${TMP}/extracted"/*; do
    base=`basename "$${entry}"`
    case "$${base}" in
      .SIGN*|.PKGINFO) continue ;;
    esac
    cp -a "$${entry}" "$${TMP}/rootfs/"
  done
fi
tar -czf "$@" -C "$${TMP}/rootfs" .
""",
)

genrule(
    name = "alpine_netutils_rootfs_amd64",
    srcs = [
        ":apk_iputils_ping_rootfs_amd64.tar",
        ":apk_nmap_rootfs_amd64.tar",
        ":apk_netcat_rootfs_amd64.tar",
    ],
    outs = ["alpine_netutils_rootfs_amd64.tar"],
    cmd = """
set -euo pipefail
ROOT=$(@D)/netutils_root
rm -rf "$${ROOT}"
mkdir -p "$${ROOT}"
for tarfile in $(SRCS); do
  tar -xzf "$${tarfile}" -C "$${ROOT}"
done
tar -czf "$@" -C "$${ROOT}" .
""",
)

pkg_tar(
    name = "core_layer_amd64",
    files = {
        "//cmd/core:core": "usr/local/bin/serviceradar-core",
        "//docker/compose:entrypoint-core.sh": "usr/local/bin/entrypoint.sh",
        "@jq_linux_amd64//file": "usr/local/bin/jq",
        "@curl_linux_amd64//file": "usr/local/bin/curl",
        "@grpcurl_linux_amd64//:grpcurl": "usr/local/bin/grpcurl",
    },
    modes = {
        "usr/local/bin/serviceradar-core": "0755",
        "usr/local/bin/entrypoint.sh": "0755",
        "usr/local/bin/jq": "0755",
        "usr/local/bin/curl": "0755",
        "usr/local/bin/grpcurl": "0755",
    },
    empty_dirs = [
        "etc/serviceradar",
        "var/log/serviceradar",
        "var/lib/serviceradar",
        "data",
    ],
    package_dir = "/",
)

oci_image(
    name = "core_image_amd64",
    base = "@ubuntu_jammy_linux_amd64//:ubuntu_jammy_linux_amd64",
    tars = [":core_layer_amd64"],
    entrypoint = ["/usr/local/bin/entrypoint.sh"],
    cmd = ["serviceradar-core"],
    workdir = "/data",
    env = {
        "PATH": "/usr/local/bin:/usr/bin:/bin",
    },
    exposed_ports = ["8090/tcp", "50052/tcp"],
    labels = {
        "org.opencontainers.image.title": "serviceradar-core",
    },
)

oci_load(
    name = "core_image_amd64_tar",
    image = ":core_image_amd64",
    repo_tags = ["ghcr.io/carverauto/serviceradar-core:local"],
)

pkg_tar(
    name = "agent_layer_amd64",
    files = {
        "//cmd/agent:agent": "usr/local/bin/serviceradar-agent",
        "//docker/compose:agent.docker.json": "etc/serviceradar/agent.json",
        "//docker/compose:sweep.docker.json": "etc/serviceradar/checkers/sweep/sweep.json",
    },
    modes = {
        "usr/local/bin/serviceradar-agent": "0755",
        "etc/serviceradar/agent.json": "0644",
        "etc/serviceradar/checkers/sweep/sweep.json": "0644",
    },
    empty_dirs = [
        "var/lib/serviceradar",
        "var/log/serviceradar",
    ],
    package_dir = "/",
)

oci_image(
    name = "agent_image_amd64",
    base = "@alpine_3_20_linux_amd64//:alpine_3_20_linux_amd64",
    tars = [":alpine_netutils_rootfs_amd64", ":common_tools_amd64", ":agent_layer_amd64"],
    cmd = ["/usr/local/bin/serviceradar-agent", "-config", "/etc/serviceradar/agent.json"],
    env = {
        "PATH": "/usr/local/bin:/usr/bin:/bin",
    },
    workdir = "/var/lib/serviceradar",
    exposed_ports = ["50051/tcp"],
    labels = {
        "org.opencontainers.image.title": "serviceradar-agent",
    },
)

oci_load(
    name = "agent_image_amd64_tar",
    image = ":agent_image_amd64",
    repo_tags = ["ghcr.io/carverauto/serviceradar-agent:local"],
)

pkg_tar(
    name = "db_event_writer_layer_amd64",
    files = {
        "//cmd/consumers/db-event-writer:db-event-writer": "usr/local/bin/serviceradar-db-event-writer",
        "//docker/compose:entrypoint-db-event-writer.sh": "usr/local/bin/entrypoint.sh",
    },
    modes = {
        "usr/local/bin/serviceradar-db-event-writer": "0755",
        "usr/local/bin/entrypoint.sh": "0755",
    },
    empty_dirs = [
        "etc/serviceradar/consumers",
        "etc/serviceradar/templates",
        "var/lib/serviceradar",
        "var/log/serviceradar",
    ],
    package_dir = "/",
)

oci_image(
    name = "db_event_writer_image_amd64",
    base = "@alpine_3_20_linux_amd64//:alpine_3_20_linux_amd64",
    tars = [":alpine_netutils_rootfs_amd64", ":common_tools_amd64", ":db_event_writer_layer_amd64"],
    entrypoint = ["/usr/local/bin/entrypoint.sh"],
    cmd = ["serviceradar-db-event-writer"],
    env = {
        "PATH": "/usr/local/bin:/usr/bin:/bin",
    },
    workdir = "/var/lib/serviceradar",
    exposed_ports = ["50041/tcp"],
    labels = {
        "org.opencontainers.image.title": "serviceradar-db-event-writer",
    },
)

oci_load(
    name = "db_event_writer_image_amd64_tar",
    image = ":db_event_writer_image_amd64",
    repo_tags = ["ghcr.io/carverauto/serviceradar-db-event-writer:local"],
)

pkg_tar(
    name = "mapper_layer_amd64",
    files = {
        "//cmd/mapper:mapper": "usr/local/bin/serviceradar-mapper",
        "//docker/compose:entrypoint-mapper.sh": "usr/local/bin/entrypoint.sh",
    },
    modes = {
        "usr/local/bin/serviceradar-mapper": "0755",
        "usr/local/bin/entrypoint.sh": "0755",
    },
    empty_dirs = [
        "etc/serviceradar",
        "var/lib/serviceradar",
        "var/log/serviceradar",
    ],
    package_dir = "/",
)

oci_image(
    name = "mapper_image_amd64",
    base = "@alpine_3_20_linux_amd64//:alpine_3_20_linux_amd64",
    tars = [":alpine_netutils_rootfs_amd64", ":common_tools_amd64", ":mapper_layer_amd64"],
    entrypoint = ["/usr/local/bin/entrypoint.sh"],
    cmd = ["serviceradar-mapper"],
    env = {
        "PATH": "/usr/local/bin:/usr/bin:/bin",
    },
    workdir = "/var/lib/serviceradar",
    exposed_ports = ["50056/tcp"],
    labels = {
        "org.opencontainers.image.title": "serviceradar-mapper",
    },
)

oci_load(
    name = "mapper_image_amd64_tar",
    image = ":mapper_image_amd64",
    repo_tags = ["ghcr.io/carverauto/serviceradar-mapper:local"],
)

pkg_tar(
    name = "datasvc_layer_amd64",
    files = {
        "//cmd/data-services:data_services": "usr/local/bin/serviceradar-datasvc",
        "//docker/compose:entrypoint-datasvc.sh": "usr/local/bin/entrypoint.sh",
        "//docker/compose:datasvc.docker.json": "etc/serviceradar/datasvc.json",
    },
    modes = {
        "usr/local/bin/serviceradar-datasvc": "0755",
        "usr/local/bin/entrypoint.sh": "0755",
        "etc/serviceradar/datasvc.json": "0644",
    },
    empty_dirs = [
        "var/lib/serviceradar",
        "var/log/serviceradar",
    ],
    package_dir = "/",
)

oci_image(
    name = "datasvc_image_amd64",
    base = "@alpine_3_20_linux_amd64//:alpine_3_20_linux_amd64",
    tars = [":alpine_netutils_rootfs_amd64", ":common_tools_amd64", ":datasvc_layer_amd64"],
    entrypoint = ["/usr/local/bin/entrypoint.sh"],
    cmd = ["/usr/local/bin/serviceradar-datasvc"],
    env = {
        "PATH": "/usr/local/bin:/usr/bin:/bin",
    },
    workdir = "/var/lib/serviceradar",
    exposed_ports = ["50057/tcp"],
    labels = {
        "org.opencontainers.image.title": "serviceradar-datasvc",
    },
)

oci_load(
    name = "datasvc_image_amd64_tar",
    image = ":datasvc_image_amd64",
    repo_tags = ["ghcr.io/carverauto/serviceradar-datasvc:local"],
)

pkg_tar(
    name = "flowgger_layer_amd64",
    files = {
        "//cmd/flowgger:flowgger": "usr/local/bin/serviceradar-flowgger",
        "//docker/compose:entrypoint-flowgger.sh": "usr/local/bin/entrypoint.sh",
        "//docker/compose:flowgger.docker.toml": "etc/serviceradar/flowgger.toml",
    },
    modes = {
        "usr/local/bin/serviceradar-flowgger": "0755",
        "usr/local/bin/entrypoint.sh": "0755",
        "etc/serviceradar/flowgger.toml": "0644",
    },
    empty_dirs = [
        "etc/serviceradar/checkers",
        "etc/serviceradar/certs",
        "var/log/serviceradar",
        "var/lib/serviceradar",
    ],
    package_dir = "/",
)

oci_image(
    name = "flowgger_image_amd64",
    base = "@debian_testing_slim_linux_amd64//:debian_testing_slim_linux_amd64",
    tars = [":common_tools_amd64", ":flowgger_layer_amd64"],
    entrypoint = ["/usr/local/bin/entrypoint.sh"],
    cmd = ["serviceradar-flowgger"],
    env = {
        "PATH": "/usr/local/bin:/usr/bin:/bin",
    },
    workdir = "/var/lib/serviceradar",
    exposed_ports = ["514/udp", "50044/tcp"],
    labels = {
        "org.opencontainers.image.title": "serviceradar-flowgger",
    },
)

oci_load(
    name = "flowgger_image_amd64_tar",
    image = ":flowgger_image_amd64",
    repo_tags = ["ghcr.io/carverauto/serviceradar-flowgger:local"],
)

pkg_tar(
    name = "trapd_layer_amd64",
    files = {
        "//cmd/trapd:trapd": "usr/local/bin/serviceradar-trapd",
        "//docker/compose:entrypoint-trapd.sh": "usr/local/bin/entrypoint.sh",
        "//docker/compose:trapd.docker.json": "etc/serviceradar/trapd.json",
    },
    modes = {
        "usr/local/bin/serviceradar-trapd": "0755",
        "usr/local/bin/entrypoint.sh": "0755",
        "etc/serviceradar/trapd.json": "0644",
    },
    empty_dirs = [
        "etc/serviceradar/certs",
        "var/log/serviceradar",
        "var/lib/serviceradar",
    ],
    package_dir = "/",
)

oci_image(
    name = "trapd_image_amd64",
    base = "@ubuntu_jammy_linux_amd64//:ubuntu_jammy_linux_amd64",
    tars = [":common_tools_amd64", ":trapd_layer_amd64"],
    entrypoint = ["/usr/local/bin/entrypoint.sh"],
    cmd = ["serviceradar-trapd"],
    env = {
        "PATH": "/usr/local/bin:/usr/bin:/bin",
    },
    workdir = "/var/lib/serviceradar",
    exposed_ports = ["162/udp", "50043/tcp"],
    labels = {
        "org.opencontainers.image.title": "serviceradar-trapd",
    },
)

oci_load(
    name = "trapd_image_amd64_tar",
    image = ":trapd_image_amd64",
    repo_tags = ["ghcr.io/carverauto/serviceradar-trapd:local"],
)

pkg_tar(
    name = "otel_layer_amd64",
    files = {
        "//cmd/otel:otel": "usr/local/bin/serviceradar-otel",
        "//docker/compose:entrypoint-otel.sh": "usr/local/bin/entrypoint.sh",
        "//docker/compose:otel.docker.toml": "etc/serviceradar/otel.toml",
    },
    modes = {
        "usr/local/bin/serviceradar-otel": "0755",
        "usr/local/bin/entrypoint.sh": "0755",
        "etc/serviceradar/otel.toml": "0644",
    },
    empty_dirs = [
        "etc/serviceradar/certs",
        "var/log/serviceradar",
        "var/lib/serviceradar",
    ],
    package_dir = "/",
)

oci_image(
    name = "otel_image_amd64",
    base = "@ubuntu_jammy_linux_amd64//:ubuntu_jammy_linux_amd64",
    tars = [":common_tools_amd64", ":otel_layer_amd64"],
    entrypoint = ["/usr/local/bin/entrypoint.sh"],
    cmd = ["serviceradar-otel"],
    env = {
        "PATH": "/usr/local/bin:/usr/bin:/bin",
    },
    workdir = "/var/lib/serviceradar",
    exposed_ports = ["4317/tcp"],
    labels = {
        "org.opencontainers.image.title": "serviceradar-otel",
    },
)

oci_load(
    name = "otel_image_amd64_tar",
    image = ":otel_image_amd64",
    repo_tags = ["ghcr.io/carverauto/serviceradar-otel:local"],
)

pkg_tar(
    name = "snmp_checker_layer_amd64",
    files = {
        "//cmd/checkers/snmp:snmp": "usr/local/bin/serviceradar-snmp-checker",
        "//docker/compose:entrypoint-snmp-checker.sh": "usr/local/bin/entrypoint.sh",
        "//docker/compose:snmp-checker.docker.json": "etc/serviceradar/checkers/snmp.json",
    },
    modes = {
        "usr/local/bin/serviceradar-snmp-checker": "0755",
        "usr/local/bin/entrypoint.sh": "0755",
        "etc/serviceradar/checkers/snmp.json": "0644",
    },
    empty_dirs = [
        "etc/serviceradar/checkers",
        "etc/serviceradar/certs",
        "var/log/serviceradar",
        "var/lib/serviceradar",
    ],
    package_dir = "/",
)

oci_image(
    name = "snmp_checker_image_amd64",
    base = "@alpine_3_20_linux_amd64//:alpine_3_20_linux_amd64",
    tars = [":alpine_netutils_rootfs_amd64", ":common_tools_amd64", ":snmp_checker_layer_amd64"],
    entrypoint = ["/usr/local/bin/entrypoint.sh"],
    cmd = ["serviceradar-snmp-checker"],
    env = {
        "PATH": "/usr/local/bin:/usr/bin:/bin",
    },
    workdir = "/var/lib/serviceradar",
    exposed_ports = ["50054/tcp"],
    labels = {
        "org.opencontainers.image.title": "serviceradar-snmp-checker",
    },
)

oci_load(
    name = "snmp_checker_image_amd64_tar",
    image = ":snmp_checker_image_amd64",
    repo_tags = ["ghcr.io/carverauto/serviceradar-snmp-checker:local"],
)

pkg_tar(
    name = "rperf_client_layer_amd64",
    files = {
        "//cmd/checkers/rperf-client:rperf_checker": "usr/local/bin/serviceradar-rperf-checker",
        "//docker/compose:entrypoint-rperf-client.sh": "usr/local/bin/entrypoint.sh",
        "//docker/compose:rperf-client.docker.json": "tmp/rperf-client.docker.json",
    },
    modes = {
        "usr/local/bin/serviceradar-rperf-checker": "0755",
        "usr/local/bin/entrypoint.sh": "0755",
        "tmp/rperf-client.docker.json": "0644",
    },
    empty_dirs = [
        "etc/serviceradar/checkers",
        "etc/serviceradar/certs",
        "var/log/serviceradar",
        "var/lib/serviceradar",
    ],
    package_dir = "/",
)

oci_image(
    name = "rperf_client_image_amd64",
    base = "@debian_bookworm_slim_linux_amd64//:debian_bookworm_slim_linux_amd64",
    tars = [":common_tools_amd64", ":rperf_client_layer_amd64"],
    entrypoint = ["/usr/local/bin/entrypoint.sh"],
    cmd = ["/usr/local/bin/serviceradar-rperf-checker", "--config", "/etc/serviceradar/checkers/rperf.json"],
    env = {
        "PATH": "/usr/local/bin:/usr/bin:/bin",
    },
    workdir = "/var/lib/serviceradar",
    exposed_ports = ["50059/tcp"],
    labels = {
        "org.opencontainers.image.title": "serviceradar-rperf-client",
    },
)

oci_load(
    name = "rperf_client_image_amd64_tar",
    image = ":rperf_client_image_amd64",
    repo_tags = ["ghcr.io/carverauto/serviceradar-rperf-client:local"],
)

pkg_tar(
    name = "poller_layer_amd64",
    files = {
        "//cmd/poller:poller": "usr/local/bin/serviceradar-poller",
        "//docker/compose:poller.docker.json": "etc/serviceradar/poller.json",
        "//docker/compose:bootstrap-nested-spire.sh": "usr/local/bin/bootstrap-nested-spire",
        "//docker/compose:entrypoint-poller.sh": "usr/local/bin/poller-entrypoint.sh",
        "@spire_linux_amd64//:bin/spire-agent": "usr/local/bin/spire-agent",
        "@spire_linux_amd64//:bin/spire-server": "usr/local/bin/spire-server",
    },
    modes = {
        "usr/local/bin/serviceradar-poller": "0755",
        "etc/serviceradar/poller.json": "0644",
        "usr/local/bin/bootstrap-nested-spire": "0755",
        "usr/local/bin/poller-entrypoint.sh": "0755",
        "usr/local/bin/spire-agent": "0755",
        "usr/local/bin/spire-server": "0755",
    },
    empty_dirs = [
        "etc/serviceradar/certs",
        "etc/serviceradar/config/poller-spire",
        "var/log/serviceradar",
        "var/lib/serviceradar",
        "run/spire/nested",
    ],
    package_dir = "/",
)

oci_image(
    name = "poller_image_amd64",
    base = "@alpine_3_20_linux_amd64//:alpine_3_20_linux_amd64",
    tars = [":alpine_netutils_rootfs_amd64", ":common_tools_amd64", ":poller_layer_amd64"],
    entrypoint = ["/usr/local/bin/poller-entrypoint.sh"],
    cmd = ["/usr/local/bin/serviceradar-poller", "-config", "/etc/serviceradar/poller.json"],
    env = {
        "PATH": "/usr/local/bin:/usr/bin:/bin",
    },
    workdir = "/var/lib/serviceradar",
    exposed_ports = ["50053/tcp"],
    labels = {
        "org.opencontainers.image.title": "serviceradar-poller",
    },
)

oci_load(
    name = "poller_image_amd64_tar",
    image = ":poller_image_amd64",
    repo_tags = ["ghcr.io/carverauto/serviceradar-poller:local"],
)

pkg_tar(
    name = "sync_layer_amd64",
    files = {
        "//cmd/sync:sync": "usr/local/bin/serviceradar-sync",
        "//docker/compose:entrypoint-sync.sh": "usr/local/bin/entrypoint.sh",
        "//docker/compose:sync.docker.json": "etc/serviceradar/sync.json",
    },
    modes = {
        "usr/local/bin/serviceradar-sync": "0755",
        "usr/local/bin/entrypoint.sh": "0755",
        "etc/serviceradar/sync.json": "0644",
    },
    empty_dirs = [
        "etc/serviceradar/certs",
        "var/log/serviceradar",
        "var/lib/serviceradar",
    ],
    package_dir = "/",
)

oci_image(
    name = "sync_image_amd64",
    base = "@ubuntu_jammy_linux_amd64//:ubuntu_jammy_linux_amd64",
    tars = [":common_tools_amd64", ":sync_layer_amd64"],
    entrypoint = ["/usr/local/bin/entrypoint.sh"],
    cmd = ["serviceradar-sync"],
    env = {
        "PATH": "/usr/local/bin:/usr/bin:/bin",
    },
    workdir = "/var/lib/serviceradar",
    exposed_ports = ["50058/tcp"],
    labels = {
        "org.opencontainers.image.title": "serviceradar-sync",
    },
)

oci_load(
    name = "sync_image_amd64_tar",
    image = ":sync_image_amd64",
    repo_tags = ["ghcr.io/carverauto/serviceradar-sync:local"],
)

pkg_tar(
    name = "zen_layer_amd64",
    files = {
        "//cmd/consumers/zen:zen": "usr/local/bin/serviceradar-zen",
        "//cmd/consumers/zen:zen_put_rule": "usr/local/bin/zen-put-rule",
        "//docker/compose:entrypoint-zen.sh": "usr/local/bin/entrypoint.sh",
        "//docker/compose:zen-install-rules.sh": "usr/local/bin/zen-install-rules.sh",
        "//docker/compose:zen.docker.json": "etc/serviceradar/zen.json",
        "//cmd/consumers/zen:data/cef_severity.json": "var/lib/serviceradar/data/cef_severity.json",
        "//cmd/consumers/zen:data/snmp_severity.json": "var/lib/serviceradar/data/snmp_severity.json",
        "//cmd/consumers/zen:data/passthrough.json": "var/lib/serviceradar/data/passthrough.json",
        "//cmd/consumers/zen:data/strip_full_message.json": "var/lib/serviceradar/data/strip_full_message.json",
    },
    modes = {
        "usr/local/bin/serviceradar-zen": "0755",
        "usr/local/bin/zen-put-rule": "0755",
        "usr/local/bin/entrypoint.sh": "0755",
        "usr/local/bin/zen-install-rules.sh": "0755",
        "etc/serviceradar/zen.json": "0644",
        "var/lib/serviceradar/data/cef_severity.json": "0644",
        "var/lib/serviceradar/data/snmp_severity.json": "0644",
        "var/lib/serviceradar/data/passthrough.json": "0644",
        "var/lib/serviceradar/data/strip_full_message.json": "0644",
    },
    empty_dirs = [
        "etc/serviceradar/certs",
        "var/log/serviceradar",
        "var/lib/serviceradar",
    ],
    package_dir = "/",
)

oci_image(
    name = "zen_image_amd64",
    base = "@ubuntu_noble_linux_amd64//:ubuntu_noble_linux_amd64",
    tars = [":common_tools_amd64", ":zen_layer_amd64"],
    entrypoint = ["/usr/local/bin/entrypoint.sh"],
    cmd = ["serviceradar-zen"],
    env = {
        "PATH": "/usr/local/bin:/usr/bin:/bin",
    },
    workdir = "/var/lib/serviceradar",
    exposed_ports = ["50040/tcp"],
    labels = {
        "org.opencontainers.image.title": "serviceradar-zen",
    },
)

oci_load(
    name = "zen_image_amd64_tar",
    image = ":zen_image_amd64",
    repo_tags = ["ghcr.io/carverauto/serviceradar-zen:local"],
)

pkg_tar(
    name = "config_updater_layer_amd64",
    files = {
        "//cmd/cli:cli": "usr/local/bin/serviceradar-cli",
        "//docker/compose:update-config.sh": "usr/local/bin/update-config.sh",
    },
    modes = {
        "usr/local/bin/serviceradar-cli": "0755",
        "usr/local/bin/update-config.sh": "0755",
    },
    empty_dirs = [
        "etc/serviceradar/certs",
        "etc/serviceradar/config",
    ],
    package_dir = "/",
)

oci_image(
    name = "config_updater_image_amd64",
    base = "@alpine_3_20_linux_amd64//:alpine_3_20_linux_amd64",
    tars = [":alpine_netutils_rootfs_amd64", ":common_tools_amd64", ":config_updater_layer_amd64"],
    cmd = ["/usr/local/bin/update-config.sh"],
    env = {
        "PATH": "/usr/local/bin:/usr/bin:/bin",
    },
    workdir = "/",
    labels = {
        "org.opencontainers.image.title": "serviceradar-config-updater",
    },
)

oci_load(
    name = "config_updater_image_amd64_tar",
    image = ":config_updater_image_amd64",
    repo_tags = ["ghcr.io/carverauto/serviceradar-config-updater:local"],
)

pkg_tar(
    name = "nginx_layer_amd64",
    files = {
        "//docker/compose:nginx.conf.template": "etc/nginx/templates/default.conf.template",
        "//docker/compose:entrypoint-nginx.sh": "docker-entrypoint.d/50-serviceradar.sh",
    },
    modes = {
        "etc/nginx/templates/default.conf.template": "0644",
        "docker-entrypoint.d/50-serviceradar.sh": "0755",
    },
    package_dir = "/",
)

oci_image(
    name = "nginx_image_amd64",
    base = "@nginx_alpine_linux_amd64//:nginx_alpine_linux_amd64",
    tars = [
        ":common_tools_amd64",
        ":nginx_layer_amd64",
    ],
    exposed_ports = ["80/tcp"],
    labels = {
        "org.opencontainers.image.title": "serviceradar-nginx",
    },
)

oci_load(
    name = "nginx_image_amd64_tar",
    image = ":nginx_image_amd64",
    repo_tags = ["ghcr.io/carverauto/serviceradar-nginx:local"],
)

pkg_tar(
    name = "web_app_tree_amd64",
    srcs = ["//pkg/core/api/web:files"],
    package_dir = "/app",
)

pkg_tar(
    name = "web_public_root_amd64",
    srcs = ["//web:public_flat"],
    package_dir = "/app/public",
    strip_prefix = "web/public_flat",
)

pkg_tar(
    name = "web_public_standalone_amd64",
    srcs = ["//web:public_flat"],
    package_dir = "/app/.next/standalone/public",
    strip_prefix = "web/public_flat",
)

genrule(
    name = "web_node_modules_amd64",
    srcs = [
        "//web:node_modules/next",
        "//web:node_modules/react",
        "//web:node_modules/react-dom",
    ],
    outs = ["web_node_modules_amd64.tar"],
    cmd = """
set -euo pipefail
TMP=$(@D)/web_node_modules
rm -rf "$${TMP}"
mkdir -p "$${TMP}/app/node_modules"
NODE_MODULES_DIR=$(GENDIR)/web/node_modules
cp -a "$${NODE_MODULES_DIR}/." "$${TMP}/app/node_modules/"
tar -czf "$@" -C "$${TMP}" app
""",
)

pkg_tar(
    name = "web_layer_amd64",
    files = {
        "//docker/compose:entrypoint-web.sh": "usr/local/bin/entrypoint.sh",
        "//docker/compose:web.docker.json": "etc/serviceradar/web.json",
    },
    modes = {
        "usr/local/bin/entrypoint.sh": "0755",
        "etc/serviceradar/web.json": "0644",
    },
    empty_dirs = [
        "etc/serviceradar/certs",
        "etc/serviceradar/config",
    ],
    package_dir = "/",
)

oci_image(
    name = "web_image_base_amd64",
    base = "@node_20_alpine_linux_amd64//:node_20_alpine_linux_amd64",
    tars = [
        ":common_tools_amd64",
        ":web_app_tree_amd64",
        ":web_public_root_amd64",
        ":web_public_standalone_amd64",
        ":web_node_modules_amd64",
        ":web_layer_amd64",
    ],
    entrypoint = ["/usr/local/bin/entrypoint.sh"],
    cmd = ["node", ".next/standalone/server.js"],
    env = {
        "HOSTNAME": "0.0.0.0",
        "NODE_ENV": "production",
        "PATH": "/usr/local/bin:/usr/bin:/bin",
        "PORT": "3000",
    },
    workdir = "/app",
    exposed_ports = ["3000/tcp"],
    labels = {
        "org.opencontainers.image.title": "serviceradar-web",
    },
)

genrule(
    name = "web_build_info_json",
    srcs = [
        ":web_image_base_amd64.digest",
        "//docker/images:core_image_amd64.digest",
        "//:VERSION",
    ],
    outs = ["web_build_info.json"],
    stamp = True,
    cmd = """
set -euo pipefail

web_digest_file="$(location :web_image_base_amd64.digest)"
core_digest_file="$(location //docker/images:core_image_amd64.digest)"
version_file="$(location //:VERSION)"
info_file="bazel-out/stable-status.txt"

web_digest=$$(cat "$$web_digest_file")
if [[ "$$web_digest" != sha256:* ]]; then
  echo "unexpected web base digest format: $$web_digest" >&2
  exit 1
fi

web_short=$${web_digest#sha256:}
web_short=$$(printf '%s' "$$web_short" | cut -c1-12)

core_digest=$$(cat "$$core_digest_file")
if [[ "$$core_digest" != sha256:* ]]; then
  echo "unexpected core digest format: $$core_digest" >&2
  exit 1
fi

core_short=$${core_digest#sha256:}
core_short=$$(printf '%s' "$$core_short" | cut -c1-12)

commit_sha="dev"
if [[ -f "$$info_file" ]]; then
  commit_sha=$$(grep -m1 '^STABLE_COMMIT_SHA ' "$$info_file" | awk '{print $$2}')
  if [[ -z "$$commit_sha" ]]; then
    commit_sha="dev"
  fi
fi
commit_short=$$(printf '%s' "$$commit_sha" | cut -c1-12)

if [[ -f "$$version_file" ]]; then
  version=$$(tr -d '\\n' < "$$version_file")
else
  version="dev"
fi

build_time="$${BUILD_TIMESTAMP:-$$(date -u +"%Y-%m-%dT%H:%M:%SZ")}"

cat > "$@" <<EOF
{
  "version": "$$version",
  "buildTime": "$$build_time",
  "webBuildId": "sha-$$commit_short",
  "webImageDigest": "$$web_digest",
  "coreBuildId": "sha-$$core_short"
}
EOF
""",
)

pkg_tar(
    name = "web_build_info_root_layer_amd64",
    files = {
        ":web_build_info_json": "app/public/build-info.json",
    },
    modes = {
        "app/public/build-info.json": "0644",
    },
    package_dir = "/",
)

pkg_tar(
    name = "web_build_info_root_nested_layer_amd64",
    files = {
        ":web_build_info_json": "app/public/web/public_flat/build-info.json",
    },
    modes = {
        "app/public/web/public_flat/build-info.json": "0644",
    },
    package_dir = "/",
)

pkg_tar(
    name = "web_build_info_standalone_layer_amd64",
    files = {
        ":web_build_info_json": "app/.next/standalone/public/build-info.json",
    },
    modes = {
        "app/.next/standalone/public/build-info.json": "0644",
    },
    package_dir = "/",
)

pkg_tar(
    name = "web_build_info_standalone_nested_layer_amd64",
    files = {
        ":web_build_info_json": "app/.next/standalone/public/web/public_flat/build-info.json",
    },
    modes = {
        "app/.next/standalone/public/web/public_flat/build-info.json": "0644",
    },
    package_dir = "/",
)

oci_image(
    name = "web_image_amd64",
    base = ":web_image_base_amd64",
    tars = [
        ":web_build_info_root_layer_amd64",
        ":web_build_info_root_nested_layer_amd64",
        ":web_build_info_standalone_layer_amd64",
        ":web_build_info_standalone_nested_layer_amd64",
    ],
)

oci_load(
    name = "web_image_amd64_tar",
    image = ":web_image_amd64",
    repo_tags = ["ghcr.io/carverauto/serviceradar-web:local"],
)

pkg_tar(
    name = "srql_layer_amd64",
    files = {
        "//rust/srql:srql_bin": "usr/local/bin/serviceradar-srql",
        "//docker/compose:entrypoint-srql.sh": "usr/local/bin/entrypoint.sh",
    },
    modes = {
        "usr/local/bin/serviceradar-srql": "0755",
        "usr/local/bin/entrypoint.sh": "0755",
    },
    empty_dirs = [
        "etc/serviceradar/certs",
    ],
    package_dir = "/",
)

oci_image(
    name = "srql_image_amd64",
    base = "@ubuntu_noble//:ubuntu_noble",
    tars = [":srql_layer_amd64"],
    entrypoint = ["/usr/local/bin/entrypoint.sh"],
    cmd = ["serviceradar-srql"],
    env = {
        "PATH": "/usr/local/bin:/usr/bin:/bin",
    },
    exposed_ports = ["8080/tcp"],
    workdir = "/app",
    labels = {
        "org.opencontainers.image.title": "serviceradar-srql",
    },
)

oci_load(
    name = "srql_image_amd64_tar",
    image = ":srql_image_amd64",
    repo_tags = ["ghcr.io/carverauto/serviceradar-srql:local"],
)

pkg_tar(
    name = "kong_config_layer_amd64",
    files = {
        "//cmd/cli:cli": "usr/local/bin/serviceradar-cli",
    },
    modes = {
        "usr/local/bin/serviceradar-cli": "0755",
    },
    package_dir = "/",
)

oci_image(
    name = "kong_config_image_amd64",
    base = "@alpine_3_20_linux_amd64//:alpine_3_20_linux_amd64",
    tars = [":common_tools_amd64", ":kong_config_layer_amd64"],
    entrypoint = ["/usr/local/bin/serviceradar-cli"],
    cmd = ["render-kong"],
    env = {
        "PATH": "/usr/local/bin:/usr/bin:/bin",
    },
    labels = {
        "org.opencontainers.image.title": "serviceradar-kong-config",
    },
)

oci_load(
    name = "kong_config_image_amd64_tar",
    image = ":kong_config_image_amd64",
    repo_tags = ["ghcr.io/carverauto/serviceradar-kong-config:local"],
)

pkg_tar(
    name = "cert_generator_layer_amd64",
    files = {
        "//docker/compose:entrypoint-certs.sh": "entrypoint-certs.sh",
    },
    modes = {
        "entrypoint-certs.sh": "0755",
    },
    empty_dirs = ["certs"],
    package_dir = "/",
)

oci_image(
    name = "cert_generator_image_amd64",
    base = "@serviceradar_cert_generator_linux_amd64//:serviceradar_cert_generator_linux_amd64",
    tars = [":cert_generator_layer_amd64"],
    entrypoint = ["/bin/sh", "/entrypoint-certs.sh"],
    labels = {
        "org.opencontainers.image.title": "serviceradar-cert-generator",
    },
)

oci_load(
    name = "cert_generator_image_amd64_tar",
    image = ":cert_generator_image_amd64",
    repo_tags = ["ghcr.io/carverauto/serviceradar-cert-generator:local"],
)

pkg_tar(
    name = "tools_layer_amd64",
    files = {
        "//cmd/cli:cli": "usr/local/bin/serviceradar-cli",
        "//cmd/tools/cnpg-migrate:cnpg-migrate": "usr/local/bin/cnpg-migrate",
        "//docker/compose:tools-entrypoint.sh": "usr/local/bin/entrypoint.sh",
        "//docker/compose:tools-profile.sh": "etc/profile.d/serviceradar-tools.sh",
        "//docker/compose:tools-motd.txt": "etc/motd",
        "@natscli_linux_amd64//:nats": "usr/local/bin/nats",
        "@spire_linux_amd64//:bin/spire-agent": "usr/local/bin/spire-agent",
        "@spire_linux_amd64//:bin/spire-server": "usr/local/bin/spire-server",
    },
    modes = {
        "usr/local/bin/serviceradar-cli": "0755",
        "usr/local/bin/cnpg-migrate": "0755",
        "usr/local/bin/entrypoint.sh": "0755",
        "etc/profile.d/serviceradar-tools.sh": "0644",
        "etc/motd": "0644",
        "usr/local/bin/nats": "0755",
        "usr/local/bin/spire-agent": "0755",
        "usr/local/bin/spire-server": "0755",
    },
    empty_dirs = [
        "etc/serviceradar/certs",
        "etc/serviceradar/nats",
        "root/.config/nats/context",
    ],
    package_dir = "/",
)

pkg_tar(
    name = "postgresql16_client_symlinks",
    package_dir = "/",
    symlinks = {
        "usr/bin/clusterdb": "/usr/libexec/postgresql16/clusterdb",
        "usr/bin/createdb": "/usr/libexec/postgresql16/createdb",
        "usr/bin/createuser": "/usr/libexec/postgresql16/createuser",
        "usr/bin/dropdb": "/usr/libexec/postgresql16/dropdb",
        "usr/bin/dropuser": "/usr/libexec/postgresql16/dropuser",
        "usr/bin/pg_amcheck": "/usr/libexec/postgresql16/pg_amcheck",
        "usr/bin/pg_basebackup": "/usr/libexec/postgresql16/pg_basebackup",
        "usr/bin/pg_dump": "/usr/libexec/postgresql16/pg_dump",
        "usr/bin/pg_dumpall": "/usr/libexec/postgresql16/pg_dumpall",
        "usr/bin/pg_isready": "/usr/libexec/postgresql16/pg_isready",
        "usr/bin/pg_recvlogical": "/usr/libexec/postgresql16/pg_recvlogical",
        "usr/bin/pg_receivewal": "/usr/libexec/postgresql16/pg_receivewal",
        "usr/bin/pg_restore": "/usr/libexec/postgresql16/pg_restore",
        "usr/bin/pg_verifybackup": "/usr/libexec/postgresql16/pg_verifybackup",
        "usr/bin/pgbench": "/usr/libexec/postgresql16/pgbench",
        "usr/bin/psql": "/usr/libexec/postgresql16/psql",
        "usr/bin/reindexdb": "/usr/libexec/postgresql16/reindexdb",
        "usr/bin/vacuumdb": "/usr/libexec/postgresql16/vacuumdb",
    },
)

oci_image(
    name = "tools_image_amd64",
    base = "@alpine_3_20_linux_amd64//:alpine_3_20_linux_amd64",
    tars = [
        ":alpine_netutils_rootfs_amd64",
        ":apk_bash_rootfs_amd64",
        ":apk_readline_rootfs_amd64",
        ":apk_postgresql16_client_rootfs_amd64",
        ":apk_libpq16_rootfs_amd64",
        ":postgresql16_client_symlinks",
        ":apk_libncursesw_rootfs_amd64",
        ":apk_ncurses_terminfo_base_rootfs_amd64",
        ":apk_glibc_rootfs_amd64",
        ":tools_layer_amd64",
        ":common_tools_amd64",
    ],
    entrypoint = ["/usr/local/bin/entrypoint.sh"],
    cmd = ["/bin/sh"],
    env = {
        "PATH": "/usr/libexec/postgresql16:/usr/local/bin:/usr/bin:/bin",
    },
    labels = {
        "org.opencontainers.image.title": "serviceradar-tools",
    },
)

oci_load(
    name = "tools_image_amd64_tar",
    image = ":tools_image_amd64",
    repo_tags = ["ghcr.io/carverauto/serviceradar-tools:local"],
)

genrule(
    name = "cnpg_postgresql_16_6_rootfs_tar",
    srcs = ["@cloudnativepg_postgresql_16_6_linux_amd64//:cloudnativepg_postgresql_16_6_linux_amd64"],
    tools = [
        "//docker/images:export_rootfs_from_layout.py",
        "//docker/images:extract_rootfs.py",
        "//third_party/binaries:crane_linux_amd64",
    ],
    outs = ["cnpg_postgresql_16_6_rootfs.tar"],
    cmd = """
set -euo pipefail
LAYOUT="$(location @cloudnativepg_postgresql_16_6_linux_amd64//:cloudnativepg_postgresql_16_6_linux_amd64)"
if [[ "$${LAYOUT}" != /* ]]; then
  LAYOUT="$$(pwd)/$${LAYOUT}"
fi
if ! "$(location //third_party/binaries:crane_linux_amd64)" export "layout:$${LAYOUT}" "$@"; then
  python3 "$(location //docker/images:export_rootfs_from_layout.py)" --layout "$${LAYOUT}" --output "$@"
fi
""",
    visibility = ["//visibility:public"],
)

genrule(
    name = "timescaledb_extension_layer",
    srcs = [
        ":cnpg_postgresql_16_6_rootfs_tar",
        "@postgresql_server_dev_16_deb//file",
        "@debian_bison_amd64_deb//file",
        "@debian_flex_amd64_deb//file",
        "@debian_libpq_dev_amd64_deb//file",
        "//timescaledb:source_tree",
        "//docker/images:pg_config_wrapper.sh",
    ],
    outs = ["timescaledb_extension_layer.tar"],
    local = True,
    tools = [
        "//docker/images:extract_rootfs.py",
        "//docker/images:overlay_deb_packages.py",
        "//docker/images:pg_config_rewrite.py",
        "@cmake_linux_amd64_prebuilt//:cmake_bin",
    ],
    cmd = """
set -euo pipefail
OUT_DIR="$$(pwd)/$(@D)"
OUT_TAR="$$(pwd)/$@"
ROOT_DIR="$${OUT_DIR}/rootfs_timescaledb"
python3 "$(location //docker/images:extract_rootfs.py)" "$(location :cnpg_postgresql_16_6_rootfs_tar)" "$${ROOT_DIR}"
python3 "$(location //docker/images:overlay_deb_packages.py)" "$${ROOT_DIR}" \
  "$(location @postgresql_server_dev_16_deb//file)" \
  "$(location @debian_bison_amd64_deb//file)" \
  "$(location @debian_flex_amd64_deb//file)" \
  "$(location @debian_libpq_dev_amd64_deb//file)"
sed -i 's|^CLANG = .*|CLANG = clang|' "$${ROOT_DIR}/usr/lib/postgresql/16/lib/pgxs/src/Makefile.global"
sed -i 's|^with_llvm\t= .*|with_llvm\t= no|' "$${ROOT_DIR}/usr/lib/postgresql/16/lib/pgxs/src/Makefile.global"

SRC_TREE="$$(pwd)/$(execpath //timescaledb:source_tree)"
echo "Copying TimescaleDB sources from $${SRC_TREE}"
if [[ -d "$${OUT_DIR}/timescaledb" ]]; then
  chmod -R u+w "$${OUT_DIR}/timescaledb"
  rm -rf "$${OUT_DIR}/timescaledb"
fi
mkdir -p "$${OUT_DIR}/timescaledb"
cp -R "$${SRC_TREE}/." "$${OUT_DIR}/timescaledb"
chmod -R u+w "$${OUT_DIR}/timescaledb"

cp "$(location //docker/images:pg_config_wrapper.sh)" "$${OUT_DIR}/pg_config_wrapper_ts.sh"
chmod +x "$${OUT_DIR}/pg_config_wrapper_ts.sh"
cp "$(location //docker/images:pg_config_rewrite.py)" "$${OUT_DIR}/pg_config_rewrite.py"

CMAKE_BIN="$(location @cmake_linux_amd64_prebuilt//:cmake_bin)"
chmod +x "$${CMAKE_BIN}"
CMAKE_DIR="$$(dirname "$${CMAKE_BIN}")"
export CMAKE="$${CMAKE_BIN}"
export CNPG_ROOT="$${ROOT_DIR}"
export CNPG_REAL_PG_CONFIG="$${ROOT_DIR}/usr/lib/postgresql/16/bin/pg_config"
export PATH="$${CMAKE_DIR}:$${ROOT_DIR}/usr/lib/postgresql/16/bin:$${ROOT_DIR}/usr/bin:/usr/bin:/bin"
export PKG_CONFIG_PATH="$${ROOT_DIR}/usr/lib/pkgconfig:$${ROOT_DIR}/usr/lib/x86_64-linux-gnu/pkgconfig"
cd "$${OUT_DIR}/timescaledb"
BUILD_FORCE_REMOVE=true ./bootstrap -DREGRESS_CHECKS=OFF -DPROJECT_INSTALL_METHOD=docker -DCMAKE_BUILD_TYPE=RelWithDebInfo -DPG_CONFIG="$${OUT_DIR}/pg_config_wrapper_ts.sh"
cd build
make -j4
mkdir -p "$${OUT_DIR}/install"
make DESTDIR="$${OUT_DIR}/install_ts" install
INSTALL_PREFIX="$${OUT_DIR}/install_ts$${CNPG_ROOT}"
if [[ ! -d "$${INSTALL_PREFIX}" ]]; then
  echo "Timescale install prefix $${INSTALL_PREFIX} not found" >&2
  exit 1
fi
tar -C "$${INSTALL_PREFIX}" -cf "$${OUT_TAR}" .
""",
)

genrule(
    name = "age_extension_layer",
    srcs = [
        ":cnpg_postgresql_16_6_rootfs_tar",
        "@postgresql_server_dev_16_deb//file",
        "@debian_bison_amd64_deb//file",
        "@debian_flex_amd64_deb//file",
        "@debian_libpq_dev_amd64_deb//file",
        "//age:source_tree",
        "//docker/images:pg_config_wrapper.sh",
    ],
    outs = ["age_extension_layer.tar"],
    local = True,
    tools = [
        "//docker/images:extract_rootfs.py",
        "//docker/images:overlay_deb_packages.py",
        "//docker/images:pg_config_rewrite.py",
    ],
    cmd = """
set -euo pipefail
OUT_DIR="$$(pwd)/$(@D)"
OUT_TAR="$$(pwd)/$@"
ROOT_DIR="$${OUT_DIR}/rootfs_age"
python3 "$(location //docker/images:extract_rootfs.py)" "$(location :cnpg_postgresql_16_6_rootfs_tar)" "$${ROOT_DIR}"
python3 "$(location //docker/images:overlay_deb_packages.py)" "$${ROOT_DIR}" \
  "$(location @postgresql_server_dev_16_deb//file)" \
  "$(location @debian_bison_amd64_deb//file)" \
  "$(location @debian_flex_amd64_deb//file)" \
  "$(location @debian_libpq_dev_amd64_deb//file)"
sed -i 's|^CLANG = .*|CLANG = clang|' "$${ROOT_DIR}/usr/lib/postgresql/16/lib/pgxs/src/Makefile.global"
sed -i 's|^with_llvm\t= .*|with_llvm\t= no|' "$${ROOT_DIR}/usr/lib/postgresql/16/lib/pgxs/src/Makefile.global"

AGE_TREE="$$(pwd)/$(execpath //age:source_tree)"
if [[ -d "$${OUT_DIR}/age" ]]; then
  chmod -R u+w "$${OUT_DIR}/age"
  rm -rf "$${OUT_DIR}/age"
fi
mkdir -p "$${OUT_DIR}/age"
cp -R "$${AGE_TREE}/." "$${OUT_DIR}/age"
chmod -R u+w "$${OUT_DIR}/age"

cp "$(location //docker/images:pg_config_wrapper.sh)" "$${OUT_DIR}/pg_config_wrapper_age.sh"
chmod +x "$${OUT_DIR}/pg_config_wrapper_age.sh"
cp "$(location //docker/images:pg_config_rewrite.py)" "$${OUT_DIR}/pg_config_rewrite.py"

export CNPG_ROOT="$${ROOT_DIR}"
export CNPG_REAL_PG_CONFIG="$${ROOT_DIR}/usr/lib/postgresql/16/bin/pg_config"
export PATH="$${ROOT_DIR}/usr/lib/postgresql/16/bin:$${ROOT_DIR}/usr/bin:/usr/bin:/bin"
export PKG_CONFIG_PATH="$${ROOT_DIR}/usr/lib/pkgconfig:$${ROOT_DIR}/usr/lib/x86_64-linux-gnu/pkgconfig"
export YACC="bison -y"
export FLEX="$${ROOT_DIR}/usr/bin/flex"
export LEX="$${ROOT_DIR}/usr/bin/flex"
cd "$${OUT_DIR}/age"
make PG_CONFIG="$${OUT_DIR}/pg_config_wrapper_age.sh" -j4
mkdir -p "$${OUT_DIR}/install_age"
make PG_CONFIG="$${OUT_DIR}/pg_config_wrapper_age.sh" DESTDIR="$${OUT_DIR}/install_age" install
INSTALL_PREFIX="$${OUT_DIR}/install_age$${CNPG_ROOT}"
if [[ ! -d "$${INSTALL_PREFIX}" ]]; then
  echo "AGE install prefix $${INSTALL_PREFIX} not found" >&2
  exit 1
fi
tar -C "$${INSTALL_PREFIX}" -cf "$${OUT_TAR}" .
""",
)

oci_image(
    name = "cnpg_image_amd64",
    base = "@cloudnativepg_postgresql_16_6_linux_amd64//:cloudnativepg_postgresql_16_6_linux_amd64",
    tars = [
        ":timescaledb_extension_layer",
        ":age_extension_layer",
    ],
    labels = {
        "org.opencontainers.image.title": "serviceradar-cnpg",
    },
)

oci_load(
    name = "cnpg_image_amd64_tar",
    image = ":cnpg_image_amd64",
    repo_tags = ["ghcr.io/carverauto/serviceradar-cnpg:local"],
)

# --- GHCR publishing ---------------------------------------------------------
declare_ghcr_push_targets()
