# NOTE: User and query level settings are set up in "users.yaml" file.
# If you have accidentally specified user-level settings here, server won't start.
# You can either move the settings to the right place inside "users.xml" file
# or add skip_check_for_incorrect_settings: 1 here.
logger:
    # Possible levels [1]:
    # - none (turns off logging)
    # - fatal
    # - critical
    # - error
    # - warning
    # - notice
    # - information
    # - debug
    # - trace
    # [1]: https://github.com/pocoproject/poco/blob/poco-1.9.4-release/Foundation/include/Poco/Logger.h#L105-L114
    level: error
    log: /var/log/proton-server/proton-server.log
    errorlog: /var/log/proton-server/proton-server.err.log
    # Rotation policy
    # See https://github.com/pocoproject/poco/blob/poco-1.9.4-release/Foundation/include/Poco/FileChannel.h#L54-L85
    size: 1000M
    count: 10
    console: 1
    # Default behavior is autodetection (log to console if not daemon mode and is tty)

# It is the name that will be shown in the proton-client.
# By default, anything with "production" will be highlighted in red in query prompt.
display_name: proton

# Explicit legacy port settings (Proton 3.x still reads these even with node.*)
http_port: 8123
tcp_port: 8463
https_port: 8443
tcp_port_secure: 9440

node:

    # Roles that the current node has
    # Supported roles : Metadata, Data, Compute
    # `Data` role contains `Compute` roles by default.
    # `Compute` node can't have streams storing data on them. Can serve ingest or query
    roles:
        role:
            - Metadata
            - Data

    # Public protocols and ports
    http:
        port: 8443 # Replaces legacy https_port
        is_tls_port: true

    # Public native protocol port for proton-client
    tcp:
        port: 9440 # Replaces legacy tcp_port_secure
        is_tls_port: true

    # Query on this port is historical table query by default
    table_tcp:
        port: 7587 # Merged from old snapshot_server_tcp_port
        is_tls_port: false

    table_http:
        port: 8123 # Merged from old snapshot_server_http_port
        is_tls_port: false

    # Compatibility with PostgreSQL protocol.
    # proton will pretend to be PostgreSQL for applications connecting to this port.
    postgresql:
        port: 5432
        is_tls_port: false

# Path to historical data directory, with trailing slash.
path: /var/lib/proton/

# Path to temporary data for processing hard queries.
tmp_path: /var/lib/proton/tmp/

# Policy from the <storage_configuration> for the temporary files.
# If not set <tmp_path> is used, otherwise <tmp_path> is ignored.

# Base directory for custom local disks
custom_local_disks_base_directory: /var/lib/proton/disks/

# Directory with user provided files that are accessible by 'file' table function.
user_files_path: /var/lib/proton/user_files/

query_state_spill_path: /var/lib/proton/query_states_spilled

# Directory in <proton-path> containing schema files for various input formats.
# The directory will be created if it doesn't exist.
format_schema_path: /var/lib/proton/format_schemas/

# Directory to look for protobuf files for the well-known types:
# https://protobuf.dev/reference/protobuf/google.protobuf/
google_protos_path: /usr/share/proton/protos/

# User defined grok patterns file
grok_patterns_file: /etc/proton-server/grok-patterns

# Path to file with region hierarchy.
# path_to_regions_hierarchy_file: /opt/geo/regions_hierarchy.txt

# Path to directory with files containing names of regions
# path_to_regions_names_files: /opt/geo/

query_state_checkpoint:
    # Path to local state checkpoint
    path: /var/lib/proton/checkpoint/
    # State checkpoint interval in seconds (0 means auto interval)
    interval: 0
    # Default intervals in different scenarios (Only used when interval is 0)
    # Minimum interval in seconds, except the specific light/heavy state interval
    min_interval: 60
    # For lightweight state scenarios such as ETL, we can set a small interval
    light_state_interval: 5
    # If any processor state larger than this size, mark it as heavy state
    # To avoid checkpointing heavy state at the same time
    heavy_state_size_threshold: 524288000 # 500 MB
    heavy_state_interval: 900 # 15 minutes, Merged from old checkpoint interval

    # Checkpoint expired if not accessed after `ttl` seconds
    last_access_ttl: 604800 # 7 days
    # Periodical last access check interval
    last_access_check_interval: 7200
    # When unsubscribe a query, wait grace interval to delete its checkpoints
    delete_grace_interval: 60
    # When server teardown, last checkpoint flush timeout in seconds
    teardown_flush_timeout: 60

    # Checkpoint Log related configs
    log_segment_size: 1073741824 # 1GB
    log_max_entry_size: 10485760 # 10 MB
    log_max_cached_entries: 0 # Disable cache now for checkpoint log
    log_flush_interval_entries: 1
    log_flush_bytes: 1
    log_retention_size: 1
    log_retention_ms: 7200000 # 2 hours
    log_min_size_to_keep: 1

metadata:
    # SINGLE-INSTANCE: metadata.server NOT USED - internal server config for distributed mode
    # server:
    #     listen_host: 0.0.0.0
    #     tcp_port: 8464
    #     # ... other server settings not used in single-instance mode


    # Meta store configurations for internal use only
    # Both metadata server and metadata client will interact with meta store
    metastore:
        # Max 127 versions to keep
        metadata_keep_versions: 10
        metadata_max_retries: 10
        data_dirs:
            - /var/lib/proton/metastore/
        log:
            check_crcs: false
            retention_check_ms: 30000
            # Fetch related configs
            fetch_max_wait_ms: 500 # max wait time if no records are available
            fetch_max_bytes: 65536 # max bytes to fetch per request
            # Log related configs
            max_entry_size: 1048576
            segment_size: 10485760 # 10MB
            retention_size: 1
            retention_ms: 86400000
            # Minimize log to keep around which is immune to retention policy
            min_size_to_keep: 1
            # For metadata log, we don't actually care the timestamp, sn inverted indexes.
            # So set a big interval bytes and entries
            index_interval_bytes: 4294967296
            index_interval_entries: 100000000
            # We like to flush per message for metadata log
            flush_interval_ms: 120000
            flush_interval_entries: 1
            flush_bytes: 1
            compression_codec: none
            cache_max_cached_entries_per_shard: 100
            cache_max_cached_bytes_per_shard: 4194304
            preallocate: true
            # When flushing data to file system, use range flush (sync_file_range) or not
            # The reliability of Range flush highly depends on file system implementation
            # Usually incremental flush has far better perf
            incremental_flush: true
            # Raft hard state checkpoint log size, checkpoint log will get rolled
            # and GCed every \hard_state_ckpt_log_size
            hard_state_ckpt_log_size: 1048576 # 1MB
            hard_state_ckpt_log_preallocate: true
            # Raft leader epoch sequence checkpoint log segment size, checkpoint
            # segment will be rolled per every \leader_epoch_index_log_size and
            # GCed automatically
            leader_epoch_index_log_size: 8388608 # 8MB
            leader_epoch_index_log_preallocate: true
            timestamp_index_log_size: 8388608 # 8MB
            timestamp_index_log_preallocate: true
            log_position_index_log_size: 8388608 # 8MB
            log_position_index_log_preallocate: true

# Local metadata queue configuration
local_meta_queue:
    # Maximum number of entries the queue can hold
    max_queue_entries: 10000
    # Maximum bytes the queue can hold (100MB)
    max_queue_bytes: 104857600

# Periodic cleanup timer configuration
cleanup_timer:
    # Number of threads for the timer pool
    thread_pool_size: 1
    # Timer tick interval in milliseconds
    tick_interval_ms: 60000
    # Cleanup task interval in milliseconds
    cleanup_interval_ms: 60000

data:
    # SINGLE-INSTANCE: data.server NOT USED - internal server config for distributed mode
    # server:
    #     listen_host: 0.0.0.0
    #     tcp_port: 8465
    #     # ... other server settings not used in single-instance mode

    datastore:
        data_dirs:
            - /var/lib/proton/nativelog/
        log:
            check_crcs: false
            retention_check_ms: 300000 # Every 5 minutes
            # Fetch related configs
            fetch_max_wait_ms: 500 # max wait time if no records are available
            fetch_max_bytes: 65536 # max bytes to fetch per request
            # Log related configs
            max_entry_size: 10485760
            segment_size: 268435456 # Merged from old nativelog setting (256 MiB)
            retention_size: 53687091200 # Merged from old nativelog setting (~50GiB)
            retention_ms: 259200000 # Merged from old nativelog setting (3 days)
            # Minimize log to keep around which is immune to retention policy
            min_size_to_keep: 2147483648
            index_interval_bytes: 4096 # Merged from old nativelog setting
            index_interval_entries: 1000
            flush_interval_ms: 600000 # Merged from old nativelog setting
            flush_interval_entries: 10000 # Merged from old nativelog setting
            flush_bytes: 1
            compression_codec: none
            cache_max_cached_entries_per_shard: 100
            cache_max_cached_bytes_per_shard: 4194304
            preallocate: true
            # When flushing data to file system, use range flush (sync_file_range) or not
            # The reliability of Range flush highly depends on file system implementation.
            # Usually incremental flush has far better perf
            incremental_flush: true
            # Raft hard state checkpoint log size, checkpoint log will get rolled
            # and GCed every \hard_state_ckpt_log_size
            hard_state_ckpt_log_size: 1048576 # 1MB
            hard_state_ckpt_log_preallocate: true
            # Raft leader epoch sequence checkpoint log segment size, checkpoint
            # segment will be rolled per every \leader_epoch_index_log_size and
            # GCed automatically
            leader_epoch_index_log_size: 8388608 # 8MB
            leader_epoch_index_log_preallocate: true
            timestamp_index_log_size: 8388608 # 8MB
            timestamp_index_log_preallocate: true
            log_position_index_log_size: 8388608 # 8MB
            log_position_index_log_preallocate: true

# SINGLE-INSTANCE: cluster section simplified for single-instance
cluster:
    # Single-instance doesn't use cluster configuration
    # metadata_node_quorum: localhost:8464

    # NOTE: ServerDescriptor.cpp looks for these at ROOT level, not under 'cluster'
    # Should be: cluster_id and intercluster_secret
    id: proton
    secret: proton

# ServerDescriptor expects these at root level (not under cluster section)
cluster_id: proton
intercluster_secret: proton

# Enable telemetry. This is used to collect the version and runtime environment information to Timeplus, Inc.
telemetry_enabled:
    "@from_env": TELEMETRY_ENABLED
    "@replace": true
    "#text": true

grpc:
    enabled: false # Merged from old grpc config (was not enabled)
    port: 9100
    is_tls_port: false

    # The following two files are used only if is_tls_port =1
    ssl_cert_file: /path/to/ssl_cert_file
    ssl_key_file: /path/to/ssl_key_file

    # Whether server will request client for a certificate
    ssl_require_client_auth: false

    # The following file is used only if ssl_require_client_auth=1
    ssl_ca_cert_file: /path/to/ssl_ca_cert_file

    # Default transport compression type (can be overridden by client, see the transport_compression_type field in QueryInfo).
    # Supported algorithms: none, deflate, gzip, stream_gzip
    transport_compression_type: deflate # Merged from old grpc config

    # Default transport compression level. Supported levels: 0..3
    transport_compression_level: 2 # Merged from old grpc config (medium -> 2)

    # Send/receive message size limits in bytes. -1 means unlimited
    max_send_message_size: -1
    max_receive_message_size: -1

    # Enable if you want very detailed logs
    verbose_logs: false

# Used with https_port and tcp_port_secure. Full ssl options list: https://github.com/proton-Extras/poco/blob/master/NetSSL_OpenSSL/include/Poco/Net/SSLManager.h#L71
openSSL:
    server:
        # Used for https server AND secure tcp port
        # openssl req -subj "/CN=localhost" -new -newkey rsa:2048 -days 365 -nodes -x509 -keyout /etc/proton-server/server.key -out /etc/proton-server/server.crt
        certificateFile: /etc/proton-server/certs/proton.pem
        privateKeyFile: /etc/proton-server/certs/proton-key.pem
        caConfig: /etc/proton-server/certs/root.pem

        # dhparams are optional. You can delete the dhParamsFile: element.
        # To generate dhparams, use the following command:
        # openssl dhparam -out /etc/proton-server/dhparam.pem 4096
        # Only file format with BEGIN DH PARAMETERS is supported.
        dhParamsFile: /etc/proton-server/dhparam.pem
        verificationMode: none
        loadDefaultCAFile: true
        cacheSessions: true
        disableProtocols: 'sslv2,sslv3'
        preferServerCiphers: true
    client:
        # Used for connecting to https dictionary source
        loadDefaultCAFile: true
        cacheSessions: true
        disableProtocols: 'sslv2,sslv3'
        preferServerCiphers: true

        # Use for self-signed: verificationMode: none
        invalidCertificateHandler:
            # Use for self-signed: name: AcceptCertificateHandler
            name: AcceptCertificateHandler # Merged from old config

# LDAP server definitions.
ldap_servers: ''

# Sources to read users, roles, access rights, profiles of settings, quotas.
user_directories:
    users_xml:
        # Path to configuration file with predefined users.
        path: users.yaml
    local_directory:
        # Path to folder where users created by SQL commands are stored.
        path: /var/lib/proton/access/

access_control_improvements:
  users_without_row_policies_can_read_rows: false

# Serve endpoint for Prometheus monitoring.
prometheus:
    endpoint: /metrics
    port: 9363
    metrics: true
    events: true
    asynchronous_metrics: true
    status_info: true
    external_stream: true
    materialized_view: true
    query_info: true
    cluster: true

# All system logs (query_log, trace_log, etc.) are identical between configs and remain unchanged.

# ... (query_log, trace_log, and other system logs remain the same as the 3.0 template) ...
query_log:
    database: system
    table: query_log
    partition_by: to_YYYYMM(event_date)
    ttl: 'event_date + INTERVAL 30 DAY DELETE'
    flush_interval_milliseconds: 7500

trace_log:
    database: system
    table: trace_log
    partition_by: to_YYYYMM(event_date)
    flush_interval_milliseconds: 7500
    ttl: 'event_date + INTERVAL 7 DAY DELETE'

query_thread_log:
    database: system
    table: query_thread_log
    partition_by: to_YYYYMM(event_date)
    ttl: 'event_date + INTERVAL 30 DAY DELETE'
    flush_interval_milliseconds: 7500

query_views_log:
    database: system
    table: query_views_log
    partition_by: to_YYYYMM(event_date)
    flush_interval_milliseconds: 7500
    ttl: 'event_date + INTERVAL 30 DAY DELETE'

part_log:
    database: system
    table: part_log
    partition_by: to_YYYYMM(event_date)
    flush_interval_milliseconds: 7500
    ttl: 'event_date + INTERVAL 30 DAY DELETE'

metric_log:
    database: system
    table: metric_log
    flush_interval_milliseconds: 7500
    collect_interval_milliseconds: 1000
    ttl: 'event_date + INTERVAL 30 DAY DELETE'

asynchronous_metric_log:
    database: system
    table: asynchronous_metric_log
    flush_interval_milliseconds: 60000
    ttl: 'event_date + INTERVAL 7 DAY DELETE'

opentelemetry_span_log:
    engine: |-
        engine MergeTree
             partition by to_YYYYMM(finish_date)
             order by (finish_date, finish_time_us, trace_id)
             ttl finish_date + INTERVAL 7 DAY DELETE
    database: system
    table: opentelemetry_span_log
    flush_interval_milliseconds: 7500

crash_log:
    database: system
    table: crash_log
    partition_by: ''
    flush_interval_milliseconds: 1000

processors_profile_log:
    database: system
    table: processors_profile_log
    partition_by: to_YYYYMM(event_date)
    flush_interval_milliseconds: 7500

asynchronous_insert_log:
  database: system
  table: asynchronous_insert_log
  flush_interval_milliseconds: 7500
  partition_by: event_date
  ttl: event_date + INTERVAL 3 DAY

stream_metric_log:
    engine: |-
        engine Stream(1, rand())
             order by (to_hour(_tp_time), database, name)
             ttl to_datetime(_tp_time) + INTERVAL 1 YEAR DELETE
             settings logstore_codec='zstd'
    database: system
    table: stream_metric_log
    flush_interval_milliseconds: 5000
    collect_interval_milliseconds: 5000

stream_state_log:
    engine: |-
        engine Stream(1, weak_hash32(node_id))
             primary key (database, name, state_name, dimension, node_id)
             order by (database, name, state_name, dimension, node_id)
             ttl to_datetime(_tp_time) + INTERVAL 2 MONTH DELETE
             settings mode = 'versioned_kv', logstore_codec='zstd'
    database: system
    table: stream_state_log
    flush_interval_milliseconds: 5000
    collect_interval_milliseconds: 5000

mat_view_dlq:
    engine: |-
        engine Stream(1, weak_hash32(node_id))
             order by (to_hour(_tp_time), database, view_name)
             ttl to_datetime(_tp_time) + INTERVAL 2 MONTH DELETE
             settings logstore_codec='zstd'
    database: system
    table: mat_view_dlq
    flush_interval_milliseconds: 5000

builtin_schemas:
    alert_ckpt_log:
        enabled: true
        ddl: |-
            CREATE STREAM system.alert_ckpt_log
            (
                uuid uuid,
                shard uint64,
                sn int64
            )
            PRIMARY KEY (uuid, shard)
            TTL to_datetime(_tp_time) + INTERVAL 3 MONTH DELETE
            SETTINGS mode='versioned_kv'

# Configuration of external dictionaries.
dictionaries_config: '*_dictionary.xml'

# Example of parameters for GraphiteMergeTree table engine
graphite_rollup_example:
    pattern:
        regexp: click_cost
        function: any
        retention:
            - age: 0
              precision: 3600
            - age: 86400
              precision: 60
    default:
        function: max
        retention:
            - age: 0
              precision: 60
            - age: 3600
              precision: 300
            - age: 86400
              precision: 3600

query_masking_rules:
    rule:
        name: hide encrypt/decrypt arguments
        regexp: '((?:aes_)?(?:encrypt|decrypt)(?:_mysql)?)\s*\(\s*(?:''(?:\\''|.)+''|.*?)\s*\)'
        replace: \1(???)

send_crash_reports:
    enabled: false
    anonymize: false
    endpoint:

task:
    worker_threads: 0
    max_scheduled_tasks: 1024

settings:
    global:
        query_mode: streaming
        query_resource_group: "dedicated"
        enable_light_ingest: true
        _tp_enable_log_stream_expr: true
        synchronous_ddl: true
        asterisk_include_reserved_columns: true
        asterisk_include_tp_sn_column: false
        async_ingest_block_timeout_ms: 12000
        aysnc_ingest_max_outstanding_blocks: 10000
        storage_commit_pool_size: 8 # Merged from old part_commit_pool_size
        max_idempotent_ids: 1000
        _tp_internal_system_open_sesame: true

        javascript_max_memory_bytes: 104857600 # Merged from old config (100MB)
        v8_log_interval_ms: 30000
        recovery_policy: "strict"
        recovery_retry_for_same_error: 1000000000000

        max_block_size: 2048 # Merged from old config
        max_insert_block_size: 2048 # Merged from old config
        nlog_adhoc_pool_size: 16
        optimize_aggregation_emit_on_updates: true

        max_hot_keys: 100000

        default_hash_table: memory

        default_hash_join: memory
        query_timeout_sec: 30

        allow_fallback_to_historical_store: true

    stream:
        default_shards: 1
        default_sharding_expr: ""
        ingest_mode: "async" # Merged from old distributed_ingest_mode
        logstore: "nativelog"
        storage_type: "hybrid"
        logstore_codec: none
        logstore_retention_bytes: 53687091200 # Merged from old config (~50GiB)
        logstore_retention_ms: 259200000 # Merged from old config (3 days)

# Global Settings
keep_alive_timeout: 3

telemetry_interval_ms: 300000

max_local_disk_usage_ratio: 0.995 # Merged from old config

total_memory_profiler_step: 4194304

total_memory_tracker_sample_probability: 0

mlock_executable: true

remap_executable: false

builtin_dictionaries_reload_interval: 3600

max_session_timeout: 3600

default_session_timeout: 60

max_connections: 4096

asynchronous_metrics_update_period_s: 2

neutron_database: neutron

default_database: default

default_profile: default

max_server_memory_usage: 0

max_server_memory_usage_to_ram_ratio: 0.9 # Merged from old config

cache_size_to_ram_max_ratio: 0.5

uncompressed_cache_size: 8589934592

mark_cache_size: 5368709120

mmap_cache_size: 1000

compiled_expression_cache_size: 134217728

max_concurrent_queries: 1000 # Increased from 100 in old config to new default
max_concurrent_insert_queries: 1000 # Increased from 100 in old config to new default
max_concurrent_select_queries: 1000 # Increased from 100 in old config to new default
