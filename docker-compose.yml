# ServiceRadar Docker Compose Configuration
#
# Usage:
#   Standard deployment (core stack only):
#     docker compose up -d
#
#   Include testing services (faker):
#     docker compose -f docker-compose.yml -f docker-compose.testing.yml --profile testing up -d
#
# Available profiles:
#   - testing: Adds the optional faker Armis emulator when the testing override is included

services:
  # Certificate Generation Service (runs once to generate mTLS certs)
  cert-generator:
    image: alpine:3.20
    container_name: serviceradar-cert-generator
    volumes:
      - cert-data:/certs
      - ./docker/compose/generate-certs.sh:/generate-certs.sh:ro
    command: sh -c "apk add --no-cache openssl bash && cp /generate-certs.sh /tmp/gen.sh && chmod +x /tmp/gen.sh && CERT_DIR=/certs bash /tmp/gen.sh"
    restart: "no"  # Only run once
    networks:
      - serviceradar-net

  # Configuration Updater (runs after cert generation to update configs with secrets)
  config-updater:
    image: ghcr.io/carverauto/serviceradar-config-updater:latest
    container_name: serviceradar-config-updater
    volumes:
      - cert-data:/etc/serviceradar/certs
      - generated-config:/etc/serviceradar/config
      - ./packaging/core/config:/config:ro
      - ./docker/compose:/templates:ro
    environment:
      - SYSMON_VM_ADDRESS=${SYSMON_VM_ADDRESS:-192.168.1.219:50110}
      - POLLERS_SECURITY_MODE=${POLLERS_SECURITY_MODE:-mtls}
      - POLLERS_TRUST_DOMAIN=${POLLERS_TRUST_DOMAIN:-carverauto.dev}
      - POLLERS_SPIRE_UPSTREAM_ADDRESS=${POLLERS_SPIRE_UPSTREAM_ADDRESS:-spire-server}
      - POLLERS_SPIRE_UPSTREAM_PORT=${POLLERS_SPIRE_UPSTREAM_PORT:-8081}
      - POLLERS_SPIRE_INSECURE_BOOTSTRAP=${POLLERS_SPIRE_INSECURE_BOOTSTRAP:-true}
      - POLLERS_SPIRE_PARENT_ID=${POLLERS_SPIRE_PARENT_ID:-spiffe://carverauto.dev/ns/edge/poller-nested-spire}
      - POLLERS_SPIRE_DOWNSTREAM_SPIFFE_ID=${POLLERS_SPIRE_DOWNSTREAM_SPIFFE_ID:-spiffe://carverauto.dev/services/poller}
    depends_on:
      cert-generator:
        condition: service_completed_successfully
    restart: "no"  # Only run once
    networks:
      - serviceradar-net

  # Generate RS256 JWT keys and update core.json (first-run init)
  core-jwks-init:
    image: ghcr.io/carverauto/serviceradar-kong-config:latest
    container_name: serviceradar-core-jwks-init
    user: "0:0"
    entrypoint: ["/usr/local/bin/serviceradar-cli", "generate-jwt-keys"]
    command: ["-file", "/etc/serviceradar/config/core.json", "-bits", "2048"]
    volumes:
      - generated-config:/etc/serviceradar/config
    depends_on:
      config-updater:
        condition: service_completed_successfully
    restart: "no"
    networks:
      - serviceradar-net

  # Fix certificate permissions for Docker deployment
  cert-permissions-fixer:
    image: alpine:3.20
    container_name: serviceradar-cert-permissions-fixer
    volumes:
      - cert-data:/etc/serviceradar/certs
      - ./docker/compose/fix-cert-permissions.sh:/fix-cert-permissions.sh:ro
    command: sh /fix-cert-permissions.sh
    depends_on:
      config-updater:
        condition: service_completed_successfully
    restart: "no"  # Only run once
    networks:
      - serviceradar-net

  # Proton (TimeBase) Database with custom configuration
  proton:
    image: ghcr.io/carverauto/serviceradar-proton:latest
    container_name: serviceradar-proton
    user: "0:0"
    mem_limit: 8g
    mem_reservation: 6g
    ports:
      - "8123:8123"  # HTTP port for JDBC driver, batch mode
      - "8463:8463"  # Native TCP port
      - "8443:8443"  # HTTPS port (with TLS)
      - "9440:9440"  # Native TCP secure port (with TLS)
    volumes:
      - proton-data:/var/lib/proton
      - cert-data:/etc/serviceradar/certs:ro
      - cert-data:/etc/proton-server/certs:ro
      - credentials:/etc/serviceradar/credentials
      - ./docker/compose/proton-init.sh:/usr/local/bin/proton-init.sh:ro
    environment:
      - PROTON_PASSWORD=${PROTON_PASSWORD:-}  # Will generate if not set
      - PROTON_LOG_LEVEL=${PROTON_LOG_LEVEL:-error}
      - PROTON_DISABLE_TASKSTATS=1
      # Align Proton memory usage with container limits to reduce OOM risk
      - PROTON_MAX_SERVER_MEMORY=6g
      - PROTON_MAX_QUERY_MEMORY=4g
      - PROTON_MAX_PARTITION_BYTES=256m
    ulimits:
      nofile:
        soft: 1048576
        hard: 1048576
      nproc:
        soft: 65535
        hard: 65535
    # sysctls disabled for Docker Desktop compatibility
    # In production Linux environments, you can enable these:
    # sysctls:
    #   - kernel.threads-max=100000  
    #   - kernel.pid_max=100000
    #   - vm.nr_hugepages=0
    cap_add:
      - NET_ADMIN
      - IPC_LOCK
      - SYS_NICE
    healthcheck:
      test: ["CMD-SHELL", "curl -sf http://localhost:8123/?query=SELECT%201 || curl -sf http://default:$$(cat /etc/proton-server/generated_password.txt)@localhost:8123/?query=SELECT%201 || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 30s
    depends_on:
      cert-generator:
        condition: service_completed_successfully
    networks:
      serviceradar-net:
        aliases:
          - proton.serviceradar
    restart: unless-stopped

  # Ensure Proton credentials are readable by application containers
  credentials-permissions-fixer:
    image: alpine:3.20
    container_name: serviceradar-credentials-permissions-fixer
    volumes:
      - credentials:/etc/serviceradar/credentials
      - ./docker/compose/fix-credentials-permissions.sh:/fix-credentials-permissions.sh:ro
    command: sh /fix-credentials-permissions.sh
    depends_on:
      proton:
        condition: service_healthy
    restart: "no"
    networks:
      - serviceradar-net

  # ServiceRadar Core Service
  core:
    image: ghcr.io/carverauto/serviceradar-core:latest
    container_name: serviceradar-core
    mem_limit: 8g
    mem_reservation: 4g
    # Expose core ports for debugging authentication
    ports:
      - "8090:8090"  # HTTP API
      - "50052:50052"  # gRPC (matching core.json)
      - "9090:9090"  # Metrics (Prometheus)
    volumes:
      # Use generated config files with secrets (generated by config-updater)
      - generated-config:/etc/serviceradar/config:ro
      - cert-data:/etc/serviceradar/certs:ro
      - credentials:/etc/serviceradar/credentials:ro
      - core-data:/var/lib/serviceradar
      - ./logs:/var/log/serviceradar
    environment:
      # Wait for dependencies
      - WAIT_FOR_PROTON=true
      - INIT_DB=true
      
      # Database password (will be set by init script)
      - PROTON_PASSWORD=${PROTON_PASSWORD:-}
      
      # Config source
      - CONFIG_SOURCE=${CONFIG_SOURCE:-file}
      - CONFIG_PATH=/etc/serviceradar/config/core.json
    depends_on:
      cert-generator:
        condition: service_completed_successfully
      config-updater:
        condition: service_completed_successfully
      core-jwks-init:
        condition: service_completed_successfully
      cert-permissions-fixer:
        condition: service_completed_successfully
      credentials-permissions-fixer:
        condition: service_completed_successfully
      proton:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "grpcurl", "-cacert", "/etc/serviceradar/certs/root.pem", "-cert", "/etc/serviceradar/certs/core.pem", "-key", "/etc/serviceradar/certs/core-key.pem", "-servername", "core.serviceradar", "localhost:50052", "grpc.health.v1.Health/Check"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    networks:
      serviceradar-net:
        aliases:
          - core.serviceradar
    restart: unless-stopped

  # ServiceRadar Web Application
  web:
    image: ghcr.io/carverauto/serviceradar-web:latest
    container_name: serviceradar-web
    environment:
      - NODE_ENV=production
      - NEXT_PUBLIC_API_URL=http://localhost/api
      - NEXT_INTERNAL_API_URL=http://core:8090
      - NEXT_INTERNAL_SRQL_URL=http://kong:8000
      - AUTH_ENABLED=true
      # API_KEY and JWT_SECRET will be loaded from generated config volume at runtime
    volumes:
      - cert-data:/etc/serviceradar/certs:ro
      - ./docker/compose/web.docker.json:/etc/serviceradar/web.json:ro
      - generated-config:/etc/serviceradar/config:ro
      - credentials:/etc/serviceradar/credentials:ro
    depends_on:
      config-updater:
        condition: service_completed_successfully
      core:
        condition: service_started
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://0.0.0.0:3000/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    networks:
      - serviceradar-net
    restart: unless-stopped

  # SRQL Service (OCaml) - handles /api/query requests routed via Kong
  srql:
    image: ghcr.io/carverauto/serviceradar-srql:latest
    container_name: serviceradar-srql
    environment:
      - PROTON_HOST=proton
      - PROTON_PORT=9440
      - PROTON_TLS=1
      - PROTON_INSECURE_SKIP_VERIFY=1
      - PROTON_VERIFY_HOSTNAME=0
      - AUTH_ENABLED=true
    volumes:
      - cert-data:/etc/serviceradar/certs:ro
      - generated-config:/etc/serviceradar/config:ro
      - credentials:/etc/serviceradar/credentials:ro
    depends_on:
      config-updater:
        condition: service_completed_successfully
      credentials-permissions-fixer:
        condition: service_completed_successfully
      proton:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-sf", "http://localhost:8080/health"]
      interval: 30s
      timeout: 5s
      retries: 5
      start_period: 20s
    networks:
      - serviceradar-net
    restart: unless-stopped

  # Nginx Reverse Proxy
  nginx:
    image: ghcr.io/carverauto/serviceradar-nginx:latest
    container_name: serviceradar-nginx
    ports:
      - "${SERVICERADAR_HTTP_PORT:-80}:80"      # HTTP
      # - "443:443"  # HTTPS (add SSL termination later)
    environment:
      API_UPSTREAM: ${API_UPSTREAM:-http://kong:8000}
    volumes:
      - cert-data:/etc/serviceradar/certs:ro
      - ./docker/compose/nginx.conf.template:/etc/nginx/templates/default.conf.template:ro
      - ./docker/compose/entrypoint-nginx.sh:/docker-entrypoint.d/50-serviceradar.sh:ro
    depends_on:
      web:
        condition: service_started
      core:
        condition: service_healthy
      kong:
        condition: service_started
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://127.0.0.1/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    networks:
      - serviceradar-net
    restart: unless-stopped

  # JWKS renderer - generates DB-less config for Kong from Core's JWKS
  kong-config:
    image: ghcr.io/carverauto/serviceradar-kong-config:latest
    container_name: serviceradar-kong-config
    user: "0:0"
    command: ["render-kong","--jwks","${JWKS_URL:-http://core:8090/auth/jwks.json}","--service","${KONG_SERVICE_URL:-http://core:8090}","--path","${KONG_ROUTE_PATH:-/api}","--srql-service","${SRQL_SERVICE_URL:-http://srql:8080}","--srql-path","${SRQL_ROUTE_PATH:-/api/query}","--out","/out/kong.yml"]
    volumes:
      - kong_config:/out
    depends_on:
      core:
        condition: service_healthy
    networks:
      - serviceradar-net
    # runs as part of default stack (no profile)
    restart: "no"

  # Kong (Community) — DB-less mode, optional 'kong' profile
  kong:
    image: ${KONG_IMAGE:-kong:latest}
    container_name: serviceradar-kong
    restart: on-failure
    # Start alongside kong-config; Kong's entrypoint will wait/copy default
    # so we don't block on kong-config completion.
    depends_on:
      kong-config:
        condition: service_started
      srql:
        condition: service_healthy
    environment:
      KONG_DATABASE: off
      KONG_DECLARATIVE_CONFIG: /opt/kong/kong.yml
      KONG_PROXY_LISTEN: 0.0.0.0:8000, 0.0.0.0:8443 ssl
      KONG_ADMIN_LISTEN: 0.0.0.0:8001
      # run Kong in foreground (no daemon) when using 'kong start'
      KONG_NGINX_DAEMON: off
      KONG_LOG_LEVEL: debug
    command: ["sh","-lc","if [ ! -f /opt/kong/kong.yml ]; then cp /default-kong.yml /opt/kong/kong.yml 2>/dev/null || true; fi; until [ -f /opt/kong/kong.yml ]; do echo '[kong] waiting for /opt/kong/kong.yml'; sleep 2; done; rm -f /usr/local/kong/pids/nginx.pid /opt/kong/pids/nginx.pid 2>/dev/null || true; exec kong start --vv"]
    volumes:
      - kong_config:/opt/kong
      - ./docker/kong/kong.yaml:/default-kong.yml:ro
    ports:
      - "8000:8000"
      - "8001:8001"
    networks:
      - serviceradar-net
    # runs as part of default stack (no profile)
    healthcheck:
      test: ["CMD", "kong", "health"]
      interval: 10s
      timeout: 5s
      retries: 12
      start_period: 20s

  

  # ServiceRadar Poller Service
  poller:
    image: ghcr.io/carverauto/serviceradar-poller:latest
    container_name: serviceradar-poller
    volumes:
      - cert-data:/etc/serviceradar/certs:ro
      - generated-config:/etc/serviceradar/config:ro
      - poller-data:/var/lib/serviceradar
      - ./logs:/var/log/serviceradar
    environment:
      # Config path
      - CONFIG_PATH=/etc/serviceradar/config/poller.json
      - POLLERS_SECURITY_MODE=${POLLERS_SECURITY_MODE:-mtls}
      - MANAGE_NESTED_SPIRE=${MANAGE_NESTED_SPIRE:-disabled}
      - POLLERS_TRUST_DOMAIN=${POLLERS_TRUST_DOMAIN:-carverauto.dev}
      - NESTED_SPIRE_CONFIG_DIR=/etc/serviceradar/config/poller-spire
      - NESTED_SPIRE_PARENT_ID=${NESTED_SPIRE_PARENT_ID:-spiffe://carverauto.dev/ns/edge/poller-nested-spire}
      - NESTED_SPIRE_DOWNSTREAM_SPIFFE_ID=${NESTED_SPIRE_DOWNSTREAM_SPIFFE_ID:-spiffe://carverauto.dev/services/poller}
      - NESTED_SPIRE_AGENT_SPIFFE_ID=${NESTED_SPIRE_AGENT_SPIFFE_ID:-spiffe://carverauto.dev/services/agent}
      - NESTED_SPIRE_UPSTREAM_JOIN_TOKEN=${NESTED_SPIRE_UPSTREAM_JOIN_TOKEN:-}
      - NESTED_SPIRE_UPSTREAM_JOIN_TOKEN_FILE=${NESTED_SPIRE_UPSTREAM_JOIN_TOKEN_FILE:-}
      - NESTED_SPIRE_UPSTREAM_TRUST_BUNDLE=${NESTED_SPIRE_UPSTREAM_TRUST_BUNDLE:-}
      - NESTED_SPIRE_UPSTREAM_TRUST_BUNDLE_FILE=${NESTED_SPIRE_UPSTREAM_TRUST_BUNDLE_FILE:-}
      - NESTED_SPIRE_DOWNSTREAM_JOIN_TOKEN=${NESTED_SPIRE_DOWNSTREAM_JOIN_TOKEN:-}
      - NESTED_SPIRE_DOWNSTREAM_JOIN_TOKEN_FILE=${NESTED_SPIRE_DOWNSTREAM_JOIN_TOKEN_FILE:-}
      - NESTED_SPIRE_AUTO_GENERATE_DOWNSTREAM_TOKEN=${NESTED_SPIRE_AUTO_GENERATE_DOWNSTREAM_TOKEN:-1}
      - NESTED_SPIRE_SERVER_SOCKET=${NESTED_SPIRE_SERVER_SOCKET:-/run/spire/nested/server/api.sock}
      - ENABLE_POLLER_JOIN_TOKEN=${ENABLE_POLLER_JOIN_TOKEN:-enabled}
      - DOWNSTREAM_REGISTRATION_MODE=${DOWNSTREAM_REGISTRATION_MODE:-disabled}
      # Logging
      - LOG_LEVEL=${LOG_LEVEL:-info}
    depends_on:
      cert-generator:
        condition: service_completed_successfully
      config-updater:
        condition: service_completed_successfully
      core:
        condition: service_healthy
    command: ["/usr/local/bin/serviceradar-poller","-config","/etc/serviceradar/config/poller.json"]
    healthcheck:
      test: ["CMD", "grpcurl", "-cacert", "/etc/serviceradar/certs/root.pem", "-cert", "/etc/serviceradar/certs/poller.pem", "-key", "/etc/serviceradar/certs/poller-key.pem", "-servername", "poller.serviceradar", "localhost:50053", "grpc.health.v1.Health/Check"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    networks:
      serviceradar-net:
        aliases:
          - poller.serviceradar
    restart: unless-stopped

  # ServiceRadar Agent Service
  agent:
    image: ghcr.io/carverauto/serviceradar-agent:latest
    container_name: serviceradar-agent
    volumes:
      - ./docker/compose/agent.docker.json:/etc/serviceradar/agent.json:ro
      - cert-data:/etc/serviceradar/certs:ro
      - generated-config:/etc/serviceradar/config:ro
      - agent-data:/var/lib/serviceradar
      - ./logs:/var/log/serviceradar
    environment:
      # Config path
      - CONFIG_PATH=/etc/serviceradar/agent.json
      # Logging
      - LOG_LEVEL=${LOG_LEVEL:-info}
    # Required capabilities for network operations
    cap_add:
      - NET_RAW
      - NET_ADMIN
    # Enable privileged mode for high-performance SYN scanning
    privileged: true
    depends_on:
      cert-generator:
        condition: service_completed_successfully
      config-updater:
        condition: service_completed_successfully
    command: ["/bin/sh","-c","if [ -f /etc/serviceradar/config/checkers/sysmon-vm.json ]; then cp /etc/serviceradar/config/checkers/sysmon-vm.json /etc/serviceradar/checkers/sysmon-vm.json; fi; exec /usr/local/bin/serviceradar-agent -config /etc/serviceradar/agent.json"]
    healthcheck:
      test: ["CMD", "grpcurl", "-cacert", "/etc/serviceradar/certs/root.pem", "-cert", "/etc/serviceradar/certs/agent.pem", "-key", "/etc/serviceradar/certs/agent-key.pem", "-servername", "agent.serviceradar", "localhost:50051", "grpc.health.v1.Health/Check"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    networks:
      serviceradar-net:
        aliases:
          - agent.serviceradar
    restart: unless-stopped

  # NATS for messaging and KV store
  nats:
    image: nats:latest
    platform: linux/amd64
    container_name: serviceradar-nats
    ports:
      - "4222:4222"  # Client connections
      - "8222:8222"  # HTTP monitoring
      - "6222:6222"  # Cluster routing
    volumes:
      - nats-data:/data
      - cert-data:/etc/serviceradar/certs:ro
      - ./docker/compose/nats.docker.conf:/etc/nats/nats-server.conf:ro
    command: ["--config", "/etc/nats/nats-server.conf"]
    depends_on:
      cert-generator:
        condition: service_completed_successfully
      cert-permissions-fixer:
        condition: service_completed_successfully
    # Health check disabled - minimal NATS image doesn't include wget/curl
    # NATS logs show when it's ready, and other services will connect via mTLS
    # healthcheck:
    #   test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8222/varz"]
    #   interval: 30s
    #   timeout: 5s
    #   retries: 3
    #   start_period: 30s
    networks:
      serviceradar-net:
        aliases:
          - nats.serviceradar
    restart: unless-stopped

  # ServiceRadar Data Service (KV + object store via NATS JetStream)
  datasvc:
    image: ghcr.io/carverauto/serviceradar-datasvc:latest
    container_name: serviceradar-datasvc
    cpus: "2.0"
    ports:
      - "50057:50057"  # gRPC port
    volumes:
      - ./docker/compose/datasvc.docker.json:/etc/serviceradar/datasvc.json:ro
      - cert-data:/etc/serviceradar/certs:ro
      - datasvc-data:/var/lib/serviceradar
      - ./logs:/var/log/serviceradar
    environment:
      # Config path
      - CONFIG_PATH=/etc/serviceradar/datasvc.json
      # Wait for dependencies
      - WAIT_FOR_NATS=true
      # Logging
      - LOG_LEVEL=${LOG_LEVEL:-info}
    depends_on:
      cert-generator:
        condition: service_completed_successfully
      nats:
        condition: service_started
    healthcheck:
      test: ["CMD", "grpcurl", "-cacert", "/etc/serviceradar/certs/root.pem", "-cert", "/etc/serviceradar/certs/datasvc.pem", "-key", "/etc/serviceradar/certs/datasvc-key.pem", "-servername", "datasvc.serviceradar", "localhost:50057", "grpc.health.v1.Health/Check"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    networks:
      serviceradar-net:
        aliases:
          - datasvc.serviceradar
    restart: unless-stopped

  # ServiceRadar Sync Service (Device discovery synchronization)
  sync:
    image: ghcr.io/carverauto/serviceradar-sync:latest
    container_name: serviceradar-sync
    ports:
      - "50058:50058"  # gRPC port
    volumes:
      - ./docker/compose/sync.docker.json:/etc/serviceradar/sync.json:ro
      - cert-data:/etc/serviceradar/certs:ro
      - sync-data:/var/lib/serviceradar
      - ./logs:/var/log/serviceradar
    environment:
      # Config path
      - CONFIG_PATH=/etc/serviceradar/sync.json
      # Wait for dependencies
      - WAIT_FOR_DATASVC=true
      - WAIT_FOR_NATS=true
      # Logging
      - LOG_LEVEL=${LOG_LEVEL:-info}
    depends_on:
      cert-generator:
        condition: service_completed_successfully
      datasvc:
        condition: service_healthy
      nats:
        condition: service_started
    # Health check disabled - sync service may not implement standard gRPC health service
    # Service logs show when it's ready and healthy
    # healthcheck:
    #   test: ["CMD", "grpcurl", "-plaintext", "localhost:50058", "grpc.health.v1.Health/Check"]
    #   interval: 30s
    #   timeout: 10s
    #   retries: 3
    #   start_period: 60s
    networks:
      - serviceradar-net
    restart: unless-stopped

  # ServiceRadar OTEL Service (OpenTelemetry collector)
  otel:
    image: ghcr.io/carverauto/serviceradar-otel:latest
    container_name: serviceradar-otel
    ports:
      - "4317:4317"  # OTEL gRPC port
    volumes:
      - ./docker/compose/otel.docker.toml:/etc/serviceradar/otel.toml:ro
      - cert-data:/etc/serviceradar/certs:ro
      - otel-data:/var/lib/serviceradar
      - ./logs:/var/log/serviceradar
    environment:
      # Config path
      - CONFIG_PATH=/etc/serviceradar/otel.toml
      # Wait for dependencies
      - WAIT_FOR_NATS=true
      # Logging
      - LOG_LEVEL=${LOG_LEVEL:-info}
    depends_on:
      cert-generator:
        condition: service_completed_successfully
      nats:
        condition: service_started
    # Health check disabled - OTEL service may not implement standard gRPC health service
    # Service logs show when it's ready and healthy
    # healthcheck:
    #   test: ["CMD", "grpcurl", "-plaintext", "localhost:4317", "grpc.health.v1.Health/Check"]
    #   interval: 30s
    #   timeout: 10s
    #   retries: 3
    #   start_period: 60s
    networks:
      - serviceradar-net
    restart: unless-stopped

  # ServiceRadar Flowgger Service (Syslog collector)
  flowgger:
    image: ghcr.io/carverauto/serviceradar-flowgger:latest
    container_name: serviceradar-flowgger
    ports:
      - "514:514/udp"  # Syslog UDP port
      - "50044:50044"  # gRPC port
    volumes:
      - ./docker/compose/flowgger.docker.toml:/etc/serviceradar/flowgger.toml:ro
      - cert-data:/etc/serviceradar/certs:ro
      - flowgger-data:/var/lib/serviceradar
      - ./logs:/var/log/serviceradar
    environment:
      # Config path
      - CONFIG_PATH=/etc/serviceradar/flowgger.toml
      # Wait for dependencies
      - WAIT_FOR_NATS=true
      # Logging
      - RUST_LOG=${RUST_LOG:-info}
    # Capabilities needed for binding to port 514
    cap_add:
      - NET_BIND_SERVICE
    depends_on:
      cert-generator:
        condition: service_completed_successfully
      nats:
        condition: service_started
    # Health check disabled - Flowgger service may not implement standard gRPC health service
    # Service logs show when it's ready and healthy
    # healthcheck:
    #   test: ["CMD", "grpcurl", "-plaintext", "localhost:50044", "grpc.health.v1.Health/Check"]
    #   interval: 30s
    #   timeout: 10s
    #   retries: 3
    #   start_period: 60s
    networks:
      - serviceradar-net
    restart: unless-stopped

  # ServiceRadar Trapd Service (SNMP trap collector)
  trapd:
    image: ghcr.io/carverauto/serviceradar-trapd:latest
    container_name: serviceradar-trapd
    ports:
      - "162:162/udp"  # SNMP trap UDP port
      - "50043:50043"  # gRPC port
    volumes:
      - ./docker/compose/trapd.docker.json:/etc/serviceradar/trapd.json:ro
      - cert-data:/etc/serviceradar/certs:ro
      - trapd-data:/var/lib/serviceradar
      - ./logs:/var/log/serviceradar
    environment:
      # Config path
      - CONFIG_PATH=/etc/serviceradar/trapd.json
      # Wait for dependencies
      - WAIT_FOR_NATS=true
      # Logging
      - RUST_LOG=${RUST_LOG:-info}
    # Capabilities needed for binding to privileged port 162
    cap_add:
      - NET_BIND_SERVICE
    depends_on:
      cert-generator:
        condition: service_completed_successfully
      nats:
        condition: service_started
    # Health check disabled - Trapd service may not implement standard gRPC health service
    # Service logs show when it's ready and healthy
    # healthcheck:
    #   test: ["CMD", "grpcurl", "-plaintext", "localhost:50043", "grpc.health.v1.Health/Check"]
    #   interval: 30s
    #   timeout: 10s
    #   retries: 3
    #   start_period: 60s
    networks:
      - serviceradar-net
    restart: unless-stopped

  # ServiceRadar Zen Service (Event processing and rule engine)
  zen:
    image: ghcr.io/carverauto/serviceradar-zen:latest
    container_name: serviceradar-zen
    ports:
      - "50040:50040"  # gRPC port
    volumes:
      - ./docker/compose/zen.docker.json:/etc/serviceradar/zen.json:ro
      - cert-data:/etc/serviceradar/certs:ro
      - zen-data:/var/lib/serviceradar
      - ./logs:/var/log/serviceradar
    environment:
      # Config path
      - CONFIG_PATH=/etc/serviceradar/zen.json
      # Wait for dependencies
      - WAIT_FOR_NATS=true
      - WAIT_FOR_DATASVC=true
      # Logging
      - RUST_LOG=${RUST_LOG:-info}
    depends_on:
      cert-generator:
        condition: service_completed_successfully
      nats:
        condition: service_started
      datasvc:
        condition: service_healthy
    # Health check disabled - Zen service may not implement standard gRPC health service
    # Service logs show when it's ready and healthy
    # healthcheck:
    #   test: ["CMD", "grpcurl", "-plaintext", "localhost:50040", "grpc.health.v1.Health/Check"]
    #   interval: 30s
    #   timeout: 10s
    #   retries: 3
    #   start_period: 60s
    networks:
      - serviceradar-net
    restart: unless-stopped

  # ServiceRadar DB Event Writer Service (NATS to Database bridge)
  db-event-writer:
    image: ghcr.io/carverauto/serviceradar-db-event-writer:latest
    container_name: serviceradar-db-event-writer
    ports:
      - "50041:50041"  # gRPC port
    volumes:
      - ./docker/compose/db-event-writer.docker.json:/etc/serviceradar/templates/db-event-writer.json:ro
      - cert-data:/etc/serviceradar/certs:ro
      - credentials:/etc/serviceradar/credentials:ro
      - db-event-writer-data:/var/lib/serviceradar
      - db-event-writer-config:/etc/serviceradar/consumers
      - ./logs:/var/log/serviceradar
    environment:
      # Wait for dependencies
      - WAIT_FOR_NATS=true
      - WAIT_FOR_PROTON=true
      # Database password
      - PROTON_PASSWORD=${PROTON_PASSWORD:-}
      # Logging
      - LOG_LEVEL=${LOG_LEVEL:-info}
    depends_on:
      cert-generator:
        condition: service_completed_successfully
      nats:
        condition: service_started
      proton:
        condition: service_healthy
      credentials-permissions-fixer:
        condition: service_completed_successfully
    healthcheck:
      test: ["CMD", "grpcurl", "-cacert", "/etc/serviceradar/certs/root.pem", "-cert", "/etc/serviceradar/certs/db-event-writer.pem", "-key", "/etc/serviceradar/certs/db-event-writer-key.pem", "-servername", "db-event-writer.serviceradar", "localhost:50041", "grpc.health.v1.Health/Check"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    networks:
      - serviceradar-net
    restart: unless-stopped

  # ServiceRadar Mapper - SNMP Network Discovery Service
  mapper:
    image: ghcr.io/carverauto/serviceradar-mapper:latest
    container_name: serviceradar-mapper
    ports:
      - "50056:50056"  # gRPC port
    volumes:
      - ./docker/compose/mapper.docker.json:/etc/serviceradar/mapper.json:ro
      - cert-data:/etc/serviceradar/certs:ro
      - mapper-data:/var/lib/serviceradar
      - ./logs:/var/log/serviceradar
    environment:
      # Wait for dependencies
      - WAIT_FOR_OTEL=true
      # Logging
      - LOG_LEVEL=${LOG_LEVEL:-info}
    depends_on:
      cert-permissions-fixer:
        condition: service_completed_successfully
      otel:
        condition: service_started
    healthcheck:
      test: ["CMD", "grpcurl", "-cacert", "/etc/serviceradar/certs/root.pem", "-cert", "/etc/serviceradar/certs/mapper.pem", "-key", "/etc/serviceradar/certs/mapper-key.pem", "-servername", "mapper.serviceradar", "localhost:50056", "grpc.health.v1.Health/Check"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    networks:
      - serviceradar-net
    restart: unless-stopped

  # ServiceRadar SNMP Checker - SNMP Polling Service
  snmp-checker:
    image: ghcr.io/carverauto/serviceradar-snmp-checker:latest
    container_name: serviceradar-snmp-checker
    ports:
      - "50054:50054"  # gRPC port
    volumes:
      - ./docker/compose/snmp-checker.docker.json:/etc/serviceradar/checkers/snmp.json:ro
      - cert-data:/etc/serviceradar/certs:ro
      - snmp-checker-data:/var/lib/serviceradar
      - ./logs:/var/log/serviceradar
    environment:
      # Wait for dependencies
      - WAIT_FOR_AGENT=true
      - WAIT_FOR_OTEL=true
      # Logging
      - LOG_LEVEL=${LOG_LEVEL:-info}
    depends_on:
      cert-permissions-fixer:
        condition: service_completed_successfully
      agent:
        condition: service_started
      otel:
        condition: service_started
    healthcheck:
      test: ["CMD", "grpcurl", "-cacert", "/etc/serviceradar/certs/root.pem", "-cert", "/etc/serviceradar/certs/snmp-checker.pem", "-key", "/etc/serviceradar/certs/snmp-checker-key.pem", "-servername", "snmp-checker.serviceradar", "localhost:50054", "grpc.health.v1.Health/Check"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    networks:
      - serviceradar-net
    restart: unless-stopped

  # ServiceRadar rperf Client - Network Performance Testing Service
  rperf-client:
    image: ghcr.io/carverauto/serviceradar-rperf-client:latest
    container_name: serviceradar-rperf-client
    ports:
      - "50059:50059"  # gRPC port
    volumes:
      - cert-data:/etc/serviceradar/certs:ro
      - rperf-client-data:/var/lib/serviceradar
      - ./logs:/var/log/serviceradar
    environment:
      # Wait for dependencies
      - WAIT_FOR_AGENT=true
      - WAIT_FOR_OTEL=true
      # Logging
      - LOG_LEVEL=${LOG_LEVEL:-info}
      - RUST_LOG=${RUST_LOG:-info}
    depends_on:
      cert-permissions-fixer:
        condition: service_completed_successfully
      agent:
        condition: service_started
      otel:
        condition: service_started
    healthcheck:
      test: ["CMD", "grpcurl", "-cacert", "/etc/serviceradar/certs/root.pem", "-cert", "/etc/serviceradar/certs/rperf-client.pem", "-key", "/etc/serviceradar/certs/rperf-client-key.pem", "-servername", "rperf-client.serviceradar", "localhost:50059", "grpc.health.v1.Health/Check"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    networks:
      - serviceradar-net
    restart: unless-stopped

networks:
  serviceradar-net:
    driver: bridge
    driver_opts:
      com.docker.network.bridge.name: serviceradar-br

volumes:
  cert-data:
    driver: local
  credentials:
    driver: local
  generated-config:
    driver: local
  proton-data:
    driver: local
  core-data:
    driver: local
  poller-data:
    driver: local
  agent-data:
    driver: local
  nats-data:
    driver: local
  datasvc-data:
    driver: local
  sync-data:
    driver: local
  otel-data:
    driver: local
  flowgger-data:
    driver: local
  trapd-data:
    driver: local
  zen-data:
    driver: local
  db-event-writer-data:
    driver: local
  db-event-writer-config:
    driver: local
  mapper-data:
    driver: local
  snmp-checker-data:
    driver: local
  rperf-client-data:
    driver: local
  kong_config:
    driver: local
  kong_db_data:
    driver: local
