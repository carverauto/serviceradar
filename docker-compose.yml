services:
  # Certificate Generation Service (runs once to generate mTLS certs)
  cert-generator:
    image: ghcr.io/carverauto/serviceradar-cert-generator:${SERVICERADAR_VERSION:-latest}
    container_name: serviceradar-cert-generator
    volumes:
      - cert-data:/certs
    restart: "no"  # Only run once
    networks:
      - serviceradar-net

  # Configuration Updater (runs after cert generation to update configs with secrets)
  config-updater:
    build:
      context: .
      dockerfile: docker/compose/Dockerfile.config-updater
    container_name: serviceradar-config-updater
    volumes:
      - cert-data:/etc/serviceradar/certs
      - generated-config:/etc/serviceradar/config
      - ./packaging/core/config:/config:ro
    depends_on:
      cert-generator:
        condition: service_completed_successfully
    restart: "no"  # Only run once
    networks:
      - serviceradar-net

  # Fix certificate permissions for Docker deployment
  cert-permissions-fixer:
    image: alpine:3.20
    container_name: serviceradar-cert-permissions-fixer
    volumes:
      - cert-data:/etc/serviceradar/certs
      - ./docker/compose/fix-cert-permissions.sh:/fix-cert-permissions.sh:ro
    command: sh /fix-cert-permissions.sh
    depends_on:
      config-updater:
        condition: service_completed_successfully
    restart: "no"  # Only run once
    networks:
      - serviceradar-net

  # Proton (TimeBase) Database with custom configuration
  proton:
    image: ghcr.io/carverauto/serviceradar-proton:1.0.53-perms
    container_name: serviceradar-proton
    ports:
      - "8123:8123"  # HTTP port for JDBC driver, batch mode
      - "8463:8463"  # Native TCP port
      - "8443:8443"  # HTTPS port (with TLS)
      - "9440:9440"  # Native TCP secure port (with TLS)
    volumes:
      - proton-data:/var/lib/proton
      - cert-data:/etc/serviceradar/certs:ro
      - cert-data:/etc/proton-server/certs:ro
      - credentials:/etc/serviceradar/credentials
    environment:
      - PROTON_PASSWORD=${PROTON_PASSWORD:-}  # Will generate if not set
      - PROTON_LOG_LEVEL=${PROTON_LOG_LEVEL:-error}
    ulimits:
      nofile:
        soft: 1048576
        hard: 1048576
      nproc:
        soft: 65535
        hard: 65535
    # sysctls disabled for Docker Desktop compatibility
    # In production Linux environments, you can enable these:
    # sysctls:
    #   - kernel.threads-max=100000  
    #   - kernel.pid_max=100000
    #   - vm.nr_hugepages=0
    cap_add:
      - NET_ADMIN
      - IPC_LOCK
      - SYS_NICE
    healthcheck:
      test: ["CMD-SHELL", "curl -sf http://localhost:8123/?query=SELECT%201 || curl -sf http://default:$(cat /etc/proton-server/generated_password.txt)@localhost:8123/?query=SELECT%201 || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 30s
    depends_on:
      cert-generator:
        condition: service_completed_successfully
    networks:
      - serviceradar-net
    restart: unless-stopped

  # ServiceRadar Core Service
  core:
    image: serviceradar-core:shared-creds
    container_name: serviceradar-core
    # Expose core ports for debugging authentication
    ports:
      - "8090:8090"  # HTTP API
      - "50052:50052"  # gRPC (matching core.json)
      - "9090:9090"  # Metrics (Prometheus)
    volumes:
      # Use generated config files with secrets (generated by config-updater)
      - generated-config:/etc/serviceradar/config:ro
      - cert-data:/etc/serviceradar/certs:ro
      - credentials:/etc/serviceradar/credentials:ro
      - core-data:/var/lib/serviceradar
      - ./logs:/var/log/serviceradar
    environment:
      # Wait for dependencies
      - WAIT_FOR_PROTON=true
      - INIT_DB=true
      
      # Database password (will be set by init script)
      - PROTON_PASSWORD=${PROTON_PASSWORD:-}
      
      # Config source
      - CONFIG_SOURCE=${CONFIG_SOURCE:-file}
      - CONFIG_PATH=/etc/serviceradar/config/core.json
    depends_on:
      cert-generator:
        condition: service_completed_successfully
      config-updater:
        condition: service_completed_successfully
      cert-permissions-fixer:
        condition: service_completed_successfully
      proton:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "grpcurl", "-cacert", "/etc/serviceradar/certs/root.pem", "-cert", "/etc/serviceradar/certs/core.pem", "-key", "/etc/serviceradar/certs/core-key.pem", "-servername", "serviceradar-core", "localhost:50052", "grpc.health.v1.Health/Check"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    networks:
      - serviceradar-net
    restart: unless-stopped

  # ServiceRadar Web Application
  web:
    image: serviceradar-web:local
    build:
      context: .
      dockerfile: docker/compose/Dockerfile.web
      args:
        - NEXT_PUBLIC_API_URL=http://localhost/api
        - NEXT_INTERNAL_API_URL=http://core:8090
    container_name: serviceradar-web
    environment:
      - NODE_ENV=production
      - NEXT_PUBLIC_API_URL=http://localhost/api
      - NEXT_INTERNAL_API_URL=http://core:8090
      - AUTH_ENABLED=true
      # API_KEY and JWT_SECRET will be loaded from generated config volume at runtime
    volumes:
      - cert-data:/etc/serviceradar/certs:ro
      - ./docker/compose/web.docker.json:/etc/serviceradar/web.json:ro
      - generated-config:/etc/serviceradar/config:ro
      - credentials:/etc/serviceradar/credentials:ro
    depends_on:
      config-updater:
        condition: service_completed_successfully
      core:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    networks:
      - serviceradar-net
    restart: unless-stopped

  # Nginx Reverse Proxy
  nginx:
    image: serviceradar-nginx:local
    build:
      context: .
      dockerfile: docker/compose/Dockerfile.nginx
    container_name: serviceradar-nginx
    ports:
      - "80:80"      # HTTP
      # - "443:443"  # HTTPS (add SSL termination later)
    volumes:
      - cert-data:/etc/serviceradar/certs:ro
    depends_on:
      web:
        condition: service_healthy
      core:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    networks:
      - serviceradar-net
    restart: unless-stopped

  # ServiceRadar Poller Service
  poller:
    image: serviceradar-poller:local
    build:
      context: .
      dockerfile: docker/compose/Dockerfile.poller
    container_name: serviceradar-poller
    volumes:
      - ./docker/compose/poller.docker.json:/etc/serviceradar/poller.json:ro
      - cert-data:/etc/serviceradar/certs:ro
      - poller-data:/var/lib/serviceradar
      - ./logs:/var/log/serviceradar
    environment:
      # Config path
      - CONFIG_PATH=/etc/serviceradar/poller.json
      # Logging
      - LOG_LEVEL=${LOG_LEVEL:-info}
    depends_on:
      cert-generator:
        condition: service_completed_successfully
      core:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "grpcurl", "-cacert", "/etc/serviceradar/certs/root.pem", "-cert", "/etc/serviceradar/certs/core.pem", "-key", "/etc/serviceradar/certs/core-key.pem", "-servername", "serviceradar-poller", "localhost:50053", "grpc.health.v1.Health/Check"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    networks:
      - serviceradar-net
    restart: unless-stopped

  # ServiceRadar Agent Service
  agent:
    image: serviceradar-agent:local
    build:
      context: .
      dockerfile: docker/compose/Dockerfile.agent
    container_name: serviceradar-agent
    volumes:
      - cert-data:/etc/serviceradar/certs:ro
      - agent-data:/var/lib/serviceradar
      - ./logs:/var/log/serviceradar
    environment:
      # Config path
      - CONFIG_PATH=/etc/serviceradar/agent.json
      # Logging
      - LOG_LEVEL=${LOG_LEVEL:-info}
    # Required capabilities for network operations
    cap_add:
      - NET_RAW
      - NET_ADMIN
    depends_on:
      cert-generator:
        condition: service_completed_successfully
    healthcheck:
      test: ["CMD", "grpcurl", "-cacert", "/etc/serviceradar/certs/root.pem", "-cert", "/etc/serviceradar/certs/core.pem", "-key", "/etc/serviceradar/certs/core-key.pem", "-servername", "serviceradar-agent", "localhost:50051", "grpc.health.v1.Health/Check"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    networks:
      - serviceradar-net
    restart: unless-stopped

  # NATS for messaging and KV store
  nats:
    image: nats:latest
    container_name: serviceradar-nats
    ports:
      - "4222:4222"  # Client connections
      - "8222:8222"  # HTTP monitoring
      - "6222:6222"  # Cluster routing
    volumes:
      - nats-data:/data
      - cert-data:/etc/serviceradar/certs:ro
      - ./docker/compose/nats.docker.conf:/etc/nats/nats-server.conf:ro
    command: ["--config", "/etc/nats/nats-server.conf"]
    depends_on:
      cert-generator:
        condition: service_completed_successfully
      cert-permissions-fixer:
        condition: service_completed_successfully
    healthcheck:
      test: ["CMD", "nats", "server", "ping"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 30s
    networks:
      - serviceradar-net
    restart: unless-stopped

networks:
  serviceradar-net:
    driver: bridge

volumes:
  cert-data:
    driver: local
  credentials:
    driver: local
  generated-config:
    driver: local
  proton-data:
    driver: local
  core-data:
    driver: local
  poller-data:
    driver: local
  agent-data:
    driver: local
  nats-data:
    driver: local