diff --git a/cmd/cli/main.go b/cmd/cli/main.go
new file mode 100644
index 0000000..8e00510
--- /dev/null
+++ b/cmd/cli/main.go
@@ -0,0 +1,24 @@
+package main
+
+import (
+	"fmt"
+	"os"
+
+	"golang.org/x/crypto/bcrypt"
+)
+
+func main() {
+	if len(os.Args) != 3 {
+		fmt.Println("Usage: serviceradar <username> <password>")
+		os.Exit(1)
+	}
+	username := os.Args[1]
+	password := os.Args[2]
+
+	hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
+	if err != nil {
+		fmt.Printf("Error generating hash: %v\n", err)
+		os.Exit(1)
+	}
+	fmt.Printf("%s:%s\n", username, string(hash))
+}
\ No newline at end of file
diff --git a/packaging/core/config/core.json b/packaging/core/config/core.json
index d20436f..e5c9221 100644
--- a/packaging/core/config/core.json
+++ b/packaging/core/config/core.json
@@ -9,10 +9,18 @@
         "max_nodes": 10000
     },
     "security": {
-        "mode": "none",
+        "mode": "mtls",
         "cert_dir": "/etc/serviceradar/certs",
         "role": "core"
     },
+    "auth": {
+        "jwt_secret": "your-secret-key-here",
+        "jwt_expiration": "24h",
+        "local_users": {
+            "admin": "$2a$10$abcdefghijklmnopqrstuv",
+            "operator": "$2a$10$xyzxyzxyzxyzxyzxyzxyzxy"
+        }
+    },
     "webhooks": [
         {
             "enabled": false,
@@ -26,10 +34,10 @@
             ]
         },
         {
-            "enabled": true,
+            "enabled": false,
             "url": "https://discord.com/api/webhooks/changeme",
             "cooldown": "15m",
             "template": "{\"embeds\":[{\"title\":\"{{.alert.Title}}\",\"description\":\"{{.alert.Message}}\",\"color\":{{if eq .alert.Level \"error\"}}15158332{{else if eq .alert.Level \"warning\"}}16776960{{else}}3447003{{end}},\"timestamp\":\"{{.alert.Timestamp}}\",\"fields\":[{\"name\":\"Node ID\",\"value\":\"{{.alert.NodeID}}\",\"inline\":true}{{range $key, $value := .alert.Details}},{\"name\":\"{{$key}}\",\"value\":\"{{$value}}\",\"inline\":true}{{end}}]}]}"
         }
     ]
-}
+}
\ No newline at end of file
diff --git a/packaging/web/config/nginx.conf b/packaging/web/config/nginx.conf
index f27940c..56b262c 100644
--- a/packaging/web/config/nginx.conf
+++ b/packaging/web/config/nginx.conf
@@ -15,6 +15,15 @@ server {
         proxy_set_header X-Forwarded-Proto $scheme;
     }
 
+    # Auth proxy (route /auth/ to Go API)
+    location /auth/ {
+        proxy_pass http://localhost:8090;
+        proxy_set_header Host $host;
+        proxy_set_header X-Real-IP $remote_addr;
+        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
+        proxy_set_header X-Forwarded-Proto $scheme;
+    }
+
     # Support for Next.js WebSockets (if used)
     location /_next/webpack-hmr {
         proxy_pass http://localhost:3000;
diff --git a/pkg/core/api/auth.go b/pkg/core/api/auth.go
index be15873..b0ea0cf 100644
--- a/pkg/core/api/auth.go
+++ b/pkg/core/api/auth.go
@@ -10,30 +10,32 @@ import (
 	"github.com/markbates/goth/gothic"
 )
 
-// Ensure handleLocalLogin handles OPTIONS
 func (s *APIServer) handleLocalLogin(w http.ResponseWriter, r *http.Request) {
-	if r.Method == http.MethodOptions {
-		w.WriteHeader(http.StatusOK)
-		return
-	}
 	var creds struct {
 		Username string `json:"username"`
 		Password string `json:"password"`
 	}
+
 	if err := json.NewDecoder(r.Body).Decode(&creds); err != nil {
 		http.Error(w, "invalid request", http.StatusBadRequest)
+
 		return
 	}
+
 	token, err := s.authService.LoginLocal(r.Context(), creds.Username, creds.Password)
 	if err != nil {
 		http.Error(w, "login failed: "+err.Error(), http.StatusUnauthorized)
+
 		return
 	}
+
 	if err := s.encodeJSONResponse(w, token); err != nil {
 		log.Printf("Error encoding login response: %v", err)
 		http.Error(w, "login failed", http.StatusInternalServerError)
+
 		return
 	}
+
 	log.Printf("Login response sent for %s", creds.Username)
 }
 
diff --git a/pkg/core/api/server.go b/pkg/core/api/server.go
index 8819a38..cbac8d1 100644
--- a/pkg/core/api/server.go
+++ b/pkg/core/api/server.go
@@ -66,11 +66,13 @@ func WithSNMPManager(m snmp.SNMPManager) func(server *APIServer) {
 }
 
 func (s *APIServer) setupRoutes() {
+	// Create a middleware chain
 	middlewareChain := func(next http.Handler) http.Handler {
-		// Order matters: CORS first, then API key/auth checks
+		// Order matters: first API key check, then CORS headers
 		return srHttp.CommonMiddleware(srHttp.APIKeyMiddleware(os.Getenv("API_KEY"))(next))
 	}
 
+	// Add middleware to router
 	s.router.Use(middlewareChain)
 
 	// Public routes
@@ -79,9 +81,8 @@ func (s *APIServer) setupRoutes() {
 	s.router.HandleFunc("/auth/{provider}", s.handleOAuthBegin).Methods("GET")
 	s.router.HandleFunc("/auth/{provider}/callback", s.handleOAuthCallback).Methods("GET")
 
-	// Protected routes
 	protected := s.router.PathPrefix("/api").Subrouter()
-	if os.Getenv("AUTH_ENABLED") == "true" && s.authService != nil {
+	if os.Getenv("AUTH_ENABLED") == "true" {
 		protected.Use(auth.AuthMiddleware(s.authService))
 	}
 
@@ -95,17 +96,6 @@ func (s *APIServer) setupRoutes() {
 	protected.HandleFunc("/nodes/{id}/snmp", s.getSNMPData).Methods("GET")
 }
 
-func (s *APIServer) getAuthStatus(w http.ResponseWriter, r *http.Request) {
-	status := struct {
-		AuthEnabled bool `json:"auth_enabled"`
-	}{
-		AuthEnabled: os.Getenv("AUTH_ENABLED") == "true",
-	}
-	if err := s.encodeJSONResponse(w, status); err != nil {
-		http.Error(w, "Internal server error", http.StatusInternalServerError)
-	}
-}
-
 // getSNMPData retrieves SNMP data for a specific node.
 func (s *APIServer) getSNMPData(w http.ResponseWriter, r *http.Request) {
 	vars := mux.Vars(r)
diff --git a/pkg/core/auth/auth.go b/pkg/core/auth/auth.go
index fb36c74..10548d5 100644
--- a/pkg/core/auth/auth.go
+++ b/pkg/core/auth/auth.go
@@ -50,16 +50,20 @@ func NewAuth(config *models.AuthConfig, db db.Service) *Auth {
 }
 
 func (a *Auth) LoginLocal(ctx context.Context, username, password string) (*models.Token, error) {
-	log.Printf("LoginLocal: %s, pass: %s", username, password)
+	// lets do some debug logging here
+	log.Printf("us3rname: %s, password: %s\n", username, password)
+
+	// print config
+	log.Println("LocalUsers Config: ", a.config.LocalUsers)
 
 	storedHash, ok := a.config.LocalUsers[username]
 	if !ok {
 		return nil, db.ErrUserNotFound
 	}
 
-	log.Printf("Stored hash for %s: %s", username, storedHash)
-
 	if err := bcrypt.CompareHashAndPassword([]byte(storedHash), []byte(password)); err != nil {
+		log.Printf("Bcrypt comparison failed: %v", err)
+
 		return nil, errInvalidCreds
 	}
 
@@ -72,7 +76,17 @@ func (a *Auth) LoginLocal(ctx context.Context, username, password string) (*mode
 
 	log.Println("User:", user)
 
-	return a.generateAndStoreToken(ctx, user)
+	// return a.generateAndStoreToken(ctx, user)
+	token, err := a.generateAndStoreToken(ctx, user)
+	if err != nil {
+		log.Printf("Token generation failed for %s: %v", username, err)
+
+		return nil, fmt.Errorf("failed to generate token: %w", err)
+	}
+
+	log.Printf("Login successful for %s, token: %s", username, token.AccessToken)
+
+	return token, nil
 }
 
 const (
@@ -156,8 +170,7 @@ func (a *Auth) generateAndStoreToken(ctx context.Context, user *models.User) (*m
 }
 
 func generateUserID(username string) string {
-	hash := sha256.Sum256([]byte(username + time.Now().String()))
-
+	hash := sha256.Sum256([]byte(username))
 	return base64.URLEncoding.EncodeToString(hash[:])
 }
 
diff --git a/pkg/core/server.go b/pkg/core/server.go
index cf9a7ad..2728a90 100644
--- a/pkg/core/server.go
+++ b/pkg/core/server.go
@@ -84,14 +84,16 @@ func NewServer(_ context.Context, config *Config) (*Server, error) {
 		return nil, fmt.Errorf("%w: %w", errDatabaseError, err)
 	}
 
+	// Initialize authConfig with defaults from config.Auth
 	authConfig := &models.AuthConfig{
 		JWTSecret:     os.Getenv("JWT_SECRET"),
 		JWTExpiration: 24 * time.Hour,
-		CallbackURL:   os.Getenv("AUTH_CALLBACK_URL"), // e.g., "http://localhost:8080/auth"
+		CallbackURL:   os.Getenv("AUTH_CALLBACK_URL"),
 		LocalUsers:    make(map[string]string),
+		SSOProviders:  make(map[string]models.SSOConfig),
 	}
 
-	// Override with config file values if present
+	// Populate authConfig from config.Auth if provided
 	if config.Auth != nil {
 		if config.Auth.JWTSecret != "" {
 			authConfig.JWTSecret = config.Auth.JWTSecret
@@ -99,16 +101,32 @@ func NewServer(_ context.Context, config *Config) (*Server, error) {
 		if config.Auth.JWTExpiration != 0 {
 			authConfig.JWTExpiration = config.Auth.JWTExpiration
 		}
-		if len(config.Auth.LocalUsers) > 0 {
-			authConfig.LocalUsers = config.Auth.LocalUsers
+		if config.Auth.CallbackURL != "" {
+			authConfig.CallbackURL = config.Auth.CallbackURL
 		}
-	} else {
-		// Fallback to environment variable if no auth section in config
-		if adminHash := os.Getenv("ADMIN_PASSWORD_HASH"); adminHash != "" {
-			authConfig.LocalUsers["admin"] = adminHash
+		if config.Auth.LocalUsers != nil {
+			for user, hash := range config.Auth.LocalUsers {
+				authConfig.LocalUsers[user] = hash
+			}
 		}
+		if config.Auth.SSOProviders != nil {
+			for provider, ssoConfig := range config.Auth.SSOProviders {
+				authConfig.SSOProviders[provider] = ssoConfig
+			}
+		}
+	}
+
+	// Override LocalUsers["admin"] with environment variable if set and not empty
+	if envHash := os.Getenv("ADMIN_PASSWORD_HASH"); envHash != "" {
+		authConfig.LocalUsers["admin"] = envHash
+	}
+
+	// Validate that admin user has a valid hash
+	if hash, ok := authConfig.LocalUsers["admin"]; !ok || hash == "" {
+		return nil, fmt.Errorf("no valid password hash provided for admin user")
 	}
 
+	// Validate JWTSecret
 	if authConfig.JWTSecret == "" {
 		return nil, errJWTSecretRequired
 	}
@@ -231,6 +249,10 @@ func (s *Server) GetSNMPManager() snmp.SNMPManager {
 	return s.snmpManager
 }
 
+func (s *Server) GetAuth() *auth.Auth {
+	return s.authService
+}
+
 func (s *Server) runMetricsCleanup(ctx context.Context) {
 	ticker := time.NewTicker(1 * time.Hour)
 	defer ticker.Stop()
@@ -846,10 +868,6 @@ func (s *Server) sendUnreportedNodesAlert(ctx context.Context, nodeIDs []string)
 	}
 }
 
-func (s *Server) GetAuth() *auth.Auth {
-	return s.authService
-}
-
 func LoadConfig(path string) (Config, error) {
 	data, err := os.ReadFile(path)
 	if err != nil {
@@ -867,6 +885,10 @@ func LoadConfig(path string) (Config, error) {
 			config.Security.Mode, config.Security.CertDir, config.Security.Role)
 	}
 
+	if config.Auth != nil {
+		log.Printf("Auth config: JWTSecret=%s, LocalUsers=%v", config.Auth.JWTSecret, config.Auth.LocalUsers)
+	}
+
 	return config, nil
 }
 
diff --git a/pkg/core/types.go b/pkg/core/types.go
index 78e3501..44162bd 100644
--- a/pkg/core/types.go
+++ b/pkg/core/types.go
@@ -18,7 +18,6 @@ package core
 
 import (
 	"encoding/json"
-	"fmt"
 	"sync"
 	"time"
 
@@ -53,55 +52,6 @@ type Config struct {
 	Auth           *models.AuthConfig     `json:"auth,omitempty"`
 }
 
-func (c *Config) UnmarshalJSON(data []byte) error {
-	type Alias Config
-
-	aux := &struct {
-		AlertThreshold string `json:"alert_threshold"`
-		Auth           *struct {
-			JWTSecret     string                      `json:"jwt_secret"`
-			JWTExpiration string                      `json:"jwt_expiration"`
-			LocalUsers    map[string]string           `json:"local_users"`
-			CallbackURL   string                      `json:"callback_url,omitempty"`
-			SSOProviders  map[string]models.SSOConfig `json:"sso_providers,omitempty"`
-		} `json:"auth"`
-		*Alias
-	}{
-		Alias: (*Alias)(c),
-	}
-
-	if err := json.Unmarshal(data, &aux); err != nil {
-		return err
-	}
-
-	// Parse the alert threshold
-	if aux.AlertThreshold != "" {
-		duration, err := time.ParseDuration(aux.AlertThreshold)
-		if err != nil {
-			return fmt.Errorf("invalid alert threshold format: %w", err)
-		}
-		c.AlertThreshold = duration
-	}
-
-	// Parse the auth section
-	if aux.Auth != nil {
-		c.Auth = &models.AuthConfig{
-			JWTSecret:    aux.Auth.JWTSecret,
-			LocalUsers:   aux.Auth.LocalUsers,
-			CallbackURL:  aux.Auth.CallbackURL,
-			SSOProviders: aux.Auth.SSOProviders,
-		}
-		if aux.Auth.JWTExpiration != "" {
-			duration, err := time.ParseDuration(aux.Auth.JWTExpiration)
-			if err != nil {
-				return fmt.Errorf("invalid jwt_expiration format: %w", err)
-			}
-			c.Auth.JWTExpiration = duration
-		}
-	}
-
-	return nil
-}
 type Server struct {
 	proto.UnimplementedPollerServiceServer
 	mu             sync.RWMutex
@@ -135,3 +85,27 @@ type ServiceStatus struct {
 	Details     string
 	Timestamp   time.Time
 }
+
+func (c *Config) UnmarshalJSON(data []byte) error {
+	type Alias Config
+	aux := struct {
+		AlertThreshold string `json:"alert_threshold"`
+		*Alias
+	}{
+		Alias: (*Alias)(c),
+	}
+
+	if err := json.Unmarshal(data, &aux); err != nil {
+		return err
+	}
+
+	if aux.AlertThreshold != "" {
+		duration, err := time.ParseDuration(aux.AlertThreshold)
+		if err != nil {
+			return err
+		}
+		c.AlertThreshold = duration
+	}
+
+	return nil
+}
diff --git a/pkg/db/db.go b/pkg/db/db.go
index eb7e711..a65ea76 100644
--- a/pkg/db/db.go
+++ b/pkg/db/db.go
@@ -101,7 +101,7 @@ const (
         port INTEGER NOT NULL,
         available INTEGER NOT NULL,
         FOREIGN KEY (sweep_id) REFERENCES sweep_results(id) ON DELETE CASCADE
-    );
+    );	
 
 	-- Timeseries metrics table
     CREATE TABLE IF NOT EXISTS timeseries_metrics (
@@ -115,7 +115,7 @@ const (
         FOREIGN KEY (node_id) REFERENCES nodes(node_id) ON DELETE CASCADE
     );
 
-   	-- Users table for authentication
+	-- Users table for authentication
     CREATE TABLE IF NOT EXISTS users (
         id TEXT PRIMARY KEY,
         email TEXT NOT NULL UNIQUE,
@@ -126,29 +126,29 @@ const (
     );
 
 	-- Indexes for better query performance
-	CREATE INDEX IF NOT EXISTS idx_sweep_results_poller_time
+	CREATE INDEX IF NOT EXISTS idx_sweep_results_poller_time 
         ON sweep_results(poller_id, timestamp);
-    CREATE INDEX IF NOT EXISTS idx_port_results_sweep
+    CREATE INDEX IF NOT EXISTS idx_port_results_sweep 
         ON port_results(sweep_id);
-	CREATE INDEX IF NOT EXISTS idx_node_history_node_time
+	CREATE INDEX IF NOT EXISTS idx_node_history_node_time 
 		ON node_history(node_id, timestamp);
-	CREATE INDEX IF NOT EXISTS idx_service_status_node_time
+	CREATE INDEX IF NOT EXISTS idx_service_status_node_time 
 		ON service_status(node_id, timestamp);
-	CREATE INDEX IF NOT EXISTS idx_service_status_type
+	CREATE INDEX IF NOT EXISTS idx_service_status_type 
 		ON service_status(service_type);
-	CREATE INDEX IF NOT EXISTS idx_service_history_status_time
+	CREATE INDEX IF NOT EXISTS idx_service_history_status_time 
 		ON service_history(service_status_id, timestamp);
 
 	 -- Indexes for timeseries data
-    CREATE INDEX IF NOT EXISTS idx_metrics_node_name
+    CREATE INDEX IF NOT EXISTS idx_metrics_node_name 
 		ON timeseries_metrics(node_id, metric_name);
-    CREATE INDEX IF NOT EXISTS idx_metrics_type
+    CREATE INDEX IF NOT EXISTS idx_metrics_type 
 		ON timeseries_metrics(metric_type);
-    CREATE INDEX IF NOT EXISTS idx_metrics_timestamp
+    CREATE INDEX IF NOT EXISTS idx_metrics_timestamp 
 		ON timeseries_metrics(timestamp);
 
 	-- Index for users table
-    CREATE INDEX IF NOT EXISTS idx_users_email
+    CREATE INDEX IF NOT EXISTS idx_users_email 
         ON users(email);
 
 	-- Enable WAL mode for better concurrent access
@@ -251,7 +251,7 @@ func (db *DB) UpdateNodeStatus(status *NodeStatus) error {
 // Rewrite the above function using our interface.
 func (*DB) updateExistingNode(tx Transaction, status *NodeStatus) error {
 	result, err := tx.Exec(`
-		UPDATE nodes
+		UPDATE nodes 
 		SET last_seen = ?,
 			is_healthy = ?
 		WHERE node_id = ?
@@ -309,7 +309,7 @@ func rollbackOnError(tx Transaction, err error) {
 // UpdateServiceStatus updates a service's status.
 func (db *DB) UpdateServiceStatus(status *ServiceStatus) error {
 	const insertSQL = `
-		INSERT INTO service_status
+		INSERT INTO service_status 
 			(node_id, service_name, service_type, available, details, timestamp)
 		VALUES (?, ?, ?, ?, ?, ?)
 	`
@@ -413,10 +413,10 @@ func (db *DB) GetNodeHistoryPoints(nodeID string, limit int) ([]NodeHistoryPoint
 // GetNodeHistory retrieves the history for a node.
 func (db *DB) GetNodeHistory(nodeID string) ([]NodeStatus, error) {
 	const querySQL = `
-        SELECT timestamp, is_healthy
-        FROM node_history
-        WHERE node_id = ?
-        ORDER BY timestamp DESC
+        SELECT timestamp, is_healthy 
+        FROM node_history 
+        WHERE node_id = ? 
+        ORDER BY timestamp DESC 
         LIMIT ?
     `
 
@@ -444,9 +444,9 @@ func (db *DB) GetNodeHistory(nodeID string) ([]NodeStatus, error) {
 
 func (db *DB) IsNodeOffline(nodeID string, threshold time.Duration) (bool, error) {
 	const querySQL = `
-        SELECT COUNT(*)
-        FROM nodes n
-        WHERE n.node_id = ?
+        SELECT COUNT(*) 
+        FROM nodes n 
+        WHERE n.node_id = ? 
         AND n.last_seen < datetime('now', ?)
     `
 
diff --git a/pkg/http/middleware.go b/pkg/http/middleware.go
index bbfc6c6..603ea4d 100644
--- a/pkg/http/middleware.go
+++ b/pkg/http/middleware.go
@@ -1,26 +1,41 @@
-// Package http pkg/http/middleware.go
-package http
+/*
+ * Copyright 2025 Carver Automation Corporation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Package httpx provides HTTP utilities for the application
+package httpx
 
 import (
 	"log"
 	"net/http"
+	"os"
 )
 
+// CommonMiddleware returns an http.Handler that sets up typical
+// headers (CORS, etc.) before calling the next handler.
 func CommonMiddleware(next http.Handler) http.Handler {
-	log.Println("CommonMiddleware")
-
 	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-		// log request
-		log.Printf("%s %s %s", r.RemoteAddr, r.Method, r.URL.Path)
-
-		w.Header().Set("Access-Control-Allow-Origin", "*") // For testing; restrict in prod if needed
-		w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
-		w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-API-Key")
-		w.Header().Set("Access-Control-Max-Age", "3600")           // Cache preflight for 1 hour
-		w.Header().Set("Access-Control-Allow-Credentials", "true") // For cookies
+		w.Header().Set("Access-Control-Allow-Origin", "*") // For prod: "http://localhost:3000"
+		w.Header().Set("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE,OPTIONS")
+		w.Header().Set("Access-Control-Allow-Headers", "Content-Type,Authorization,X-API-Key")
+		w.Header().Set("Access-Control-Max-Age", "3600") // Cache preflight for 1 hour
 
 		if r.Method == http.MethodOptions {
+			// Preflight request response
 			w.WriteHeader(http.StatusOK)
+
 			return
 		}
 
@@ -28,15 +43,25 @@ func CommonMiddleware(next http.Handler) http.Handler {
 	})
 }
 
-func APIKeyMiddleware(apiKey string) func(next http.Handler) http.Handler {
+// APIKeyMiddleware creates middleware that validates API keys.
+// It can accept an API key directly or read from the environment.
+func APIKeyMiddleware(apiKeyParam string) func(next http.Handler) http.Handler {
+	apiKey := apiKeyParam
+	if apiKey == "" {
+		apiKey = os.Getenv("API_KEY")
+	}
 	return func(next http.Handler) http.Handler {
 		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
 			requestKey := r.Header.Get("X-API-Key")
 			if requestKey == "" {
 				requestKey = r.URL.Query().Get("api_key")
 			}
-			log.Printf("API-KEY received: %s", requestKey)
-			if requestKey == "" || (apiKey != "" && requestKey != apiKey) {
+			log.Println("API-KEY:", requestKey)
+			log.Println("All headers:")
+			for key, values := range r.Header {
+				log.Printf("%s: %v", key, values)
+			}
+			if requestKey == "" || requestKey != apiKey {
 				log.Printf("Unauthorized API access attempt: %s %s", r.Method, r.URL.Path)
 				http.Error(w, "Unauthorized", http.StatusUnauthorized)
 				return
diff --git a/pkg/models/auth.go b/pkg/models/auth.go
index 2efd122..2c79675 100644
--- a/pkg/models/auth.go
+++ b/pkg/models/auth.go
@@ -1,6 +1,7 @@
 package models
 
 import (
+	"encoding/json"
 	"time"
 )
 
@@ -20,11 +21,11 @@ type Token struct {
 }
 
 type AuthConfig struct {
-	JWTSecret     string 				`json:"jwt_secret"`
-	JWTExpiration time.Duration 		`json:"jwt_expiration"`
-	CallbackURL   string 				`json:"callback_url"`
-	LocalUsers    map[string]string 	`json:"local_users"`
-	SSOProviders  map[string]SSOConfig 	`json:"sso_providers"`
+	JWTSecret     string               `json:"jwt_secret""`
+	JWTExpiration time.Duration        `json:"jwt_expiration"`
+	CallbackURL   string               `json:"callback_url"`
+	LocalUsers    map[string]string    `json:"local_users"`
+	SSOProviders  map[string]SSOConfig `json:"sso_providers"`
 }
 
 type SSOConfig struct {
@@ -32,3 +33,31 @@ type SSOConfig struct {
 	ClientSecret string
 	Scopes       []string
 }
+
+// UnmarshalJSON implements the json.Unmarshaler interface for AuthConfig.
+func (a *AuthConfig) UnmarshalJSON(data []byte) error {
+	// Define an auxiliary struct to handle the string parsing
+	type Alias AuthConfig
+	aux := struct {
+		JWTExpiration string `json:"jwt_expiration"` // Temporarily store as string
+		*Alias
+	}{
+		Alias: (*Alias)(a),
+	}
+
+	// Unmarshal into the auxiliary struct
+	if err := json.Unmarshal(data, &aux); err != nil {
+		return err
+	}
+
+	// Parse the JWTExpiration string into a time.Duration
+	if aux.JWTExpiration != "" {
+		duration, err := time.ParseDuration(aux.JWTExpiration)
+		if err != nil {
+			return err // This will propagate the error up to LoadConfig
+		}
+		a.JWTExpiration = duration
+	}
+
+	return nil
+}
diff --git a/scripts/buildAll.sh b/scripts/buildAll.sh
index d5676fe..86d3006 100755
--- a/scripts/buildAll.sh
+++ b/scripts/buildAll.sh
@@ -15,7 +15,7 @@
 # limitations under the License.
 
 # buildAll.sh - Build all packages for ServiceRadar
-VERSION=${VERSION:-1.0.27}
+VERSION=${VERSION:-1.0.26}
 
 ./scripts/setup-deb-agent.sh
 ./scripts/setup-deb-poller.sh
@@ -23,14 +23,7 @@ VERSION=${VERSION:-1.0.27}
 ./scripts/setup-deb-dusk-checker.sh
 ./scripts/setup-deb-snmp-checker.sh
 
-# demo
 scp ./release-artifacts/serviceradar-poller_${VERSION}.deb duskadmin@192.168.2.22:~/
 scp ./release-artifacts/serviceradar-agent_${VERSION}.deb duskadmin@192.168.2.22:~/
 scp ./release-artifacts/serviceradar-dusk-checker_${VERSION}.deb duskadmin@192.168.2.22:~/
 scp ./release-artifacts/serviceradar-snmp-checker_${VERSION}.deb duskadmin@192.168.2.22:~/
-
-# demo-staging
-scp ./release-artifacts/serviceradar-poller_${VERSION}.deb 192.168.2.23:~/
-scp ./release-artifacts/serviceradar-agent_${VERSION}.deb 192.168.2.23:~/
-scp ./release-artifacts/serviceradar-dusk-checker_${VERSION}.deb 192.168.2.23:~/
-scp ./release-artifacts/serviceradar-snmp-checker_${VERSION}.deb 192.168.2.23:~/
diff --git a/web/next.config.ts b/web/next.config.ts
index 40f0c28..286dd81 100644
--- a/web/next.config.ts
+++ b/web/next.config.ts
@@ -17,30 +17,29 @@
 import type { NextConfig } from "next";
 
 const nextConfig: NextConfig = {
-  reactStrictMode: true,
-  output: "standalone",
-  async rewrites() {
-    const backendUrl =
-      process.env.NEXT_PUBLIC_API_URL || "http://localhost:8090";
-    return [
-      {
-        source: "/auth/:path*",
-        destination: `${backendUrl}/auth/:path*`,
-      },
-      {
-        source: "/api/:path*",
-        destination: `${backendUrl}/api/:path*`,
-      },
-    ];
-  },
-  env: {
-    NEXT_PUBLIC_API_URL:
-      process.env.NEXT_PUBLIC_API_URL || "http://localhost:8090",
-  },
-  serverRuntimeConfig: {
-    // Will only be available on the server side
-    apiKey: process.env.API_KEY || "",
-  },
+    reactStrictMode: true,
+    output: "standalone",
+    async rewrites() {
+        const backendUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8090';
+        console.log("Rewriting to backend URL:", backendUrl);
+        return [
+            {
+                source: '/api/:path*',
+                destination: `${backendUrl}/api/:path*`,
+            },
+            {
+                source: '/auth/:path*',
+                destination: `${backendUrl}/auth/:path*`,
+            },
+        ];
+    },
+    env: {
+        NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8090',
+        API_KEY: process.env.API_KEY || '',
+    },
+    serverRuntimeConfig: {
+        apiKey: process.env.API_KEY || '',
+    }
 };
 
-export default nextConfig;
+export default nextConfig;
\ No newline at end of file
diff --git a/web/src/app/layout.tsx b/web/src/app/layout.tsx
index 00c5ee0..afb1d7b 100644
--- a/web/src/app/layout.tsx
+++ b/web/src/app/layout.tsx
@@ -19,6 +19,7 @@ import './globals.css';
 import { Inter } from 'next/font/google';
 import { Providers } from './providers';
 import { AuthProvider } from '@/components/AuthProvider';
+import { PublicEnvScript } from 'next-runtime-env';
 
 const inter = Inter({ subsets: ['latin'] });
 
@@ -36,6 +37,7 @@ export default function RootLayout({ children }: { children: React.ReactNode })
             <link rel="shortcut icon" href="/favicons/favicon.ico" />
             <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png" />
             <link rel="manifest" href="/favicons/site.webmanifest" />
+            <PublicEnvScript />
         </head>
         <body className={inter.className}>
         <AuthProvider>
diff --git a/web/src/app/login/page.tsx b/web/src/app/login/page.tsx
index ab2fe4c..98a8940 100644
--- a/web/src/app/login/page.tsx
+++ b/web/src/app/login/page.tsx
@@ -19,20 +19,27 @@
 
 import { useState } from 'react';
 import { useAuth } from '@/components/AuthProvider';
+import { useRouter } from 'next/navigation';
 
 export default function LoginPage() {
-    const { login } = useAuth(); // Removed isAuthEnabled
+    const { login, isAuthEnabled } = useAuth();
     const [username, setUsername] = useState('');
     const [password, setPassword] = useState('');
     const [error, setError] = useState('');
+    const router = useRouter();
+
+    if (!isAuthEnabled) {
+        router.push('/');
+        return null;
+    }
 
     const handleSubmit = async (e: React.FormEvent) => {
         e.preventDefault();
         setError('');
         try {
             await login(username, password);
-            // No need to redirect here; login() already handles it
         } catch (err) {
+            // TODO: remove this before production
             console.log(err);
             setError('Login failed. Please check your credentials.');
         }
diff --git a/web/src/components/AuthProvider.tsx b/web/src/components/AuthProvider.tsx
index a43f8d1..3b76b7e 100644
--- a/web/src/components/AuthProvider.tsx
+++ b/web/src/components/AuthProvider.tsx
@@ -1,242 +1,150 @@
-/*
- * Copyright 2025 Carver Automation Corporation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
 // src/components/AuthProvider.tsx
-"use client";
+'use client';
 
-import React, {
-  createContext,
-  useContext,
-  useState,
-  useEffect,
-  useCallback,
-} from "react";
-import { useRouter } from "next/navigation";
+import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';
+import { useRouter } from 'next/navigation';
+import { useAuthFlag } from '@/hooks/useAuthFlag';
 
 interface AuthContextType {
-  token: string | null;
-  user: { id: string; email: string; provider: string } | null;
-  login: (username: string, password: string) => Promise<void>;
-  logout: () => void;
-  refreshToken: () => Promise<void>;
-  isAuthenticated: boolean;
-  isAuthEnabled: boolean;
+    token: string | null;
+    user: { id: string; email: string; provider: string } | null;
+    login: (username: string, password: string) => Promise<void>;
+    logout: () => void;
+    refreshToken: () => Promise<void>;
+    isAuthenticated: boolean;
+    isAuthEnabled: boolean;
 }
 
 const AuthContext = createContext<AuthContextType | undefined>(undefined);
 
-export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({
-  children,
-}) => {
-  const [token, setToken] = useState<string | null>(null);
-  const [user, setUser] = useState<{
-    id: string;
-    email: string;
-    provider: string;
-  } | null>(null);
-  const [isAuthenticated, setIsAuthenticated] = useState(false);
-  const [isAuthEnabled, setIsAuthEnabled] = useState(true);
-  const router = useRouter();
-
-  // Check if auth is enabled (useful for UI adjustments)
-  useEffect(() => {
-    fetch("/api/auth/status")
-      .then((res) => res.json())
-      .then((data) => {
-        setIsAuthEnabled(data.authEnabled);
-        console.log("Auth enabled status:", data.authEnabled);
-      })
-      .catch((err) => {
-        console.error("Failed to fetch auth status:", err);
-      });
-  }, []);
-
-  const logout = useCallback(() => {
-    document.cookie = "accessToken=; Max-Age=0; path=/";
-    document.cookie = "refreshToken=; Max-Age=0; path=/";
-    setToken(null);
-    setUser(null);
-    setIsAuthenticated(false);
-    router.push("/login");
-  }, [router]);
-
-  const refreshToken = useCallback(async () => {
-    const refreshTokenValue = document.cookie
-      .split("; ")
-      .find((row) => row.startsWith("refreshToken="))
-      ?.split("=")[1];
-
-    if (!refreshTokenValue) {
-      logout();
-      return;
-    }
-
-    try {
-      // Use the API route for refresh - it will handle adding the API key
-      const response = await fetch("/api/auth/refresh", {
-        method: "POST",
-        headers: { "Content-Type": "application/json" },
-        body: JSON.stringify({ refresh_token: refreshTokenValue }),
-      });
-
-      if (!response.ok) {
-        throw new Error("Token refresh failed");
-      }
-
-      const data = await response.json();
-
-      // Handle different field naming between your API and frontend
-      const accessToken = data.access_token || data.accessToken;
-      const refreshToken = data.refresh_token || data.refreshToken;
-
-      document.cookie = `accessToken=${accessToken}; path=/; max-age=${24 * 60 * 60}`;
-      document.cookie = `refreshToken=${refreshToken}; path=/; max-age=${7 * 24 * 60 * 60}`;
-
-      setToken(accessToken);
-      const verifiedUser = await verifyToken(accessToken);
-      setUser(verifiedUser);
-      setIsAuthenticated(true);
-    } catch (error) {
-      console.error("Error refreshing token:", error);
-      logout();
-    }
-  }, [logout]);
-
-  const verifyToken = async (token: string) => {
-    try {
-      // Use server-side endpoint for token verification
-      const response = await fetch("/api/auth/verify", {
-        headers: { Authorization: `Bearer ${token}` },
-      });
-
-      if (!response.ok) {
-        throw new Error("Token verification failed");
-      }
-
-      // Parse JWT payload
-      const base64Url = token.split(".")[1];
-      const base64 = base64Url.replace(/-/g, "+").replace(/_/g, "/");
-      const jsonPayload = decodeURIComponent(
-        atob(base64)
-          .split("")
-          .map((c) => "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2))
-          .join(""),
-      );
-
-      return JSON.parse(jsonPayload);
-    } catch (error) {
-      console.error("Token verification error:", error);
-      throw error;
-    }
-  };
-
-  useEffect(() => {
-    if (!isAuthEnabled) {
-      return; // Skip token verification if auth is disabled
-    }
-
-    const storedToken = document.cookie
-      .split("; ")
-      .find((row) => row.startsWith("accessToken="))
-      ?.split("=")[1];
-
-    if (storedToken) {
-      verifyToken(storedToken)
-        .then((verifiedUser) => {
-          setToken(storedToken);
-          setUser(verifiedUser);
-          setIsAuthenticated(true);
-          refreshToken().catch(() => logout());
-        })
-        .catch(() => {
-          document.cookie = "accessToken=; Max-Age=0; path=/";
-          document.cookie = "refreshToken=; Max-Age=0; path=/";
-          setIsAuthenticated(false);
-          router.push("/login");
+export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
+    const [token, setToken] = useState<string | null>(null);
+    const [user, setUser] = useState<{ id: string; email: string; provider: string } | null>(null);
+    const [isAuthenticated, setIsAuthenticated] = useState(false);
+    const { isAuthEnabled, error: authFlagError } = useAuthFlag();
+    const router = useRouter();
+
+    const logout = useCallback(() => {
+        localStorage.removeItem('accessToken');
+        localStorage.removeItem('refreshToken');
+        setToken(null);
+        setUser(null);
+        setIsAuthenticated(false);
+        router.push('/login');
+    }, [router]);
+
+    const refreshToken = useCallback(async () => {
+        const refreshTokenValue = localStorage.getItem('refreshToken');
+        if (!refreshTokenValue) {
+            logout();
+            return;
+        }
+
+        const response = await fetch('/auth/refresh', {
+            method: 'POST',
+            headers: { 'Content-Type': 'application/json' },
+            body: JSON.stringify({ refreshToken: refreshTokenValue }),
         });
-    }
-  }, [router, refreshToken, logout, isAuthEnabled]);
-
-  const login = async (username: string, password: string) => {
-    try {
-      console.log(`Attempting login for user: ${username}`);
-
-      // Use the Next.js API route that will add the API key
-      const response = await fetch("/api/auth/login", {
-        method: "POST",
-        headers: { "Content-Type": "application/json" },
-        body: JSON.stringify({ username, password }),
-      });
 
-      if (!response.ok) {
-        const errorText = await response.text();
-        console.error("Login error response:", errorText);
-        throw new Error(`Login failed: ${errorText}`);
-      }
+        if (!response.ok) {
+            logout();
+            throw new Error('Token refresh failed');
+        }
 
-      const data = await response.json();
-
-      // Handle different field naming between your API and frontend
-      const accessToken = data.access_token || data.accessToken;
-      const refreshToken = data.refresh_token || data.refreshToken;
-
-      if (!accessToken || !refreshToken) {
-        console.error("Invalid token format received:", data);
-        throw new Error("Invalid token format received from server");
-      }
+        const data = await response.json();
+        localStorage.setItem('accessToken', data.accessToken);
+        localStorage.setItem('refreshToken', data.refreshToken);
+        setToken(data.accessToken);
+        const verifiedUser = await verifyToken(data.accessToken);
+        setUser(verifiedUser);
+        setIsAuthenticated(true);
+    }, [logout]);
 
-      document.cookie = `accessToken=${accessToken}; path=/; max-age=${24 * 60 * 60}`;
-      document.cookie = `refreshToken=${refreshToken}; path=/; max-age=${7 * 24 * 60 * 60}`;
+    const verifyToken = async (token: string) => {
+        const response = await fetch('/api/status', {
+            headers: { Authorization: `Bearer ${token}` },
+        });
 
-      setToken(accessToken);
+        if (!response.ok) throw new Error('Token verification failed');
+
+        const base64Url = token.split('.')[1];
+        const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
+        const jsonPayload = decodeURIComponent(
+            atob(base64)
+                .split('')
+                .map((c) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))
+                .join('')
+        );
+        return JSON.parse(jsonPayload);
+    };
+
+    useEffect(() => {
+        if (isAuthEnabled === null) return;
+
+        if (!isAuthEnabled) {
+            setIsAuthenticated(true);
+            return;
+        }
+
+        const storedToken = localStorage.getItem('accessToken');
+        if (storedToken) {
+            verifyToken(storedToken)
+                .then((verifiedUser) => {
+                    setToken(storedToken);
+                    setUser(verifiedUser);
+                    setIsAuthenticated(true);
+                    refreshToken().catch(() => logout());
+                })
+                .catch(() => {
+                    localStorage.removeItem('accessToken');
+                    localStorage.removeItem('refreshToken');
+                    setIsAuthenticated(false);
+                    router.push('/login');
+                });
+        }
+    }, [router, refreshToken, logout, isAuthEnabled]);
+
+    const login = async (username: string, password: string) => {
+        try {
+            const response = await fetch('/auth/login', {
+                method: 'POST',
+                headers: { 'Content-Type': 'application/json' },
+                body: JSON.stringify({ username, password }),
+            });
+
+            if (!response.ok) throw new Error('Login failed');
+
+            const data = await response.json();
+            localStorage.setItem('accessToken', data.accessToken);
+            localStorage.setItem('refreshToken', data.refreshToken);
+            setToken(data.accessToken);
+            const verifiedUser = await verifyToken(data.accessToken);
+            setUser(verifiedUser);
+            setIsAuthenticated(true);
+            router.push('/nodes');
+        } catch (error) {
+            console.error('Login error:', error);
+            throw error;
+        }
+    };
+
+    if (authFlagError) {
+        return <div>Error loading authentication status: {authFlagError}</div>;
+    }
 
-      try {
-        const verifiedUser = await verifyToken(accessToken);
-        setUser(verifiedUser);
-        setIsAuthenticated(true);
-        router.push("/nodes");
-      } catch (verifyError) {
-        console.error("Token verification error:", verifyError);
-        throw new Error("Invalid token received");
-      }
-    } catch (error) {
-      console.error("Login error:", error);
-      throw error;
+    if (isAuthEnabled === null) {
+        return <div>Loading authentication status...</div>;
     }
-  };
-
-  return (
-    <AuthContext.Provider
-      value={{
-        token,
-        user,
-        login,
-        logout,
-        refreshToken,
-        isAuthenticated,
-        isAuthEnabled,
-      }}
-    >
-      {children}
-    </AuthContext.Provider>
-  );
+
+    return (
+        <AuthContext.Provider value={{ token, user, login, logout, refreshToken, isAuthenticated, isAuthEnabled }}>
+            {children}
+        </AuthContext.Provider>
+    );
 };
 
 export const useAuth = () => {
-  const context = useContext(AuthContext);
-  if (!context) throw new Error("useAuth must be used within an AuthProvider");
-  return context;
-};
+    const context = useContext(AuthContext);
+    if (!context) throw new Error('useAuth must be used within an AuthProvider');
+    return context;
+};
\ No newline at end of file
diff --git a/web/src/components/DashboardWrapper.tsx b/web/src/components/DashboardWrapper.tsx
index e379848..7487bb0 100644
--- a/web/src/components/DashboardWrapper.tsx
+++ b/web/src/components/DashboardWrapper.tsx
@@ -24,20 +24,19 @@ import { fetchWithCache } from '@/lib/client-api';
 import { SystemStatus } from '@/types';
 
 export default function DashboardWrapper({ initialData }: { initialData: SystemStatus | null }) {
-    const { token } = useAuth(); // Removed isAuthEnabled
+    const { token, isAuthEnabled } = useAuth();
     const [data, setData] = useState<SystemStatus | null>(initialData);
 
     useEffect(() => {
-        if (token) {
-            // Refetch with token if available
+        if (isAuthEnabled && token) {
+            // Refetch with token if auth is enabled
             fetchWithCache('/status', { headers: { Authorization: `Bearer ${token}` } })
                 .then(updatedData => {
                     if (updatedData) setData(updatedData);
                 })
                 .catch(err => console.error('Error refetching with token:', err));
         }
-        // If no token, rely on initialData or API key from middleware
-    }, [token]);
+    }, [token, isAuthEnabled]);
 
     return <Dashboard initialData={data} />;
 }
\ No newline at end of file
diff --git a/web/src/lib/api.ts b/web/src/lib/api.ts
index 79aa817..af42c80 100644
--- a/web/src/lib/api.ts
+++ b/web/src/lib/api.ts
@@ -14,29 +14,28 @@
  * limitations under the License.
  */
 
-// web/src/lib/api.ts - server-side utilities with TypeScript
+// src/lib/api.ts - server-side utilities with TypeScript
 import { SystemStatus, Node } from '@/types';
 
 export async function fetchFromAPI<T>(endpoint: string, token?: string): Promise<T | null> {
-    const baseUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8090';
-    const normalizedEndpoint = endpoint.replace(/^\/+/, ''); // Remove leading slashes
-    const apiUrl = normalizedEndpoint.startsWith('auth/') || normalizedEndpoint.startsWith('api/')
-        ? `${baseUrl}/${normalizedEndpoint}`
-        : `${baseUrl}/api/${normalizedEndpoint}`;
+    const backendUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8090';
+    // Normalize endpoint by removing leading slashes
+    const normalizedEndpoint = endpoint.replace(/^\/+/, '');
+    const apiUrl = normalizedEndpoint.startsWith('api/') || normalizedEndpoint.startsWith('auth/')
+        ? `${backendUrl}/${normalizedEndpoint}`
+        : `${backendUrl}/api/${normalizedEndpoint}`;
 
     const headers: HeadersInit = { 'Content-Type': 'application/json' };
     if (token) headers['Authorization'] = `Bearer ${token}`;
 
     try {
-        console.log(`Fetching from: ${apiUrl}`);
+        console.log(`Fetching from: ${apiUrl}`); // Debug log
         const response = await fetch(apiUrl, {
             headers,
             cache: 'no-store',
-            credentials: 'include', // Include cookies for auth
         });
 
         if (!response.ok) {
-            console.error(`API request failed: ${response.status} - ${await response.text()}`);
             throw new Error(`API request failed: ${response.status}`);
         }
 
@@ -47,5 +46,4 @@ export async function fetchFromAPI<T>(endpoint: string, token?: string): Promise
     }
 }
 
-// Union type for cacheable data (exported for client-api.ts)
 export type CacheableData = SystemStatus | Node[];
\ No newline at end of file
diff --git a/web/src/middleware.ts b/web/src/middleware.ts
index bd7291c..c1530bd 100644
--- a/web/src/middleware.ts
+++ b/web/src/middleware.ts
@@ -1,78 +1,38 @@
-// web/src/middleware.ts
-import { NextResponse } from "next/server";
-import type { NextRequest } from "next/server";
-import { env } from "next-runtime-env";
+import { NextResponse } from 'next/server';
+import type { NextRequest } from 'next/server';
+import { env } from 'next-runtime-env';
 
-export async function middleware(request: NextRequest) {
-  const apiKey = env("API_KEY") || "";
-  const isAuthEnabled = env("AUTH_ENABLED") === "true";
-
-  console.log(
-    "Middleware triggered for:",
-    request.method,
-    request.nextUrl.pathname,
-  );
-  console.log("AUTH_ENABLED:", isAuthEnabled, "API_KEY:", apiKey);
-
-  // Handle OPTIONS preflight
-  if (request.method === "OPTIONS") {
-    return new NextResponse(null, {
-      status: 200,
-      headers: {
-        "Access-Control-Allow-Origin": "*",
-        "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
-        "Access-Control-Allow-Headers":
-          "Content-Type, Authorization, X-API-Key",
-      },
-    });
-  }
+// The API key should be accessible through server runtime config
+const API_KEY = env('API_KEY') || '';
 
-  // Public paths and static assets
-  const publicPaths = ["/login", "/auth", "/serviceRadar.svg", "/favicons"];
-  if (publicPaths.some((path) => request.nextUrl.pathname.startsWith(path))) {
-    const requestHeaders = new Headers(request.headers);
-    if (apiKey && !isAuthEnabled) {
-      requestHeaders.set("X-API-Key", apiKey);
+export async function middleware(request: NextRequest) {
+    console.log('API_KEY:', API_KEY)
+    console.log("Middleware triggered for:", request.method, request.nextUrl.pathname);
+
+    // Handle OPTIONS preflight requests
+    if (request.method === 'OPTIONS') {
+        return new NextResponse(null, {
+            status: 200,
+            headers: {
+                'Access-Control-Allow-Origin': '*',
+                'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS',
+                'Access-Control-Allow-Headers': 'Content-Type,Authorization,X-API-Key',
+            },
+        });
     }
-    return NextResponse.next({ request: { headers: requestHeaders } });
-  }
-
-  const isPublicPath =
-    request.nextUrl.pathname.startsWith("/api/") ||
-    request.nextUrl.pathname.startsWith("/auth/") ||
-    publicPaths.some((path) => request.nextUrl.pathname.startsWith(path));
 
-  if (isPublicPath) {
+    // Clone and modify headers - ALWAYS add API key
     const requestHeaders = new Headers(request.headers);
-    if (apiKey) {
-      requestHeaders.set("X-API-Key", apiKey);
-    }
-    return NextResponse.next({ request: { headers: requestHeaders } });
-  }
-
-  const requestHeaders = new Headers(request.headers);
-  const token =
-    request.cookies.get("accessToken")?.value ||
-    request.headers.get("Authorization")?.replace("Bearer ", "");
-
-  if (isAuthEnabled) {
-    if (!token) {
-      console.log("No token found, redirecting to /login");
-      return NextResponse.redirect(new URL("/login", request.url));
-    }
-    requestHeaders.set("Authorization", `Bearer ${token}`);
-  } else if (apiKey) {
-    requestHeaders.set("X-API-Key", apiKey);
-  }
-
-  console.log("Headers being sent to backend:");
-  requestHeaders.forEach((value, key) => console.log(`${key}: ${value}`));
+    requestHeaders.set('X-API-Key', API_KEY);
 
-  return NextResponse.next({
-    request: { headers: requestHeaders },
-  });
+    console.log("Headers being sent to backend:");
+    requestHeaders.forEach((value, key) => console.log(`${key}: ${value}`));
+    return NextResponse.next({
+        request: { headers: requestHeaders },
+    });
 }
 
+// Match all routes
 export const config = {
-  matcher: ["/((?!_next/static|_next/image).*)"], // Exclude _next/static and _next/image
-};
+    matcher: ['/((?!_next/static|_next/image|favicon.ico).*)'],
+};
\ No newline at end of file
