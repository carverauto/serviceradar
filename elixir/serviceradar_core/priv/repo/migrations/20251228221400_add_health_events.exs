defmodule ServiceRadar.Repo.Migrations.AddHealthEvents do
  @moduledoc """
  Updates resources based on their most recent snapshots.

  This file was autogenerated with `mix ash_postgres.generate_migrations`
  """

  use Ecto.Migration

  def up do
    # Drop tables if they exist from previous partial migration
    drop_if_exists table(:tenant_cas)

    create table(:tenant_cas, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true

      add :tenant_id,
          references(:tenants,
            column: :id,
            name: "tenant_cas_tenant_id_fkey",
            type: :uuid,
            prefix: "public"
          ), null: false

      add :certificate_pem, :text, null: false
      add :serial_number, :text, null: false
      add :next_child_serial, :bigint, default: 1
      add :subject_cn, :text, null: false
      add :not_before, :utc_datetime, null: false
      add :not_after, :utc_datetime, null: false
      add :status, :text, null: false, default: "active"
      add :revoked_at, :utc_datetime
      add :revocation_reason, :text

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :encrypted_private_key_pem, :binary, null: false
    end

    drop_if_exists unique_index(:tenant_cas, [:tenant_id, :status], name: "tenant_cas_unique_active_tenant_ca_index")
    create unique_index(:tenant_cas, [:tenant_id, :status],
             name: "tenant_cas_unique_active_tenant_ca_index",
             where: "(status = 'active')"
           )

    alter table(:pollers) do
      modify :status, :text, null: false, default: "inactive"
    end

    # Drop existing poll_jobs table if it exists (from previous partial migration)
    drop_if_exists table(:poll_jobs)

    create table(:poll_jobs, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true

      add :schedule_id,
          references(:polling_schedules,
            column: :id,
            name: "poll_jobs_schedule_id_fkey",
            type: :uuid,
            prefix: "public"
          ), null: false

      add :schedule_name, :text
      add :check_count, :bigint, default: 0
      add :check_ids, {:array, :uuid}, default: []
      add :poller_id, :text
      add :agent_id, :text
      add :priority, :bigint, default: 0
      add :timeout_seconds, :bigint, default: 60
      add :status, :text, null: false, default: "pending"
      add :dispatched_at, :utc_datetime
      add :started_at, :utc_datetime
      add :completed_at, :utc_datetime
      add :duration_ms, :bigint
      add :success_count, :bigint, default: 0
      add :failure_count, :bigint, default: 0
      add :results, {:array, :map}, default: []
      add :error_message, :text
      add :error_code, :text
      add :retry_count, :bigint, default: 0
      add :max_retries, :bigint, default: 3
      add :metadata, :map, default: %{}
      add :tenant_id, :uuid, null: false

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    drop_if_exists unique_index(:poll_jobs, [:tenant_id, :id], name: "poll_jobs_unique_job_index")
    create unique_index(:poll_jobs, [:tenant_id, :id], name: "poll_jobs_unique_job_index")

    drop_if_exists table(:ng_job_schedules)

    create table(:ng_job_schedules, primary_key: false) do
      add :id, :bigserial, null: false, primary_key: true
      add :job_key, :text, null: false
      add :cron, :text, null: false
      add :timezone, :text, default: "Etc/UTC"
      add :args, :map, default: %{}
      add :enabled, :boolean, default: true
      add :unique_period_seconds, :bigint
      add :last_enqueued_at, :utc_datetime_usec

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :updated_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")
    end

    drop_if_exists unique_index(:ng_job_schedules, [:job_key], name: "ng_job_schedules_unique_job_key_index")
    create unique_index(:ng_job_schedules, [:job_key],
             name: "ng_job_schedules_unique_job_key_index"
           )

    drop_if_exists table(:health_events)

    create table(:health_events, primary_key: false) do
      add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
      add :entity_type, :text, null: false
      add :entity_id, :text, null: false
      add :old_state, :text
      add :new_state, :text, null: false
      add :reason, :text
      add :node, :text
      add :duration_seconds, :bigint
      add :recorded_at, :utc_datetime, null: false
      add :metadata, :map, default: %{}
      add :tenant_id, :uuid, null: false
    end

    drop_if_exists index(:health_events, [:tenant_id, :entity_type, :new_state, :recorded_at])
    create index(:health_events, [:tenant_id, :entity_type, :new_state, :recorded_at])

    drop_if_exists index(:health_events, [:tenant_id, :recorded_at])
    create index(:health_events, [:tenant_id, :recorded_at])

    drop_if_exists index(:health_events, [:tenant_id, :entity_type, :entity_id, :recorded_at])
    create index(:health_events, [:tenant_id, :entity_type, :entity_id, :recorded_at])

    drop_if_exists unique_index(:health_events, [:tenant_id, :id], name: "health_events_unique_event_index")
    create unique_index(:health_events, [:tenant_id, :id],
             name: "health_events_unique_event_index"
           )

    # Add columns to checkers only if they don't exist (handles partial migrations)
    execute """
    DO $$
    BEGIN
      IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'checkers' AND column_name = 'status') THEN
        ALTER TABLE checkers ADD COLUMN status TEXT NOT NULL DEFAULT 'active';
      END IF;
      IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'checkers' AND column_name = 'consecutive_failures') THEN
        ALTER TABLE checkers ADD COLUMN consecutive_failures BIGINT DEFAULT 0;
      END IF;
      IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'checkers' AND column_name = 'last_success') THEN
        ALTER TABLE checkers ADD COLUMN last_success TIMESTAMP;
      END IF;
      IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'checkers' AND column_name = 'last_failure') THEN
        ALTER TABLE checkers ADD COLUMN last_failure TIMESTAMP;
      END IF;
      IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'checkers' AND column_name = 'failure_reason') THEN
        ALTER TABLE checkers ADD COLUMN failure_reason TEXT;
      END IF;
    END $$;
    """
  end

  def down do
    alter table(:checkers) do
      remove :failure_reason
      remove :last_failure
      remove :last_success
      remove :consecutive_failures
      remove :status
    end

    drop_if_exists unique_index(:health_events, [:tenant_id, :id],
                     name: "health_events_unique_event_index"
                   )

    drop_if_exists index(:health_events, [:tenant_id, :entity_type, :entity_id, :recorded_at])

    drop_if_exists index(:health_events, [:tenant_id, :recorded_at])

    drop_if_exists index(:health_events, [:tenant_id, :entity_type, :new_state, :recorded_at])

    drop table(:health_events)

    drop_if_exists unique_index(:ng_job_schedules, [:job_key],
                     name: "ng_job_schedules_unique_job_key_index"
                   )

    drop table(:ng_job_schedules)

    drop_if_exists unique_index(:poll_jobs, [:tenant_id, :id], name: "poll_jobs_unique_job_index")

    drop constraint(:poll_jobs, "poll_jobs_schedule_id_fkey")

    drop table(:poll_jobs)

    alter table(:pollers) do
      modify :status, :text, null: true, default: "active"
    end

    drop_if_exists unique_index(:tenant_cas, [:tenant_id, :status],
                     name: "tenant_cas_unique_active_tenant_ca_index"
                   )

    drop constraint(:tenant_cas, "tenant_cas_tenant_id_fkey")

    drop table(:tenant_cas)
  end
end
