# Implementation Plan: KV-Backed Canonical Identity Map (Step 1)

## Objective
Establish a shared canonical identity map in the KV service so device IDs are normalized at ingestion time. This reduces duplicate `device_id`s generated by DHCP/IP churn and positions poller/agent rewrites (including the Gleam migration) to consume the same source of truth.

## Desired Outcomes
- Core registry persists canonical identity decisions (Armis/NetBox/MAC + partition/IP aliases) into KV.
- Pollers/agents can query a lightweight gRPC endpoint to retrieve canonical IDs until they adopt local caches.
- Backfill CLIs become idempotent maintenance instead of a prerequisite migration.

## Scope
- Go services only (Core, Registry, Sync). Gleam clients use the data later.
- KV schema and replication strategy.
- Instrumentation and observability around map freshness and collision handling.

## Non-Goals
- Rewriting pollers/agents to consult the map directly (deferred to Step 2 / Gleam rewrite).
- Removing existing tombstone logic—kept as a safety net.
- Full automation of backfill executions.

## Deliverables
1. **Schema**: `kv://device_canonical_map/<identity-type>/<identity-key>` entries containing canonical `device_id`, partition, metadata checksum, and last-updated timestamp.
2. **Registry publisher**: `DeviceRegistry` emits KV updates after processing batches and reconciling canonical IDs.
3. **Core lookup API**: new RPC (`GetCanonicalDevice`) to allow legacy pollers/agents to query the map until they move to caches.
4. **Sync alignment**: Sync service writes canonical IDs when creating sweep configs, using the same helper library as the registry.
5. **Backfill integration**: Backfill job seeds the map for historic data and skips publishing tombstones already reflected in KV.
6. **Metrics & alerts**: counters/histograms for map hit rate, publish latency, and conflict resolution.
7. **Documentation**: Update architecture docs/runbooks explaining the map and fallback behaviour.

## Work Breakdown

### 1. Design & Validation
- [x] Draft KV key format and payload structure (protobuf selected for schema evolution).
- [x] Confirm KV consistency semantics (watch streams or versioned gets) and document latency expectations.  
  JetStream KV guarantees immediately consistent monotonic writes/reads inside a bucket, with optimistic locking via revision numbers (`Update`) and exclusive creates (`Create`). Direct `Get` calls may be served by followers, so read-your-writes requires targeting the stream leader; latency budgets should assume sub-100 ms on LAN clusters but allow a few hundred ms when replicas need to catch up. We'll expose revision metadata alongside the canonical record payload so pollers/agents can honor freshness timeouts when the KV path lags.
- [x] Define conflict resolution order: Armis > NetBox > MAC > partition/IP alias.
- [x] Review security: ensure KV ACLs allow core/poller both read and write, audit logging for map updates.  
  mTLS identities already gate access (see `pkg/kv/rbac.go`), but we need a writer role for registry/core and read-only role for pollers. Add audit hooks that emit structured logs on `Update`/`Delete`, and ensure the new CAS RPC inherits the same RBAC table before rollout.

### 2. Shared Library (`pkg/identitymap`)
- [x] Implement Go package providing:
  - `type IdentityKey struct { Kind enum; Value string }`
  - `type CanonicalRecord struct { DeviceID, Partition, MetadataHash string; UpdatedAt time.Time }`
  - Helpers `BuildKeys(*models.DeviceUpdate)` and `Serialize/Deserialize`.
- [x] Add unit tests covering key derivation across Armis, NetBox, MAC, partition/IP inputs.

### 3. Registry Publisher Hook
- [x] Inside `DeviceRegistry.ProcessBatchDeviceUpdates` post canonicalization:
  - Assemble `CanonicalRecord` for the winning device.
  - Write each identity key to KV via the shared client (per-key `Get` + `PutIfAbsent`/`Update` so CAS metadata is preserved).
  - Record metrics for publish success/failure.
- [x] Ensure operations are retried with exponential backoff / CAS semantics.  
  Registry publisher now performs per-key `Get` → `PutIfAbsent`/`Update` cycles with exponential backoff (capped at 5s) and leverages the new gRPC `Update` RPC. CAS conflicts surface as `codes.Aborted` and trigger retries; identical metadata hashes short-circuit without rewrites.

### 4. Core Lookup API
- Extend proto (`proto/core/service.proto`) with `GetCanonicalDevice` RPC.
- Implement handler in `pkg/core/api` that checks KV first, falls back to DB scan if missing, then hydrates cache.
- Add integration tests using in-memory KV stub.

### 5. Sync Service Alignment
- Update Sync writers to call shared library when generating sweep configs.
- Ensure they populate `canonical_device_id` metadata if map already contains the identity key.
- Add regression tests for Armis/NetBox sources.

### 6. Backfill Enhancements
- Modify `BackfillIdentityTombstones` and `BackfillIPAliasTombstones` to:
  - Populate KV entries while walking historical rows.
  - Skip publishing tombstones when KV already points at the canonical device (idempotent behaviour).
- Provide `--seed-kv-only` option for dry seeding without tombstones.

### 7. Observability & Ops
- Expose Prometheus metrics: `identitymap_kv_publish_total`, `identitymap_lookup_latency_seconds`, `identitymap_conflict_total`.
- Add structured logs when conflicts occur or CAS retries exceed budget.
- Update runbooks (`docs/docs/architecture.md` + new ops doc) to cover rollout, monitoring, failure scenarios, and rollback.

### 8. Rollout Plan
- Ship behind feature flag `CanonicalIdentityMapEnabled` (default off).
- Deploy to staging, run backfill with `--seed-kv-only`, verify poller lookups via API.
- Enable flag in production, monitor hit rate and duplicate suppression.
- Gradually update pollers/agents to use lookup API (pre-Gleam clients) while tracking fallback to tombstones.

## Risks & Mitigations
| Risk | Impact | Mitigation |
|------|--------|------------|
| KV outages leave map stale | Duplicate IDs resurface temporarily | Keep core canonicalization + tombstones active; add circuit breaker that falls back to DB lookups |
| CAS write contention | Dropped updates | Retry with jitter, track `identitymap_conflict_total`, escalate alert if trends increase |
| Sync writes predating registry decisions | Overwrites canonical device | Require map writes to include `MetadataHash`; registry rejects stale writes via CAS version |
| Backfill duration | Long-running job, potential KV load | Chunk by partition, use rate limiting, run during off-peak windows |

## Exit Criteria
- Duplicate `device_id` creation rate drops by >90% in staging.
- Backfill CLI completes without publishing new tombstones for already merged identities.
- Metrics dashboards show sustained KV publish success >99.9% and lookup hit rate >95% post-rollout.
- Documentation and runbooks reviewed with ops team.
