# Implementation Plan: KV-Backed Canonical Identity Map (Step 1)

## Objective
Establish a shared canonical identity map in the KV service so device IDs are normalized at ingestion time. This reduces duplicate `device_id`s generated by DHCP/IP churn and positions poller/agent rewrites (including the Gleam migration) to consume the same source of truth.

## Desired Outcomes
- Core registry persists canonical identity decisions (Armis/NetBox/MAC + partition/IP aliases) into KV.
- Pollers/agents can query a lightweight gRPC endpoint to retrieve canonical IDs until they adopt local caches.
- Backfill CLIs become idempotent maintenance instead of a prerequisite migration.

## Scope
- Go services only (Core, Registry, Sync). Gleam clients use the data later.
- KV schema and replication strategy.
- Instrumentation and observability around map freshness and collision handling.

## Non-Goals
- Rewriting pollers/agents to consult the map directly (deferred to Step 2 / Gleam rewrite).
- Removing existing tombstone logicâ€”kept as a safety net.
- Full automation of backfill executions.

## Deliverables
1. **Schema**: `kv://device_canonical_map/<identity-type>/<identity-key>` entries containing canonical `device_id`, partition, metadata checksum, and last-updated timestamp.
2. **Registry publisher**: `DeviceRegistry` emits KV updates after processing batches and reconciling canonical IDs.
3. **Core lookup API**: new RPC (`GetCanonicalDevice`) to allow legacy pollers/agents to query the map until they move to caches.
4. **Sync alignment**: Sync service writes canonical IDs when creating sweep configs, using the same helper library as the registry.
5. **Backfill integration**: Backfill job seeds the map for historic data and skips publishing tombstones already reflected in KV.
6. **Metrics & alerts**: counters/histograms for map hit rate, publish latency, and conflict resolution.
7. **Documentation**: Update architecture docs/runbooks explaining the map and fallback behaviour.

## Work Breakdown

### 1. Design & Validation
- Draft KV key format and payload structure (JSON vs protobuf). Prefer protobuf for schema evolution.
- Confirm KV consistency semantics (watch streams or versioned gets) and document latency expectations.
- Define conflict resolution order: Armis > NetBox > MAC > partition/IP alias.
- Review security: ensure KV ACLs allow core/poller both read and write, audit logging for map updates.

### 2. Shared Library (`pkg/identitymap`)
- Implement Go package providing:
  - `type IdentityKey struct { Kind enum; Value string }`
  - `type CanonicalRecord struct { DeviceID, Partition, MetadataHash string; UpdatedAt time.Time }`
  - Helpers `BuildKeys(*models.DeviceUpdate)` and `Serialize/Deserialize`.
- Add unit tests covering key derivation across Armis, NetBox, MAC, partition/IP inputs.

### 3. Registry Publisher Hook
- Inside `DeviceRegistry.ProcessBatchDeviceUpdates` post canonicalization:
  - Assemble `CanonicalRecord` for the winning device.
  - Write each identity key to KV via new client (`kv.Client.Put` with CAS to prevent stale overwrites).
  - Record metrics for publish success/failure.
- Ensure operations are batched and retried with exponential backoff.

### 4. Core Lookup API
- Extend proto (`proto/core/service.proto`) with `GetCanonicalDevice` RPC.
- Implement handler in `pkg/core/api` that checks KV first, falls back to DB scan if missing, then hydrates cache.
- Add integration tests using in-memory KV stub.

### 5. Sync Service Alignment
- Update Sync writers to call shared library when generating sweep configs.
- Ensure they populate `canonical_device_id` metadata if map already contains the identity key.
- Add regression tests for Armis/NetBox sources.

### 6. Backfill Enhancements
- Modify `BackfillIdentityTombstones` and `BackfillIPAliasTombstones` to:
  - Populate KV entries while walking historical rows.
  - Skip publishing tombstones when KV already points at the canonical device (idempotent behaviour).
- Provide `--seed-kv-only` option for dry seeding without tombstones.

### 7. Observability & Ops
- Expose Prometheus metrics: `identitymap_kv_publish_total`, `identitymap_lookup_latency_seconds`, `identitymap_conflict_total`.
- Add structured logs when conflicts occur or CAS retries exceed budget.
- Update runbooks (`docs/docs/architecture.md` + new ops doc) to cover rollout, monitoring, failure scenarios, and rollback.

### 8. Rollout Plan
- Ship behind feature flag `CanonicalIdentityMapEnabled` (default off).
- Deploy to staging, run backfill with `--seed-kv-only`, verify poller lookups via API.
- Enable flag in production, monitor hit rate and duplicate suppression.
- Gradually update pollers/agents to use lookup API (pre-Gleam clients) while tracking fallback to tombstones.

## Risks & Mitigations
| Risk | Impact | Mitigation |
|------|--------|------------|
| KV outages leave map stale | Duplicate IDs resurface temporarily | Keep core canonicalization + tombstones active; add circuit breaker that falls back to DB lookups |
| CAS write contention | Dropped updates | Retry with jitter, track `identitymap_conflict_total`, escalate alert if trends increase |
| Sync writes predating registry decisions | Overwrites canonical device | Require map writes to include `MetadataHash`; registry rejects stale writes via CAS version |
| Backfill duration | Long-running job, potential KV load | Chunk by partition, use rate limiting, run during off-peak windows |

## Exit Criteria
- Duplicate `device_id` creation rate drops by >90% in staging.
- Backfill CLI completes without publishing new tombstones for already merged identities.
- Metrics dashboards show sustained KV publish success >99.9% and lookup hit rate >95% post-rollout.
- Documentation and runbooks reviewed with ops team.

