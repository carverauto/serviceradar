{{- if (not (eq false .Values.secrets.autoGenerate)) }}
{{- $secretName := default "serviceradar-secrets" .Values.secrets.existingSecretName -}}
{{- $toolsTag := default "latest" .Values.image.tags.tools -}}
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: serviceradar-secret-generator
  namespace: {{ .Release.Namespace }}
  labels:
    app.kubernetes.io/part-of: serviceradar
    app.kubernetes.io/component: secret-generator
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-weight": "-5"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
---
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: serviceradar-secret-generator
  namespace: {{ .Release.Namespace }}
  labels:
    app.kubernetes.io/part-of: serviceradar
    app.kubernetes.io/component: secret-generator
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-weight": "-5"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "list", "create", "update", "patch"]
---
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: serviceradar-secret-generator
  namespace: {{ .Release.Namespace }}
  labels:
    app.kubernetes.io/part-of: serviceradar
    app.kubernetes.io/component: secret-generator
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-weight": "-5"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: serviceradar-secret-generator
subjects:
- kind: ServiceAccount
  name: serviceradar-secret-generator
  namespace: {{ .Release.Namespace }}
---
apiVersion: batch/v1
kind: Job
metadata:
  name: serviceradar-secret-generator
  namespace: {{ .Release.Namespace }}
  labels:
    app.kubernetes.io/part-of: serviceradar
    app.kubernetes.io/component: secret-generator
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
spec:
  ttlSecondsAfterFinished: 300
  backoffLimit: 2
  template:
    metadata:
      labels:
        app: serviceradar-secret-generator
        app.kubernetes.io/part-of: serviceradar
        app.kubernetes.io/component: secret-generator
    spec:
      serviceAccountName: serviceradar-secret-generator
      restartPolicy: OnFailure
      {{- include "serviceradar.imagePullSecrets" . | nindent 6 }}
      containers:
      - name: secret-generator
        image: ghcr.io/carverauto/serviceradar-tools:{{ $toolsTag }}
        imagePullPolicy: IfNotPresent
        command: ["/bin/sh", "-c"]
        env:
        - name: EDGE_ONBOARDING_KEY_OVERRIDE
          value: {{ default "" .Values.secrets.edgeOnboardingKey | quote }}
        args:
        - |
          set -euo pipefail

          SECRET_NAME="${SECRET_NAME:-serviceradar-secrets}"
          APISERVER="https://kubernetes.default.svc"
          SERVICEACCOUNT="/var/run/secrets/kubernetes.io/serviceaccount"
          TOKEN=$(cat "${SERVICEACCOUNT}/token")
          NAMESPACE=$(cat "${SERVICEACCOUNT}/namespace")
          CACERT="${SERVICEACCOUNT}/ca.crt"
          REQUIRED_KEYS="jwt-secret api-key admin-password admin-bcrypt-hash edge-onboarding-key"

          existing_secret=$(mktemp)
          has_secret=false
          if curl -fsS --cacert "${CACERT}" --header "Authorization: Bearer ${TOKEN}" \
            -o "${existing_secret}" \
            "${APISERVER}/api/v1/namespaces/${NAMESPACE}/secrets/${SECRET_NAME}" >/dev/null 2>&1; then
            has_secret=true
          fi

          missing_keys=""
          if [ "${has_secret}" = true ]; then
            for key in ${REQUIRED_KEYS}; do
              if ! jq -e --arg k "${key}" '.data | has($k)' "${existing_secret}" >/dev/null; then
                missing_keys="${missing_keys} ${key}"
              fi
            done

            if [ -z "${missing_keys#"${missing_keys%%[![:space:]]*}"}" ]; then
              echo "✅ Secret ${SECRET_NAME} already has required keys; skipping generation"
              exit 0
            fi
            echo "ℹ️ Secret ${SECRET_NAME} exists but missing keys:${missing_keys}"
          else
            echo "ℹ️ Secret ${SECRET_NAME} not found; generating new one"
            missing_keys="${REQUIRED_KEYS}"
          fi

          if [ "${has_secret}" = true ] && [ -n "${EDGE_ONBOARDING_KEY_OVERRIDE:-}" ]; then
            missing_keys="${missing_keys} edge-onboarding-key"
          fi

          rand_hex() { head -c 32 /dev/urandom | hexdump -v -e '/1 "%02x"'; }
          rand_pw() { head -c 24 /dev/urandom | base64 | tr -d '=+/' | head -c 20; }
          b64_nows() { printf '%s' "$1" | base64 | tr -d '\n'; }

          JWT_SECRET_RAW=$(rand_hex)
          API_KEY_RAW=$(rand_hex)
          ADMIN_PASSWORD_RAW=$(rand_pw)
          ADMIN_BCRYPT_HASH=$(serviceradar-cli auth bcrypt-gen --password "${ADMIN_PASSWORD_RAW}")
          if [ -n "${EDGE_ONBOARDING_KEY_OVERRIDE:-}" ]; then
            EDGE_KEY_RAW="${EDGE_ONBOARDING_KEY_OVERRIDE}"
          else
            EDGE_KEY_RAW=$(head -c 32 /dev/urandom | base64)
          fi

          JWT_SECRET=$(b64_nows "${JWT_SECRET_RAW}")
          API_KEY=$(b64_nows "${API_KEY_RAW}")
          ADMIN_PASSWORD=$(b64_nows "${ADMIN_PASSWORD_RAW}")
          ADMIN_BCRYPT_HASH_B64=$(b64_nows "${ADMIN_BCRYPT_HASH}")
          EDGE_KEY=$(b64_nows "${EDGE_KEY_RAW}")

          if [ "${has_secret}" = false ]; then
            cat <<EOF >/tmp/secret.json
          {
            "apiVersion": "v1",
            "kind": "Secret",
            "metadata": {
              "name": "${SECRET_NAME}",
              "labels": {
                "app.kubernetes.io/part-of": "serviceradar",
                "app.kubernetes.io/component": "secrets"
              }
            },
            "type": "Opaque",
            "data": {
              "jwt-secret": "${JWT_SECRET}",
              "api-key": "${API_KEY}",
              "admin-password": "${ADMIN_PASSWORD}",
              "admin-bcrypt-hash": "${ADMIN_BCRYPT_HASH_B64}",
              "edge-onboarding-key": "${EDGE_KEY}"
            }
          }
          EOF
            curl -fsS --cacert "${CACERT}" --header "Authorization: Bearer ${TOKEN}" \
              --header "Content-Type: application/json" \
              -X POST "${APISERVER}/api/v1/namespaces/${NAMESPACE}/secrets" \
              -d @/tmp/secret.json
            echo "✅ Created secret ${SECRET_NAME}"
            exit 0
          fi

          patch_file=$(mktemp)
          echo "[" > "${patch_file}"
          first=1
          add_patch() {
            key="$1"
            val="$2"
            op="add"
            if [ "${has_secret}" = true ] && [ "${key}" = "edge-onboarding-key" ]; then
              op="replace"
            fi
            if [ "${first}" -eq 0 ]; then
              echo "," >> "${patch_file}"
            fi
            first=0
            printf '{"op":"%s","path":"/data/%s","value":"%s"}' "${op}" "${key}" "${val}" >> "${patch_file}"
          }

          for key in ${missing_keys}; do
            case "${key}" in
              jwt-secret) add_patch "jwt-secret" "${JWT_SECRET}" ;;
              api-key) add_patch "api-key" "${API_KEY}" ;;
              admin-password) add_patch "admin-password" "${ADMIN_PASSWORD}" ;;
              admin-bcrypt-hash) add_patch "admin-bcrypt-hash" "${ADMIN_BCRYPT_HASH_B64}" ;;
              edge-onboarding-key) add_patch "edge-onboarding-key" "${EDGE_KEY}" ;;
            esac
          done
          echo "]" >> "${patch_file}"

          curl -fsS --cacert "${CACERT}" --header "Authorization: Bearer ${TOKEN}" \
            --header "Content-Type: application/json-patch+json" \
            -X PATCH "${APISERVER}/api/v1/namespaces/${NAMESPACE}/secrets/${SECRET_NAME}" \
            -d @"${patch_file}"

          echo "✅ Patched ${SECRET_NAME} with missing keys:${missing_keys}"
{{- end }}
