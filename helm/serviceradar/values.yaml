namespace: demo

# Global settings that apply across all services
global:
  # Override all ServiceRadar image tags at once. When set, this takes precedence
  # over individual image.tags.* values. Use for releases (e.g., "v1.0.70").
  # Leave empty to use individual tags below.
  imageTag: ""
  # Image pull policy: IfNotPresent (default), Always (for staging/mutable tags), Never
  imagePullPolicy: IfNotPresent

image:
  registryPullSecret: ghcr-io-cred
  tags:
    # Default tag for ServiceRadar images. Use global.imageTag to override all at once.
    # For production, set global.imageTag to a specific version (e.g., "v1.0.71").
    appTag: &appTag "latest"
    core: *appTag
    webNg: *appTag
    nats: "2.12.2-alpine"
    datasvc: *appTag
    agent: *appTag
    poller: *appTag
    snmpChecker: *appTag
    dbEventWriter: *appTag
    otel: *appTag
    mapper: *appTag
    trapd: *appTag
    flowgger: *appTag
    zen: *appTag
    sync: *appTag
    rperfClient: *appTag
    faker: *appTag
    rperfChecker: *appTag
    tools: *appTag
kv:
  enabled: true
  configSource: kv
  bucket: serviceradar-datasvc
  address: serviceradar-datasvc:50057
  secMode: spiffe
  trustDomain: ""
  serverSPIFFEID: ""
  workloadSocket: unix:/run/spire/sockets/agent.sock
  certDir: /etc/serviceradar/certs
checkerTemplates:
  # Enable checker template seeding into KV for edge onboarding
  enabled: true
core:
  # Enable or disable KV watch/reload in the core service
  configWatchEnabled: true
  # Stale device reaper settings - controls cleanup of IP-only "ghost" devices
  reaper:
    # How often to run the reaper job
    interval: "1h"
    # How long a device without strong identity (IP-only) must be unseen before deletion
    ttl: "24h"
  identity:
    enabled: true
    # Enable promotion so sightings are turned into devices automatically.
    sightingsOnlyMode: true
    promotion:
      enabled: false
      shadowMode: false
      minPersistence: "1h"
      requireHostname: true
      requireFingerprint: false
    fingerprinting:
      enabled: false
      portBudget: 32
      timeout: "2s"
    reaper:
      interval: "1m"
      profiles:
        default:
          ttl: "24h"
        dynamic:
          ttl: "6h"
        guest:
          ttl: "1h"
        static:
          ttl: "72h"
          allowIPAsID: false
    drift:
      baselineDevices: 50000
      tolerancePercent: 2
      pauseOnDrift: true
      alertOnDrift: true
faker:
  simulation:
    totalDevices: 50000
    ipShuffle:
      enabled: true
      interval: "10m"
      percentage: 5
      warmupCycles: 2
      allowExpansion: false
      poolHeadroomPercent: 0
coreClient:
  address: "" # auto-derived to serviceradar-core.<namespace>.svc.cluster.local:50052
  secMode: spiffe
  trustDomain: ""
  serverSPIFFEID: ""
  workloadSocket: unix:/run/spire/sockets/agent.sock
  certDir: /etc/serviceradar/certs
cnpg:
  host: ""
  port: 5432
  database: serviceradar
  username: serviceradar
  runtimeParams:
    search_path: "public,ag_catalog,\\\"$user\\\""
  credentialsSecret: serviceradar-db-credentials
  sslmode: verify-full
  certDir: /etc/serviceradar/certs
  caFile: /etc/serviceradar/cnpg/ca.crt
webNg:
  host: ""
  checkOrigin: "false"
  devRoutes: "false"
  localMailer: "false"
agent:
  resources:
    limits:
      cpu: 500m
      memory: 1Gi
    requests:
      cpu: 200m
      memory: 512Mi
dbEventWriter:
  # Use on-disk config to avoid storing DB secrets in KV; passwords come from the secret env vars.
  configSource: file
  kvBootstrap:
    enabled: true
configSync:
  flowgger:
    enabled: true
    seed: true
    watch: false
    kvKey: ""
    role: ""
    extraArgs: ""
    extraEnv: {}
  trapd:
    enabled: true
    seed: true
    watch: false
    kvKey: ""
    role: ""
    extraArgs: ""
    extraEnv: {}
  otel:
    enabled: true
    seed: true
    watch: false
    kvKey: ""
    role: ""
    extraArgs: ""
    extraEnv: {}
  zen:
    enabled: true
    seed: true
    watch: false
    kvKey: ""
    role: ""
    extraArgs: ""
    extraEnv: {}
spire:
  enabled: true
  namespace: ""
  serverSelector: app=spire-server
  trustDomain: carverauto.dev
  clusterName: carverauto-cluster
  agentServiceAccount: spire-agent
  coreServiceAccount: serviceradar-core
  pollerServiceAccount: serviceradar-poller
  datasvcServiceAccount: serviceradar-datasvc
  serviceradarAgentServiceAccount: serviceradar-agent
  socketHostPath: ""
  joinTokenTTL: 15m
  otelServiceAccount: serviceradar-otel
  syncServiceAccount: serviceradar-sync
  zenServiceAccount: serviceradar-zen
  mapperServiceAccount: serviceradar-mapper
  dbEventWriterServiceAccount: serviceradar-db-event-writer
  snmpCheckerServiceAccount: serviceradar-snmp-checker
  rperfCheckerServiceAccount: serviceradar-rperf-checker
  flowggerServiceAccount: serviceradar-flowgger
  trapdServiceAccount: serviceradar-trapd
  nestedPoller:
    enabled: false
    name: poller-nested-spire
    containerName: poller-nested-spire
    podLabelKey: app
    podLabelValue: serviceradar-poller
    spiffeID: ""
    x509TTL: 4h
    jwtTTL: 30m
    admin: true
    storeSVID: true
    joinTokenMode: disabled
    serverPort: 8083
    upstreamServerAddress: ""
    upstreamServerPort: 8081
    upstreamAgentSocketPath: /run/spire/nested/upstream/agent.sock
    downstreamAgentSocketPath: /run/spire/nested/workload/agent.sock
    upstreamAgentDataDir: /run/spire/nested/upstream-agent
    downstreamAgentDataDir: /run/spire/nested/downstream-agent
    serverDataDir: /run/spire/nested/server
    logLevel: INFO
    extraSelectors: []
    downstreamX509TTLSeconds: 14400
    downstreamJWTTTLSeconds: 1800
    downstreamWaitSeconds: 5
    downstreamRefreshSeconds: 300
    downstreamRegistrationMode: disabled
    downstreamRetrySeconds: 5
    adminUsername: admin
    adminSecret: serviceradar-secrets
    adminSecretKey: admin-password
    joinToken:
      enabled: true
      ttlSeconds: 900
      coreURL: http://serviceradar-core:8090
      apiKeySecret: serviceradar-secrets
      apiKeyKey: api-key
  bundleConfigMap: spire-bundle
  server:
    image: ghcr.io/spiffe/spire-server:1.11.2
    logLevel: DEBUG
    adminIDs: []
    initConfigImage: busybox
    serviceName: spire-server
    serviceType: LoadBalancer
    dataPVC:
      size: 1Gi
      storageClass: ""
  agent:
    image: ghcr.io/spiffe/spire-agent:1.11.2
    logLevel: DEBUG
    waitForImage: cgr.dev/chainguard/wait-for-it
  tokenAudience: spire-server
  additionalAgentNamespaces: []
  postgres:
    enabled: true
    clusterName: cnpg
    database: spire
    instances: 3
    storageClass: local-path
    storageSize: 100Gi
    secretName: spire-db-credentials
    username: spire
    password: changeme
    image: ghcr.io/carverauto/serviceradar-cnpg
    imageTag: ""
    imageName: ghcr.io/carverauto/serviceradar-cnpg:16.6.0-sr3@sha256:882fdd3f4905342a6ffa347ee988840eafa4f8e8b234a26e6e8cb72ec71b8eb8
    imagePullSecrets: []
    sharedPreloadLibraries:
      - timescaledb
      - age
    extensionsSQL:
      - CREATE EXTENSION IF NOT EXISTS timescaledb;
      - CREATE EXTENSION IF NOT EXISTS age;
  controllerManager:
    enabled: true
    image: ghcr.io/spiffe/spire-controller-manager
    tag: 0.6.3
    configMapName: spire-controller-manager-config
    spireServerSocketPath: /spire-server/api.sock
    metricsBindAddress: 127.0.0.1:8082
    healthProbeBindAddress: 0.0.0.0:8083
    logLevel: info
    leaderElectionResourceName: spire-controller-manager
    ignoreNamespaces:
      - kube-system
      - kube-public
      - local-path-storage
      - kube-node-lease
    validatingWebhookConfigurationName: spire-controller-manager-webhook
    enableWebhooks: false
    resources:
      limits:
        cpu: 200m
        memory: 512Mi
      requests:
        cpu: 50m
        memory: 256Mi
ingress:
  enabled: true
  host: demo.serviceradar.cloud
  className: nginx
  annotations: {}
  tls:
    enabled: true
    secretName: serviceradar-prod-tls
    clusterIssuer: carverauto-issuer
secrets:
  autoGenerate: true
  existingSecretName: serviceradar-secrets
  # Provide adminBcryptHash to avoid in-cluster generation.
  adminBcryptHash: ""
  # Base64-encoded 32-byte key for edge onboarding; used by core and seeded into config.
  edgeOnboardingKey: "5yV33bvFfRKBz5y20XPVnxyysYhXc/LXdG4jtrvrkN0="
# Network sweep defaults (can be tuned per-deploy)
sweep:
  # Target networks and ports to scan
  networks:
    - 192.168.2.0/24
    - 192.168.3.1/32
  ports:
    - 22
    - 80
    - 443
    - 3306
    - 5432
    - 6379
    - 8080
    - 8443
  # Sweep modes and pacing
  modes:
    - icmp
    - tcp
  interval: 5m
  concurrency: 100
  timeout: 10s
  tcp:
    # SYN packets per second; keep conservative by default
    rateLimit: 20000
    rateLimitBurst: 20000
    # Per-scanner tuning
    maxBatch: 32
    concurrency: 256
    timeout: 3s
    # Route discovery and ring buffer tuning
    routeDiscoveryHost: 8.8.8.8:80
    ringBlockSize: 0
    ringBlockCount: 0
    interface: ""
    suppressRSTReply: false
    globalRingMemoryMB: 0
    ringReaders: 0
    ringPollTimeoutMs: 0
  icmp:
    # Enable high performance ICMP (raw sockets) where permitted
    highPerf: true
    # Global ICMP rate limit (scanner-level)
    rateLimit: 5000
    settings:
      # Per-batch ICMP settings for fine tuning
      rateLimit: 1000
      timeout: 5s
      maxBatch: 64

# =============================================================================
# Elixir Poller Configuration
# =============================================================================
# Standalone Elixir release that joins the ERTS cluster for distributed monitoring

pollerElx:
  enabled: false
  replicas: 1
  
  # Poller identification
  partitionId: "default"
  domain: "default"
  capabilities: "icmp,tcp,http"
  
  # Cluster configuration
  clusterStrategy: "kubernetes"
  kubernetesSelector: "app=serviceradar"
  nodeBasename: "serviceradar"
  coreService: "serviceradar-core-elx-headless"
  
  # Secrets
  serviceAccount: "serviceradar-poller-elx"
  cookieSecret: "serviceradar-secrets"
  cookieSecretKey: "erlang-cookie"
  certSecret: "serviceradar-certs"
  
  # Resources
  resources:
    limits:
      cpu: "500m"
      memory: "512Mi"
    requests:
      cpu: "100m"
      memory: "256Mi"

# =============================================================================
# SPIFFE Configuration (shared by all Elixir components)
# =============================================================================

spiffe:
  mode: "filesystem"
  trustDomain: "serviceradar.local"
