import gleam/otp/actor

pub type MetricsCollectorState {
  MetricsCollectorState(
    polls_total: Int,
    polls_successful: Int,
    polls_failed: Int,
  )
}

pub type MetricsCollectorMessage {
  IncrementPollsTotal
  IncrementPollsSuccessful
  IncrementPollsFailed
  GetMetrics
  Shutdown
}

pub fn start() -> Result(actor.StartResult(MetricsCollectorMessage), actor.StartError) {
  let initial_state = MetricsCollectorState(
    polls_total: 0,
    polls_successful: 0,
    polls_failed: 0,
  )
  actor.start(initial_state, handle_message)
}

fn handle_message(
  message: MetricsCollectorMessage,
  state: MetricsCollectorState,
) -> actor.Next(MetricsCollectorMessage, MetricsCollectorState) {
  case message {
    IncrementPollsTotal -> {
      actor.continue(MetricsCollectorState(
        ..state,
        polls_total: state.polls_total + 1,
      ))
    }

    IncrementPollsSuccessful -> {
      actor.continue(MetricsCollectorState(
        ..state,
        polls_successful: state.polls_successful + 1,
      ))
    }

    IncrementPollsFailed -> {
      actor.continue(MetricsCollectorState(
        ..state,
        polls_failed: state.polls_failed + 1,
      ))
    }

    GetMetrics -> {
      // For now, just continue - in real implementation this would reply
      actor.continue(state)
    }

    Shutdown -> {
      actor.stop(actor.Normal)
    }
  }
}