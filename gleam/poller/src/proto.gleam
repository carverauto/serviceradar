//// Generated by Protozoa from proto/monitoring.proto
//// 
//// This file is auto-generated and can be safely deleted and regenerated.
//// To regenerate all proto files, run: gleam run -m proto_codegen
//// 
//// DO NOT EDIT THIS FILE MANUALLY - all changes will be lost on regeneration.

import gleam/int
import gleam/list
import gleam/result
import gleam/string
import protozoa/decode
import protozoa/encode
import protozoa/wire

pub type SweepStatus {
  UNKNOWN
  NOTSTARTED
  INPROGRESS
  COMPLETED
  FAILED
}

pub type DeviceStatusRequest {
  DeviceStatusRequest(
    agent_id: String,
  )
}

pub type StatusRequest {
  StatusRequest(
    service_name: String,
    service_type: String,
    agent_id: String,
    poller_id: String,
    details: String,
    port: Int,
  )
}

pub type ResultsRequest {
  ResultsRequest(
    service_name: String,
    service_type: String,
    agent_id: String,
    poller_id: String,
    details: String,
    last_sequence: String,
    completion_status: SweepCompletionStatus,
  )
}

pub type StatusResponse {
  StatusResponse(
    available: Bool,
    message: BitArray,
    service_name: String,
    service_type: String,
    response_time: Int,
    agent_id: String,
    poller_id: String,
  )
}

pub type ResultsResponse {
  ResultsResponse(
    available: Bool,
    data: BitArray,
    service_name: String,
    service_type: String,
    response_time: Int,
    agent_id: String,
    poller_id: String,
    timestamp: Int,
    current_sequence: String,
    has_new_data: Bool,
    sweep_completion: SweepCompletionStatus,
  )
}

pub type PollerStatusRequest {
  PollerStatusRequest(
    services: List(ServiceStatus),
    poller_id: String,
    agent_id: String,
    timestamp: Int,
    partition: String,
    source_ip: String,
    kv_store_id: String,
  )
}

pub type PollerStatusResponse {
  PollerStatusResponse(
    received: Bool,
  )
}

pub type ServiceStatus {
  ServiceStatus(
    service_name: String,
    available: Bool,
    message: BitArray,
    service_type: String,
    response_time: Int,
    agent_id: String,
    poller_id: String,
    partition: String,
    source: String,
    kv_store_id: String,
  )
}

pub type SweepServiceStatus {
  SweepServiceStatus(
    network: String,
    total_hosts: Int,
    available_hosts: Int,
    ports: List(PortStatus),
    last_sweep: Int,
  )
}

pub type PortStatus {
  PortStatus(
    port: Int,
    available: Int,
  )
}

pub type ResultsChunk {
  ResultsChunk(
    data: BitArray,
    is_final: Bool,
    chunk_index: Int,
    total_chunks: Int,
    current_sequence: String,
    timestamp: Int,
  )
}

pub type SweepCompletionStatus {
  SweepCompletionStatus(
    status: SweepStatus,
    completion_time: Int,
    target_sequence: String,
    total_targets: Int,
    completed_targets: Int,
    error_message: String,
  )
}

pub type PollerStatusChunk {
  PollerStatusChunk(
    services: List(ServiceStatus),
    poller_id: String,
    agent_id: String,
    timestamp: Int,
    partition: String,
    source_ip: String,
    is_final: Bool,
    chunk_index: Int,
    total_chunks: Int,
    kv_store_id: String,
  )
}

pub fn encode_pollerstatuschunk(pollerstatuschunk: PollerStatusChunk) -> BitArray {
  let services_fields = list.map(pollerstatuschunk.services, fn(v) { encode.field(1, wire.LengthDelimited, encode.length_delimited(encode_servicestatus(v))) })
  encode.message(list.flatten([services_fields, [encode.string_field(2, pollerstatuschunk.poller_id)], [encode.string_field(3, pollerstatuschunk.agent_id)], [encode.int64_field(4, pollerstatuschunk.timestamp)], [encode.string_field(5, pollerstatuschunk.partition)], [encode.string_field(6, pollerstatuschunk.source_ip)], [encode.bool_field(7, pollerstatuschunk.is_final)], [encode.int32_field(8, pollerstatuschunk.chunk_index)], [encode.int32_field(9, pollerstatuschunk.total_chunks)], [encode.string_field(10, pollerstatuschunk.kv_store_id)]]))
}

pub fn encode_sweepcompletionstatus(sweepcompletionstatus: SweepCompletionStatus) -> BitArray {
  encode.message([
    encode.int32_field(1, encode_sweepstatus_value(sweepcompletionstatus.status)),
    encode.int64_field(2, sweepcompletionstatus.completion_time),
    encode.string_field(3, sweepcompletionstatus.target_sequence),
    encode.int32_field(4, sweepcompletionstatus.total_targets),
    encode.int32_field(5, sweepcompletionstatus.completed_targets),
    encode.string_field(6, sweepcompletionstatus.error_message),
  ])
}

pub fn encode_resultschunk(resultschunk: ResultsChunk) -> BitArray {
  encode.message([
    encode.field(1, wire.LengthDelimited, encode.length_delimited(resultschunk.data)),
    encode.bool_field(2, resultschunk.is_final),
    encode.int32_field(3, resultschunk.chunk_index),
    encode.int32_field(4, resultschunk.total_chunks),
    encode.string_field(5, resultschunk.current_sequence),
    encode.int64_field(6, resultschunk.timestamp),
  ])
}

pub fn encode_portstatus(portstatus: PortStatus) -> BitArray {
  encode.message([
    encode.int32_field(1, portstatus.port),
    encode.int32_field(2, portstatus.available),
  ])
}

pub fn encode_sweepservicestatus(sweepservicestatus: SweepServiceStatus) -> BitArray {
  let ports_fields = list.map(sweepservicestatus.ports, fn(v) { encode.field(4, wire.LengthDelimited, encode.length_delimited(encode_portstatus(v))) })
  encode.message(list.flatten([ports_fields, [encode.string_field(1, sweepservicestatus.network)], [encode.int32_field(2, sweepservicestatus.total_hosts)], [encode.int32_field(3, sweepservicestatus.available_hosts)], [encode.int64_field(5, sweepservicestatus.last_sweep)]]))
}

pub fn encode_servicestatus(servicestatus: ServiceStatus) -> BitArray {
  encode.message([
    encode.string_field(1, servicestatus.service_name),
    encode.bool_field(2, servicestatus.available),
    encode.field(3, wire.LengthDelimited, encode.length_delimited(servicestatus.message)),
    encode.string_field(4, servicestatus.service_type),
    encode.int64_field(5, servicestatus.response_time),
    encode.string_field(6, servicestatus.agent_id),
    encode.string_field(7, servicestatus.poller_id),
    encode.string_field(8, servicestatus.partition),
    encode.string_field(9, servicestatus.source),
    encode.string_field(10, servicestatus.kv_store_id),
  ])
}

pub fn encode_pollerstatusresponse(pollerstatusresponse: PollerStatusResponse) -> BitArray {
  encode.message([
    encode.bool_field(1, pollerstatusresponse.received),
  ])
}

pub fn encode_pollerstatusrequest(pollerstatusrequest: PollerStatusRequest) -> BitArray {
  let services_fields = list.map(pollerstatusrequest.services, fn(v) { encode.field(1, wire.LengthDelimited, encode.length_delimited(encode_servicestatus(v))) })
  encode.message(list.flatten([services_fields, [encode.string_field(2, pollerstatusrequest.poller_id)], [encode.string_field(3, pollerstatusrequest.agent_id)], [encode.int64_field(4, pollerstatusrequest.timestamp)], [encode.string_field(5, pollerstatusrequest.partition)], [encode.string_field(6, pollerstatusrequest.source_ip)], [encode.string_field(7, pollerstatusrequest.kv_store_id)]]))
}

pub fn encode_resultsresponse(resultsresponse: ResultsResponse) -> BitArray {
  encode.message([
    encode.bool_field(1, resultsresponse.available),
    encode.field(2, wire.LengthDelimited, encode.length_delimited(resultsresponse.data)),
    encode.string_field(3, resultsresponse.service_name),
    encode.string_field(4, resultsresponse.service_type),
    encode.int64_field(5, resultsresponse.response_time),
    encode.string_field(6, resultsresponse.agent_id),
    encode.string_field(7, resultsresponse.poller_id),
    encode.int64_field(8, resultsresponse.timestamp),
    encode.string_field(9, resultsresponse.current_sequence),
    encode.bool_field(10, resultsresponse.has_new_data),
    encode.field(11, wire.LengthDelimited, encode.length_delimited(encode_sweepcompletionstatus(resultsresponse.sweep_completion))),
  ])
}

pub fn encode_statusresponse(statusresponse: StatusResponse) -> BitArray {
  encode.message([
    encode.bool_field(1, statusresponse.available),
    encode.field(2, wire.LengthDelimited, encode.length_delimited(statusresponse.message)),
    encode.string_field(3, statusresponse.service_name),
    encode.string_field(4, statusresponse.service_type),
    encode.int64_field(5, statusresponse.response_time),
    encode.string_field(6, statusresponse.agent_id),
    encode.string_field(7, statusresponse.poller_id),
  ])
}

pub fn encode_resultsrequest(resultsrequest: ResultsRequest) -> BitArray {
  encode.message([
    encode.string_field(1, resultsrequest.service_name),
    encode.string_field(2, resultsrequest.service_type),
    encode.string_field(3, resultsrequest.agent_id),
    encode.string_field(4, resultsrequest.poller_id),
    encode.string_field(5, resultsrequest.details),
    encode.string_field(6, resultsrequest.last_sequence),
    encode.field(7, wire.LengthDelimited, encode.length_delimited(encode_sweepcompletionstatus(resultsrequest.completion_status))),
  ])
}

pub fn encode_statusrequest(statusrequest: StatusRequest) -> BitArray {
  encode.message([
    encode.string_field(1, statusrequest.service_name),
    encode.string_field(2, statusrequest.service_type),
    encode.string_field(3, statusrequest.agent_id),
    encode.string_field(4, statusrequest.poller_id),
    encode.string_field(5, statusrequest.details),
    encode.int32_field(6, statusrequest.port),
  ])
}

pub fn encode_devicestatusrequest(devicestatusrequest: DeviceStatusRequest) -> BitArray {
  encode.message([
    encode.string_field(1, devicestatusrequest.agent_id),
  ])
}

pub fn pollerstatuschunk_decoder() -> decode.Decoder(PollerStatusChunk) {
  use services <- decode.then(decode.repeated_field(1, fn(field) { decode.message_field(_, servicestatus_decoder())(field) }))
  use poller_id <- decode.then(decode.string_with_default(2, ""))
  use agent_id <- decode.then(decode.string_with_default(3, ""))
  use timestamp <- decode.then(decode.int64_with_default(4, 0))
  use partition <- decode.then(decode.string_with_default(5, ""))
  use source_ip <- decode.then(decode.string_with_default(6, ""))
  use is_final <- decode.then(decode.bool_with_default(7, False))
  use chunk_index <- decode.then(decode.int32_with_default(8, 0))
  use total_chunks <- decode.then(decode.int32_with_default(9, 0))
  use kv_store_id <- decode.then(decode.string_with_default(10, ""))
  decode.success(PollerStatusChunk(
    services: services,
    poller_id: poller_id,
    agent_id: agent_id,
    timestamp: timestamp,
    partition: partition,
    source_ip: source_ip,
    is_final: is_final,
    chunk_index: chunk_index,
    total_chunks: total_chunks,
    kv_store_id: kv_store_id,
  ))
}

pub fn decode_pollerstatuschunk(data: BitArray) -> Result(PollerStatusChunk, List(decode.DecodeError)) {
  decode.run(data, pollerstatuschunk_decoder())
}

pub fn sweepcompletionstatus_decoder() -> decode.Decoder(SweepCompletionStatus) {
  use status <- decode.then(decode_sweepstatus_field(1))
  use completion_time <- decode.then(decode.int64_with_default(2, 0))
  use target_sequence <- decode.then(decode.string_with_default(3, ""))
  use total_targets <- decode.then(decode.int32_with_default(4, 0))
  use completed_targets <- decode.then(decode.int32_with_default(5, 0))
  use error_message <- decode.then(decode.string_with_default(6, ""))
  decode.success(SweepCompletionStatus(
    status: status,
    completion_time: completion_time,
    target_sequence: target_sequence,
    total_targets: total_targets,
    completed_targets: completed_targets,
    error_message: error_message,
  ))
}

pub fn decode_sweepcompletionstatus(data: BitArray) -> Result(SweepCompletionStatus, List(decode.DecodeError)) {
  decode.run(data, sweepcompletionstatus_decoder())
}

pub fn resultschunk_decoder() -> decode.Decoder(ResultsChunk) {
  use data <- decode.then(decode.bytes(1))
  use is_final <- decode.then(decode.bool_with_default(2, False))
  use chunk_index <- decode.then(decode.int32_with_default(3, 0))
  use total_chunks <- decode.then(decode.int32_with_default(4, 0))
  use current_sequence <- decode.then(decode.string_with_default(5, ""))
  use timestamp <- decode.then(decode.int64_with_default(6, 0))
  decode.success(ResultsChunk(
    data: data,
    is_final: is_final,
    chunk_index: chunk_index,
    total_chunks: total_chunks,
    current_sequence: current_sequence,
    timestamp: timestamp,
  ))
}

pub fn decode_resultschunk(data: BitArray) -> Result(ResultsChunk, List(decode.DecodeError)) {
  decode.run(data, resultschunk_decoder())
}

pub fn portstatus_decoder() -> decode.Decoder(PortStatus) {
  use port <- decode.then(decode.int32_with_default(1, 0))
  use available <- decode.then(decode.int32_with_default(2, 0))
  decode.success(PortStatus(port: port, available: available))
}

pub fn decode_portstatus(data: BitArray) -> Result(PortStatus, List(decode.DecodeError)) {
  decode.run(data, portstatus_decoder())
}

pub fn sweepservicestatus_decoder() -> decode.Decoder(SweepServiceStatus) {
  use network <- decode.then(decode.string_with_default(1, ""))
  use total_hosts <- decode.then(decode.int32_with_default(2, 0))
  use available_hosts <- decode.then(decode.int32_with_default(3, 0))
  use ports <- decode.then(decode.repeated_field(4, fn(field) { decode.message_field(_, portstatus_decoder())(field) }))
  use last_sweep <- decode.then(decode.int64_with_default(5, 0))
  decode.success(SweepServiceStatus(
    network: network,
    total_hosts: total_hosts,
    available_hosts: available_hosts,
    ports: ports,
    last_sweep: last_sweep,
  ))
}

pub fn decode_sweepservicestatus(data: BitArray) -> Result(SweepServiceStatus, List(decode.DecodeError)) {
  decode.run(data, sweepservicestatus_decoder())
}

pub fn servicestatus_decoder() -> decode.Decoder(ServiceStatus) {
  use service_name <- decode.then(decode.string_with_default(1, ""))
  use available <- decode.then(decode.bool_with_default(2, False))
  use message <- decode.then(decode.bytes(3))
  use service_type <- decode.then(decode.string_with_default(4, ""))
  use response_time <- decode.then(decode.int64_with_default(5, 0))
  use agent_id <- decode.then(decode.string_with_default(6, ""))
  use poller_id <- decode.then(decode.string_with_default(7, ""))
  use partition <- decode.then(decode.string_with_default(8, ""))
  use source <- decode.then(decode.string_with_default(9, ""))
  use kv_store_id <- decode.then(decode.string_with_default(10, ""))
  decode.success(ServiceStatus(
    service_name: service_name,
    available: available,
    message: message,
    service_type: service_type,
    response_time: response_time,
    agent_id: agent_id,
    poller_id: poller_id,
    partition: partition,
    source: source,
    kv_store_id: kv_store_id,
  ))
}

pub fn decode_servicestatus(data: BitArray) -> Result(ServiceStatus, List(decode.DecodeError)) {
  decode.run(data, servicestatus_decoder())
}

pub fn pollerstatusresponse_decoder() -> decode.Decoder(PollerStatusResponse) {
  use received <- decode.then(decode.bool_with_default(1, False))
  decode.success(PollerStatusResponse(received: received))
}

pub fn decode_pollerstatusresponse(data: BitArray) -> Result(PollerStatusResponse, List(decode.DecodeError)) {
  decode.run(data, pollerstatusresponse_decoder())
}

pub fn pollerstatusrequest_decoder() -> decode.Decoder(PollerStatusRequest) {
  use services <- decode.then(decode.repeated_field(1, fn(field) { decode.message_field(_, servicestatus_decoder())(field) }))
  use poller_id <- decode.then(decode.string_with_default(2, ""))
  use agent_id <- decode.then(decode.string_with_default(3, ""))
  use timestamp <- decode.then(decode.int64_with_default(4, 0))
  use partition <- decode.then(decode.string_with_default(5, ""))
  use source_ip <- decode.then(decode.string_with_default(6, ""))
  use kv_store_id <- decode.then(decode.string_with_default(7, ""))
  decode.success(PollerStatusRequest(
    services: services,
    poller_id: poller_id,
    agent_id: agent_id,
    timestamp: timestamp,
    partition: partition,
    source_ip: source_ip,
    kv_store_id: kv_store_id,
  ))
}

pub fn decode_pollerstatusrequest(data: BitArray) -> Result(PollerStatusRequest, List(decode.DecodeError)) {
  decode.run(data, pollerstatusrequest_decoder())
}

pub fn resultsresponse_decoder() -> decode.Decoder(ResultsResponse) {
  use available <- decode.then(decode.bool_with_default(1, False))
  use data <- decode.then(decode.bytes(2))
  use service_name <- decode.then(decode.string_with_default(3, ""))
  use service_type <- decode.then(decode.string_with_default(4, ""))
  use response_time <- decode.then(decode.int64_with_default(5, 0))
  use agent_id <- decode.then(decode.string_with_default(6, ""))
  use poller_id <- decode.then(decode.string_with_default(7, ""))
  use timestamp <- decode.then(decode.int64_with_default(8, 0))
  use current_sequence <- decode.then(decode.string_with_default(9, ""))
  use has_new_data <- decode.then(decode.bool_with_default(10, False))
  use sweep_completion <- decode.then(decode.nested_message(11, sweepcompletionstatus_decoder()))
  decode.success(ResultsResponse(
    available: available,
    data: data,
    service_name: service_name,
    service_type: service_type,
    response_time: response_time,
    agent_id: agent_id,
    poller_id: poller_id,
    timestamp: timestamp,
    current_sequence: current_sequence,
    has_new_data: has_new_data,
    sweep_completion: sweep_completion,
  ))
}

pub fn decode_resultsresponse(data: BitArray) -> Result(ResultsResponse, List(decode.DecodeError)) {
  decode.run(data, resultsresponse_decoder())
}

pub fn statusresponse_decoder() -> decode.Decoder(StatusResponse) {
  use available <- decode.then(decode.bool_with_default(1, False))
  use message <- decode.then(decode.bytes(2))
  use service_name <- decode.then(decode.string_with_default(3, ""))
  use service_type <- decode.then(decode.string_with_default(4, ""))
  use response_time <- decode.then(decode.int64_with_default(5, 0))
  use agent_id <- decode.then(decode.string_with_default(6, ""))
  use poller_id <- decode.then(decode.string_with_default(7, ""))
  decode.success(StatusResponse(
    available: available,
    message: message,
    service_name: service_name,
    service_type: service_type,
    response_time: response_time,
    agent_id: agent_id,
    poller_id: poller_id,
  ))
}

pub fn decode_statusresponse(data: BitArray) -> Result(StatusResponse, List(decode.DecodeError)) {
  decode.run(data, statusresponse_decoder())
}

pub fn resultsrequest_decoder() -> decode.Decoder(ResultsRequest) {
  use service_name <- decode.then(decode.string_with_default(1, ""))
  use service_type <- decode.then(decode.string_with_default(2, ""))
  use agent_id <- decode.then(decode.string_with_default(3, ""))
  use poller_id <- decode.then(decode.string_with_default(4, ""))
  use details <- decode.then(decode.string_with_default(5, ""))
  use last_sequence <- decode.then(decode.string_with_default(6, ""))
  use completion_status <- decode.then(decode.nested_message(7, sweepcompletionstatus_decoder()))
  decode.success(ResultsRequest(
    service_name: service_name,
    service_type: service_type,
    agent_id: agent_id,
    poller_id: poller_id,
    details: details,
    last_sequence: last_sequence,
    completion_status: completion_status,
  ))
}

pub fn decode_resultsrequest(data: BitArray) -> Result(ResultsRequest, List(decode.DecodeError)) {
  decode.run(data, resultsrequest_decoder())
}

pub fn statusrequest_decoder() -> decode.Decoder(StatusRequest) {
  use service_name <- decode.then(decode.string_with_default(1, ""))
  use service_type <- decode.then(decode.string_with_default(2, ""))
  use agent_id <- decode.then(decode.string_with_default(3, ""))
  use poller_id <- decode.then(decode.string_with_default(4, ""))
  use details <- decode.then(decode.string_with_default(5, ""))
  use port <- decode.then(decode.int32_with_default(6, 0))
  decode.success(StatusRequest(
    service_name: service_name,
    service_type: service_type,
    agent_id: agent_id,
    poller_id: poller_id,
    details: details,
    port: port,
  ))
}

pub fn decode_statusrequest(data: BitArray) -> Result(StatusRequest, List(decode.DecodeError)) {
  decode.run(data, statusrequest_decoder())
}

pub fn devicestatusrequest_decoder() -> decode.Decoder(DeviceStatusRequest) {
  use agent_id <- decode.then(decode.string_with_default(1, ""))
  decode.success(DeviceStatusRequest(agent_id: agent_id))
}

pub fn decode_devicestatusrequest(data: BitArray) -> Result(DeviceStatusRequest, List(decode.DecodeError)) {
  decode.run(data, devicestatusrequest_decoder())
}

pub fn encode_sweepstatus_value(value: SweepStatus) -> Int {
  case value {
    UNKNOWN -> 0
    NOTSTARTED -> 1
    INPROGRESS -> 2
    COMPLETED -> 3
    FAILED -> 4
  }
}

pub fn decode_sweepstatus_field(field_num: Int) -> decode.Decoder(SweepStatus) {
  decode.field(field_num, fn(field) {
    use value <- result.try(decode.int32_field(field))
    case value {
          0 -> Ok(UNKNOWN)
          1 -> Ok(NOTSTARTED)
          2 -> Ok(INPROGRESS)
          3 -> Ok(COMPLETED)
          4 -> Ok(FAILED)
      _ -> Error(decode.DecodeError(expected: "valid sweepstatus value", found: "Unknown sweepstatus value: " <> string.inspect(value), path: []))
    }
  })
}

fn decode_sweepstatus_from_field(field: decode.Field) -> Result(SweepStatus, decode.DecodeError) {
  use value <- result.try(decode.int32_field(field))
  case value {
      0 -> Ok(UNKNOWN)
      1 -> Ok(NOTSTARTED)
      2 -> Ok(INPROGRESS)
      3 -> Ok(COMPLETED)
      4 -> Ok(FAILED)
    _ -> Error(decode.DecodeError(expected: "valid sweepstatus value", found: "Unknown sweepstatus value: " <> string.inspect(value), path: []))
  }
}

pub fn decode_sweepstatus_value(value: Int) -> Result(SweepStatus, String) {
  case value {
    0 -> Ok(UNKNOWN)
    1 -> Ok(NOTSTARTED)
    2 -> Ok(INPROGRESS)
    3 -> Ok(COMPLETED)
    4 -> Ok(FAILED)
    _ -> Error("Unknown sweepstatus value: " <> int.to_string(value))
  }
}

pub fn decode_repeated_sweepstatus(field_num: Int) -> decode.Decoder(List(SweepStatus)) {
  decode.repeated_field(field_num, fn(field) {
    use value <- result.try(decode.int32_field(field))
    decode_sweepstatus_value(value)
    |> result.map_error(fn(err) { decode.DecodeError(expected: "sweepstatus", found: err, path: []) })
  })
}

// Service: AgentService

/// Client interface for AgentService service
/// This trait defines the client-side methods for calling the service
pub type AgentServiceClient {
  AgentServiceClient(
    // TODO: Add client implementation fields (e.g., HTTP client, endpoint URL)
    endpoint: String,
  )
}

// Method signatures for client:
  // GetStatus(StatusRequest) -> StatusResponse // Unary call
  // GetResults(ResultsRequest) -> ResultsResponse // Unary call
  // StreamResults(ResultsRequest) -> ResultsChunk // Server streaming
// TODO: Implement actual client method calls

/// Server interface for AgentService service
/// Implement this trait to handle incoming service requests
pub type AgentServiceServer {
  AgentServiceServer(
    // TODO: Add server implementation fields
  )
}

// Method signatures for server:
  // GetStatus(StatusRequest) -> StatusResponse // Unary handler
  // GetResults(ResultsRequest) -> ResultsResponse // Unary handler
  // StreamResults(ResultsRequest) -> ResultsChunk // Server streaming handler
// TODO: Implement server method handlers and request routing

// Service: PollerService

/// Client interface for PollerService service
/// This trait defines the client-side methods for calling the service
pub type PollerServiceClient {
  PollerServiceClient(
    // TODO: Add client implementation fields (e.g., HTTP client, endpoint URL)
    endpoint: String,
  )
}

// Method signatures for client:
  // ReportStatus(PollerStatusRequest) -> PollerStatusResponse // Unary call
  // StreamStatus(PollerStatusChunk) -> PollerStatusResponse // Client streaming
// TODO: Implement actual client method calls

/// Server interface for PollerService service
/// Implement this trait to handle incoming service requests
pub type PollerServiceServer {
  PollerServiceServer(
    // TODO: Add server implementation fields
  )
}

// Method signatures for server:
  // ReportStatus(PollerStatusRequest) -> PollerStatusResponse // Unary handler
  // StreamStatus(PollerStatusChunk) -> PollerStatusResponse // Client streaming handler
// TODO: Implement server method handlers and request routing