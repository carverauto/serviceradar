# base/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: serviceradar-config
data:
  nginx.conf: |
    # ServiceRadar Web Interface - Nginx (Kubernetes)
    server {
      listen 80;
      server_name _;

      client_max_body_size 100M;

      # Static assets
      location /_next/ {
        proxy_pass http://serviceradar-web:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
      }

      # Next.js API routes (keep hitting web)
      location ~ ^/api/(auth|nodes|status|pollers|devices|mcp) {
        proxy_pass http://serviceradar-web:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
      }

      # Swagger/UI (direct to core)
      location /swagger/ {
        proxy_pass http://serviceradar-core:8090;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
      }
      location = /api-docs { proxy_pass http://serviceradar-core:8090; }

      # Backend API (direct to Core)
      location /api/ {
        proxy_pass http://serviceradar-core:8090;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
      }

      # Auth is public, direct to core
      location /auth/ {
        proxy_pass http://serviceradar-core:8090;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
      }

      # Main app
      location / {
        proxy_pass http://serviceradar-web:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
      }
    }
  core.json: |
    {
      "listen_addr": ":8090",
      "grpc_addr": ":50052",
      "database": {
        "addresses": [
          "serviceradar-proton:9440"
        ],
        "name": "default",
        "username": "default",
        "password": "",
        "max_conns": 10,
        "idle_conns": 5,
        "tls": {
          "cert_file": "/etc/serviceradar/certs/core.pem",
          "key_file": "/etc/serviceradar/certs/core-key.pem",
          "ca_file": "/etc/serviceradar/certs/root.pem",
          "server_name": "proton.serviceradar"
        },
        "settings": {
          "max_execution_time": 60,
          "output_format_json_quote_64bit_int": 0,
          "allow_experimental_live_view": 1,
          "idle_connection_timeout": 600,
          "join_use_nulls": 1,
          "input_format_defaults_for_omitted_fields": 1
        }
      },
      "alert_threshold": "5m",
      "known_pollers": ["k8s-poller"],
      "metrics": {
      "enabled": true,
      "retention": 100,
      "max_nodes": 10000
        },
        "security": {
          "mode": "mtls",
          "cert_dir": "/etc/serviceradar/certs",
          "role": "core",
          "server_name": "proton.serviceradar",
          "tls": {
            "cert_file": "/etc/serviceradar/certs/core.pem",
            "key_file": "/etc/serviceradar/certs/core-key.pem",
            "ca_file": "/etc/serviceradar/certs/root.pem",
            "client_ca_file": "/etc/serviceradar/certs/root.pem",
            "skip_verify": false
          }
        },
        "cors": {
          "allowed_origins": [
            "*"
          ],
          "allow_credentials": true
        },
        "auth": {
          "jwt_secret": "PLACEHOLDER_WILL_BE_REPLACED",
          "jwt_expiration": "24h",
          "local_users": {
            "admin": "PLACEHOLDER_BCRYPT_HASH_WILL_BE_REPLACED"
          }
        },
        "nats": {
          "url": "tls://serviceradar-nats:4222",
          "max_reconnects": 10,
          "reconnect_wait": "2s",
          "drain_timeout": "30s"
        },
        "snmp": {
          "enabled": false,
          "listen_addr": ":161",
          "community": "public",
          "timeout": "5s",
          "retries": 3
        },
        "write_buffer": {
          "size": 10000,
          "flush_interval": "5s",
          "max_retries": 3,
          "retry_delay": "1s"
        },
        "logging": {
          "level": "info",
          "debug": false,
          "output": "stdout",
          "time_format": "",
          "otel": {
            "enabled": true,
            "endpoint": "serviceradar-otel:4317",
            "service_name": "serviceradar-core",
            "batch_timeout": "5s",
            "insecure": false,
            "headers": {},
            "tls": {
              "cert_file": "/etc/serviceradar/certs/core.pem",
              "key_file": "/etc/serviceradar/certs/core-key.pem",
              "ca_file": "/etc/serviceradar/certs/root.pem",
              "server_name": "serviceradar-otel",
              "skip_verify": false
            }
          }
        },
        "webhooks": [
          {
            "enabled": false,
            "url": "https://your-webhook-url",
            "cooldown": "15m",
            "headers": [
              {
                "key": "Authorization",
                "value": "Bearer your-token"
              }
            ]
          },
          {
            "enabled": false,
            "url": "https://discord.com/api/webhooks/PLACEHOLDER_WEBHOOK_URL",
            "cooldown": "15m",
            "template": "{\"embeds\":[{\"title\":\"{{.alert.Title}}\",\"description\":\"{{.alert.Message}}\",\"color\":{{if eq .alert.Level \"error\"}}15158332{{else if eq .alert.Level \"warning\"}}16776960{{else}}3447003{{end}},\"timestamp\":\"{{.alert.Timestamp}}\",\"fields\":[{\"name\":\"Node ID\",\"value\":\"{{.alert.NodeID}}\",\"inline\":true}{{range $key, $value := .alert.Details}},{\"name\":\"{{$key}}\",\"value\":\"{{$value}}\",\"inline\":true}{{end}}]}]}"
          }
        ]
    }

  poller.json: |
    {
      "agents": {
        "k8s-agent": {
          "address": "serviceradar-agent:50051",
          "security": {
            "server_name": "agent.serviceradar",
            "mode": "mtls",
            "cert_dir": "/etc/serviceradar/certs",
            "role": "poller",
            "tls": {
              "cert_file": "poller.pem",
              "key_file": "poller-key.pem",
              "ca_file": "root.pem",
              "client_ca_file": "root.pem"
            }
          },
          "checks": [
            { "service_type": "process", "service_name": "serviceradar-agent", "details": "serviceradar-agent" },
            { "service_type": "port",    "service_name": "SSH",               "details": "serviceradar-agent:22" },
            { "service_type": "icmp",    "service_name": "ping",              "details": "8.8.8.8" },
            { "service_type": "sweep",   "service_name": "network_sweep",     "details": "", "results_interval": "2m" },
            { "service_type": "grpc",    "service_name": "rperf-checker",     "details": "serviceradar-rperf:50081" },
            { "service_type": "grpc",    "service_name": "mapper",            "details": "serviceradar-mapper:50056" },
            { "service_type": "grpc",    "service_name": "db-event-writer",   "details": "serviceradar-db-event-writer:50041" },
            { "service_type": "grpc",    "service_name": "zen",               "details": "serviceradar-zen:50040" },
            { "service_type": "grpc",    "service_name": "trapd",             "details": "serviceradar-trapd:50043" },
            { "service_type": "grpc",    "service_name": "flowgger",          "details": "serviceradar-flowgger:50044" },
            { "service_type": "grpc",    "service_name": "sync",              "details": "serviceradar-sync:50058", "results_interval": "30s" },
            { "service_type": "grpc",    "service_name": "kv",                "details": "serviceradar-kv:50057" },
            { "service_type": "grpc",    "service_name": "nats",              "details": "serviceradar-nats:4222" }
          ]
        }
      },
      "core_address": "serviceradar-core:50052",
      "core_security": {
        "mode": "mtls",
        "cert_dir": "/etc/serviceradar/certs",
        "server_name": "core.serviceradar",
        "role": "poller",
        "tls": {
          "cert_file": "poller.pem",
          "key_file": "poller-key.pem",
          "ca_file": "root.pem"
        }
      },
      "listen_addr": ":50053",
      "poll_interval": "30s",
      "poller_id": "k8s-poller",
      "partition": "default",
      "source_ip": "poller",
      "service_name": "PollerService",
      "service_type": "grpc",
      "security": {
        "mode": "mtls",
        "cert_dir": "/etc/serviceradar/certs",
        "role": "poller",
        "tls": {
          "cert_file": "poller.pem",
          "key_file": "poller-key.pem",
          "ca_file": "root.pem",
          "client_ca_file": "root.pem"
        }
      },
      "logging": {
        "level": "info",
        "debug": false,
        "output": "stdout",
        "time_format": "",
        "otel": {
          "enabled": true,
          "endpoint": "serviceradar-otel:4317",
          "service_name": "serviceradar-poller",
          "batch_timeout": "5s",
          "insecure": false,
          "headers": {
            "x-api-key": "your-collector-api-key"
          },
          "tls": {
            "cert_file": "/etc/serviceradar/certs/poller.pem",
            "key_file": "/etc/serviceradar/certs/poller-key.pem",
            "ca_file": "/etc/serviceradar/certs/root.pem",
            "server_name": "serviceradar-otel"
          }
        }
      }
    }

  agent.json: |
    {
      "checkers_dir": "/etc/serviceradar/checkers",
      "listen_addr": ":50051",
      "service_type": "grpc",
      "service_name": "AgentService",
      "agent_id": "k8s-agent",
      "agent_name": "agent",
      "host_ip": "agent",
      "partition": "default",
      "kv_address": "serviceradar-kv:50057",
      "kv_security": {
        "mode": "mtls",
        "cert_dir": "/etc/serviceradar/certs",
        "server_name": "kv.serviceradar",
        "role": "agent",
        "tls": {
          "cert_file": "agent.pem",
          "key_file": "agent-key.pem",
          "ca_file": "root.pem"
        }
      },
      "security": {
        "mode": "mtls",
        "cert_dir": "/etc/serviceradar/certs",
        "server_name": "agent.serviceradar",
        "role": "agent",
        "tls": {
          "cert_file": "agent.pem",
          "key_file": "agent-key.pem",
          "ca_file": "root.pem"
        }
      },
      "logging": {
        "level": "info",
        "debug": false,
        "output": "stdout",
        "time_format": "",
        "otel": {
          "enabled": false
        }
      }
    }

  sweep.json: |
    {
      "networks": [
          "192.168.2.0/24",
          "192.168.3.1/32"
      ],
      "ports": [
        22,
        80,
        443,
        3306,
        5432,
        6379,
        8080,
        8443
      ],
      "sweep_modes": [
        "icmp",
        "tcp"
      ],
      "interval": "5m",
      "concurrency": 100,
      "timeout": "10s",
      "tcp_settings": {
        "rate_limit": 20000,
        "rate_limit_burst": 20000,
        "max_batch": 32,
        "concurrency": 256,
        "timeout": "3s"
      },
      "high_perf_icmp": true,
      "icmp_rate_limit": 5000,
      "icmp_settings": {
        "rate_limit": 1000,
        "timeout": "5s",
        "max_batch": 64
      }
    } 

  external.json: |
    {
      "enabled": true
    }

  zen.json: |
    {
      "nats_url": "tls://serviceradar-nats:4222",
      "stream_name": "events",
      "consumer_name": "zen-consumer",
      "subjects": ["events.syslog", "events.snmp", "events.otel.logs"],
      "decision_groups": [
        {
          "name": "syslog",
          "subjects": ["events.syslog"],
          "rules": [
            {"order": 1, "key": "strip_full_message"},
            {"order": 2, "key": "cef_severity"}
          ],
          "format": "json"
        },
        {
          "name": "snmp",
          "subjects": ["events.snmp"],
          "rules": [
            {"order": 1, "key": "snmp_severity"}
          ],
          "format": "json"
        },
        {
          "name": "otel_logs",
          "subjects": ["events.otel.logs"],
          "rules": [
            {"order": 1, "key": "passthrough"}
          ],
          "format": "protobuf"
        }
      ],
      "agent_id": "k8s-zen-consumer",
      "kv_address": "serviceradar-kv:50057",
      "kv_bucket": "serviceradar-kv",
      "listen_addr": "0.0.0.0:50040",
      "result_subject_suffix": ".processed",
      "security": {
        "cert_file": "/etc/serviceradar/certs/zen.pem",
        "key_file": "/etc/serviceradar/certs/zen-key.pem",
        "ca_file": "/etc/serviceradar/certs/root.pem"
      },
      "grpc_security": {
        "cert_file": "/etc/serviceradar/certs/zen.pem",
        "key_file": "/etc/serviceradar/certs/zen-key.pem",
        "ca_file": "/etc/serviceradar/certs/root.pem"
      },
      "kv_security": {
        "mode": "mtls",
        "cert_dir": "/etc/serviceradar/certs",
        "server_name": "kv.serviceradar",
        "role": "zen",
        "tls": {
          "cert_file": "zen.pem",
          "key_file": "zen-key.pem",
          "ca_file": "root.pem"
        }
      },
      "logging": {
        "level": "info",
        "debug": false,
        "output": "stdout",
        "time_format": "",
        "otel": {
          "enabled": true,
          "endpoint": "serviceradar-otel:4317",
          "service_name": "serviceradar-zen",
          "batch_timeout": "5s",
          "insecure": false,
          "headers": {},
          "tls": {
            "cert_file": "/etc/serviceradar/certs/zen.pem",
            "key_file": "/etc/serviceradar/certs/zen-key.pem",
            "ca_file": "/etc/serviceradar/certs/root.pem",
            "server_name": "serviceradar-otel"
          }
        }
      }
    }

  snmp.json: |
    {
      "node_address": "localhost:50051",
      "listen_addr": ":50054",
      "partition": "k8s",
      "security": {
        "server_name": "serviceradar-demo",
        "mode": "none",
        "role": "checker",
        "cert_dir": "/etc/serviceradar/certs"
      },
      "timeout": "30s",
      "targets": [
        {
          "name": "test-router",
          "host": "192.168.1.1",
          "port": 161,
          "community": "public",
          "version": "v2c",
          "interval": "30s",
          "retries": 2,
          "oids": [
            {
              "oid": ".1.3.6.1.2.1.2.2.1.10.4",
              "name": "ifInOctets_4",
              "type": "counter",
              "scale": 1.0
            }
          ]
        }
      ]
    }

  sync.json: |
    {
      "kv_address": "serviceradar-kv:50057",
      "listen_addr": ":50058",
      "poll_interval": "5m",
      "discovery_interval": "5m",
      "update_interval": "10m",
      "agent_id": "k8s-agent",
      "poller_id": "k8s-poller",
      "nats_url": "tls://serviceradar-nats:4222",
      "security": {
        "mode": "mtls",
        "cert_dir": "/etc/serviceradar/certs",
        "server_name": "kv.serviceradar",
        "role": "poller",
        "tls": {
          "cert_file": "sync.pem",
          "key_file": "sync-key.pem",
          "ca_file": "root.pem",
          "client_ca_file": "root.pem"
        }
      },
      "nats_security": {
        "mode": "mtls",
        "cert_dir": "/etc/serviceradar/certs",
        "server_name": "nats.serviceradar",
        "role": "poller",
        "tls": {
          "cert_file": "sync.pem",
          "key_file": "sync-key.pem",
          "ca_file": "root.pem",
          "client_ca_file": "root.pem"
        }
      },
      "sources": {
        "armis": {
          "type": "armis",
          "endpoint": "http://serviceradar-faker:8080",
          "prefix": "armis/",
          "poll_interval": "5m",
          "sweep_interval": "5m",
          "agent_id": "k8s-agent",
          "poller_id": "k8s-poller",
          "partition": "default",
          "credentials": {
            "username": "test",
            "password": "test"
          },
          "page_size": 1000,
          "network_blacklist": [],
          "queries": [
            {
              "label": "all_devices",
              "query": "in:devices",
              "sweep_modes": ["icmp", "tcp"]
            }
          ]
        }
      },
      "logging": {
        "level": "debug",
        "debug": true,
        "output": "stdout",
        "time_format": "",
        "otel": {
          "enabled": true,
          "endpoint": "serviceradar-otel:4317",
          "service_name": "serviceradar-sync",
          "batch_timeout": "5s",
          "insecure": false,
          "headers": {},
          "tls": {
            "cert_file": "/etc/serviceradar/certs/sync.pem",
            "key_file": "/etc/serviceradar/certs/sync-key.pem",
            "ca_file": "/etc/serviceradar/certs/root.pem"
          }
        }
      }
    }

  rperf.json: |
    {
      "listen_addr": "0.0.0.0:50081",
      "name": "rperf-checker",
      "type": "grpc",
      "timeout": "30s",
      "security": {
        "tls_enabled": true,
        "cert_file": "/etc/serviceradar/certs/rperf-client.pem",
        "key_file": "/etc/serviceradar/certs/rperf-client-key.pem",
        "ca_file": "/etc/serviceradar/certs/root.pem"
      },
      "default_poll_interval": 300,
      "targets": []
    }

  proton-logger.xml: |
    <?xml version="1.0"?>
    <proton>
        <logger>
            <level>error</level>
            <console>1</console>
            <log remove="remove"/>
            <errorlog remove="remove"/>
        </logger>
    </proton>

  proton-k8s-init.sh: |
    #!/bin/bash
    set -e
    
    echo "[Proton K8s Init] Starting Kubernetes-specific initialization with TLS"
    
    # Wait for certificates to be available
    echo "[Proton K8s Init] Waiting for TLS certificates..."
    timeout=300
    count=0
    while [ ! -f /etc/serviceradar/certs/proton.pem ] || [ ! -f /etc/serviceradar/certs/root.pem ]; do
      if [ $count -ge $timeout ]; then
        echo "[Proton K8s Init] ERROR: Timeout waiting for certificates"
        exit 1
      fi
      echo "[Proton K8s Init] Waiting for certificates... ($count/$timeout)"
      sleep 1
      count=$((count + 1))
    done
    echo "[Proton K8s Init] Certificates found!"
    
    # Create proton-server certs directory and link certificates  
    mkdir -p /etc/proton-server/certs
    ln -sf /etc/serviceradar/certs/proton.pem /etc/proton-server/certs/proton.pem
    ln -sf /etc/serviceradar/certs/proton-key.pem /etc/proton-server/certs/proton-key.pem
    ln -sf /etc/serviceradar/certs/root.pem /etc/proton-server/certs/root.pem
    
    # Generate DH parameters if not present (for SSL security)
    echo "[Proton K8s Init] Checking DH parameters..."
    if [ ! -f "/etc/proton-server/dhparam.pem" ]; then
        echo "[Proton K8s Init] Generating DH parameters (this may take a few minutes for security)..."
        openssl dhparam -out /etc/proton-server/dhparam.pem 2048
        chmod 644 /etc/proton-server/dhparam.pem
        echo "[Proton K8s Init] DH parameters generated successfully"
    else
        echo "[Proton K8s Init] DH parameters already exist"
    fi
    
    # Run only the setup parts of the original init script  
    cp /usr/local/bin/proton-init.sh /tmp/proton-init-original.sh
    sed -i '/^ulimit/d' /tmp/proton-init-original.sh
    sed -i '/exec.*proton/d' /tmp/proton-init-original.sh
    chmod +x /tmp/proton-init-original.sh
    
    echo "[Proton K8s Init] Running setup portions only (no server start)"
    /tmp/proton-init-original.sh
    
    # Generate password if not provided
    if [ -z "$PROTON_PASSWORD" ]; then
        echo "[Proton K8s Init] Generating random password..."
        PROTON_PASSWORD=$(openssl rand -hex 16)
        echo "$PROTON_PASSWORD" > /etc/proton-server/generated_password.txt
        chmod 600 /etc/proton-server/generated_password.txt
        echo "[Proton K8s Init] Generated password saved to /etc/proton-server/generated_password.txt"
        
        # Also save to shared credentials volume for other services
        if [ -d "/etc/serviceradar/credentials" ]; then
            echo "$PROTON_PASSWORD" > /etc/serviceradar/credentials/proton-password
            chmod 644 /etc/serviceradar/credentials/proton-password
            echo "[Proton K8s Init] Password also saved to shared credentials volume"
        fi
    fi
    
    # Create password hash for user config
    PASSWORD_HASH=$(echo -n "$PROTON_PASSWORD" | sha256sum | awk '{print $1}')
    
    # Create user configuration
    echo "[Proton K8s Init] Configuring default user password..."
    mkdir -p /etc/proton-server/users.d
    cat > /etc/proton-server/users.d/default-password.xml << END_OF_XML
    <proton>
        <users>
            <default>
                <password remove='1' />
                <password_sha256_hex>${PASSWORD_HASH}</password_sha256_hex>
                <networks>
                    <ip>0.0.0.0/0</ip>
                </networks>
            </default>
        </users>
    </proton>
    END_OF_XML
    chmod 600 /etc/proton-server/users.d/default-password.xml
    
    echo "[Proton K8s Init] Fixing ownership and starting Proton as proton user"
    chown -R proton:proton /var/lib/proton
    find /etc/proton-server/ -type f ! -path "*/config.d/logger.xml" -exec chown proton:proton {} \;
    find /etc/proton-server/ -type d -exec chown proton:proton {} \;
    
    exec su -s /bin/bash proton -c "/usr/bin/proton server --config-file=/etc/proton-server/config.yaml"

  config.yaml: |
    # Proton Server Configuration for Kubernetes
    logger:
      level: error
      log: /var/log/proton-server/proton-server.log
      errorlog: /var/log/proton-server/proton-server.err.log
      size: 1000M
      count: 10

    # Listen on all interfaces for Kubernetes
    listen_host: 0.0.0.0

    # HTTP port for queries
    snapshot_server_http_port: 8123

    # Native TCP port (non-secure)
    snapshot_server_tcp_port: 8463

    # HTTPS port with TLS
    https_port: 8443

    # Native TCP port with TLS - this is what serviceradar-core connects to
    tcp_port_secure: 9440

    # Enable telemetry (required for MetaStoreServer)
    telemetry_enabled: true
    telemetry_interval_ms: 300000

    # Server settings
    max_connections: 4096
    keep_alive_timeout: 3
    max_thread_pool_size: 10000
    max_server_memory_usage_to_ram_ratio: 0.9

    # Cache settings
    uncompressed_cache_size: 8589934592
    mark_cache_size: 5368709120
    mmap_cache_size: 1000
    compiled_expression_cache_size: 134217728

    # TLS Configuration
    openSSL:
      server:
        # Proton server certificates
        certificateFile: /etc/proton-server/certs/proton.pem
        privateKeyFile: /etc/proton-server/certs/proton-key.pem
        caConfig: /etc/proton-server/certs/root.pem
        verificationMode: relaxed
        loadDefaultCAFile: false
        cacheSessions: false
        disableProtocols: 'sslv2,sslv3'
        preferServerCiphers: true
      client:
        loadDefaultCAFile: true
        cacheSessions: true
        disableProtocols: 'sslv2,sslv3'
        preferServerCiphers: true
        invalidCertificateHandler:
          name: AcceptCertificateHandler

    # Path configuration
    path: /var/lib/proton

    # Users and access control
    user_directories:
      users_xml:
        path: /etc/proton-server/users.d/default-password.xml

  openssl.xml: |
    <?xml version="1.0"?>
    <proton>
        <openSSL>
            <server>
                <certificateFile>/etc/proton-server/certs/proton.pem</certificateFile>
                <privateKeyFile>/etc/proton-server/certs/proton-key.pem</privateKeyFile>
                <caConfig>/etc/proton-server/certs/root.pem</caConfig>
                <verificationMode>relaxed</verificationMode>
                <loadDefaultCAFile>false</loadDefaultCAFile>
                <cacheSessions>false</cacheSessions>
                <disableProtocols>sslv2,sslv3</disableProtocols>
                <preferServerCiphers>true</preferServerCiphers>
            </server>
            <client>
                <loadDefaultCAFile>true</loadDefaultCAFile>
                <cacheSessions>true</cacheSessions>
                <disableProtocols>sslv2,sslv3</disableProtocols>
                <preferServerCiphers>true</preferServerCiphers>
                <invalidCertificateHandler>
                    <name>AcceptCertificateHandler</name>
                </invalidCertificateHandler>
            </client>
        </openSSL>
    </proton>

  core-k8s-init.sh: |
    #!/bin/bash
    set -e
    
    echo "ðŸ”‘ Using API_KEY: ${API_KEY:0:8}... (${#API_KEY} chars)"
    echo "ðŸ” Using JWT_SECRET: ${JWT_SECRET:0:8}... (${#JWT_SECRET} chars)"
    
    TEMPLATE_PATH="/etc/serviceradar/core.json"
    CONFIG_PATH="${CONFIG_PATH:-/var/lib/serviceradar/core.json}"
    CONFIG_DIR=$(dirname "$CONFIG_PATH")
    mkdir -p "$CONFIG_DIR"
    if [ ! -f "$CONFIG_PATH" ]; then
        echo "Seeding runtime config from $TEMPLATE_PATH into $CONFIG_PATH"
        cp "$TEMPLATE_PATH" "$CONFIG_PATH"
    fi
    echo "Using runtime configuration at $CONFIG_PATH"
    
    # Get Proton password from Kubernetes secret (loaded as env var)
    if [ -n "$PROTON_PASSWORD" ]; then
        echo "Found Proton password from Kubernetes secret"
    else
        echo "Warning: PROTON_PASSWORD environment variable not found"
    fi
    
    # Update the config file with secrets using jq for in-place editing
    if [ -f "$CONFIG_PATH" ]; then
        echo "Updating configuration with secrets..."

        # Use jq to update the existing config - match production auth format exactly  
        TMP_CONFIG=$(mktemp)
        jq --arg pwd "$PROTON_PASSWORD" \
           --arg jwt "$JWT_SECRET" \
           --arg api_key "$API_KEY" \
           --arg bcrypt "$ADMIN_BCRYPT_HASH" \
           '.database.password = $pwd | .auth.jwt_secret = $jwt | .auth.jwt_expiration = "24h" | .auth.local_users.admin = $bcrypt | .api_key = $api_key' \
           "$CONFIG_PATH" > "$TMP_CONFIG"
        mv "$TMP_CONFIG" "$CONFIG_PATH"
        echo "Configuration updated with secrets at $CONFIG_PATH"

        if ! jq -e '.auth.jwt_private_key_pem // empty' "$CONFIG_PATH" >/dev/null 2>&1; then
            echo "Warning: RS256 key material missing from $CONFIG_PATH; Core JWKS will be empty" >&2
        fi
    fi

    # Wait for Proton to be ready
    if [ "${WAIT_FOR_PROTON:-false}" = "true" ]; then
        PROTON_TLS_ADDR="${PROTON_HOST:-serviceradar-proton}:9440"
        PROTON_HTTP_ADDR="${PROTON_HOST:-serviceradar-proton}:8123"
        echo "Waiting for Proton TLS port at $PROTON_TLS_ADDR..."
        for i in {1..30}; do
            # First check if TLS port is listening (using openssl to test TLS connectivity)
            if echo "QUIT" | openssl s_client -connect $PROTON_TLS_ADDR -cert /etc/serviceradar/certs/core.pem -key /etc/serviceradar/certs/core-key.pem -CAfile /etc/serviceradar/certs/root.pem -servername proton.serviceradar -quiet > /dev/null 2>&1; then
                echo "Proton TLS port is ready!"
                # Also verify HTTP for initialization queries (optional)
                if [ -n "$PROTON_PASSWORD" ]; then
                    if curl -sf "http://default:${PROTON_PASSWORD}@$PROTON_HTTP_ADDR/?query=SELECT%201" > /dev/null 2>&1; then
                        echo "Proton HTTP authentication is working!"
                    else
                        echo "TLS is working, HTTP auth may not be ready yet but proceeding..."
                    fi
                else
                    echo "Warning: No password found for Proton authentication"
                fi
                break
            fi
            echo "Waiting for Proton TLS... ($i/30)"
            sleep 2
        done
    fi
    
    # Initialize database if requested
    if [ "${INIT_DB:-false}" = "true" ]; then
        echo "Initializing database tables..."
    fi
    
    echo "ðŸ” Final environment check:"
    echo "  API_KEY: ${API_KEY:0:8}... (${#API_KEY} chars)"
    echo "  JWT_SECRET: ${JWT_SECRET:0:8}... (${#JWT_SECRET} chars)"
    echo "  AUTH_ENABLED: ${AUTH_ENABLED:-true}"
    
    # Start the core service
    exec /usr/local/bin/serviceradar-core --config="$CONFIG_PATH"
  nats.conf: |
    # NATS Server Configuration for ServiceRadar Kubernetes Deployment
    server_name: nats-serviceradar-k8s

    # Listen on all interfaces for Kubernetes networking
    listen: 0.0.0.0:4222

    # HTTP monitoring
    http: 0.0.0.0:8222

    # Enable JetStream for KV store
    jetstream {
      # Directory to store JetStream data
      store_dir: /data/jetstream
      # Maximum storage size
      max_memory_store: 1G
      # Maximum disk storage
      max_file_store: 10G
    }

    # Enable mTLS for secure communication
    tls {
      # Path to the server certificate
      cert_file: "/etc/serviceradar/certs/nats.pem"
      # Path to the server private key
      key_file: "/etc/serviceradar/certs/nats-key.pem"
      # Path to the root CA certificate for verifying clients
      ca_file: "/etc/serviceradar/certs/root.pem"

      # Require client certificates (enables mTLS)
      verify: true
      # Require and verify client certificates
      verify_and_map: true
    }

    # Account-based authorization for ServiceRadar components
    accounts {
      # System account with full privileges  
      SYS: {
        users: []
      }
      
      # ServiceRadar services account
      SERVICERADAR: {
        jetstream: enabled
        users: [
        {
          user: "CN=serviceradar-debug-client,OU=Kubernetes,O=ServiceRadar,L=San Francisco,ST=CA,C=US"
          permissions: {
            publish: {
              allow: [">"]
            }
            subscribe: {
              allow: [">"]
            }
          }
        },
        {
          user: "CN=serviceradar-core,OU=Kubernetes,O=ServiceRadar,L=San Francisco,ST=CA,C=US"
          permissions: {
            publish: {
              allow: [">"]
            }
            subscribe: {
              allow: [">"]
            }
          }
        },
        {
          user: "CN=serviceradar-kv,OU=Kubernetes,O=ServiceRadar,L=San Francisco,ST=CA,C=US"
          permissions: {
            publish: {
              allow: [">"]
            }
            subscribe: {
              allow: [">"]
            }
          }
        },
        {
          user: "CN=serviceradar-poller,OU=Kubernetes,O=ServiceRadar,L=San Francisco,ST=CA,C=US"
          permissions: {
            publish: {
              allow: [">"]
            }
            subscribe: {
              allow: [">"]
            }
          }
        },
        {
          user: "CN=serviceradar-agent,OU=Kubernetes,O=ServiceRadar,L=San Francisco,ST=CA,C=US"
          permissions: {
            publish: {
              allow: [">"]
            }
            subscribe: {
              allow: [">"]
            }
          }
        },
        {
          user: "CN=serviceradar-db-event-writer,OU=Kubernetes,O=ServiceRadar,L=San Francisco,ST=CA,C=US"
          permissions: {
            publish: {
              allow: [">"]
            }
            subscribe: {
              allow: [">"]
            }
          }
        },
        {
          user: "CN=serviceradar-zen,OU=Kubernetes,O=ServiceRadar,L=San Francisco,ST=CA,C=US"
          permissions: {
            publish: {
              allow: [">"]
            }
            subscribe: {
              allow: [">"]
            }
          }
        },
        {
          user: "CN=serviceradar-flowgger,OU=Kubernetes,O=ServiceRadar,L=San Francisco,ST=CA,C=US"
          permissions: {
            publish: {
              allow: ["events.syslog", "$JS.API.STREAM.INFO.events", "$JS.API.STREAM.CREATE.events", "$JS.API.>"]
            }
            subscribe: {
              allow: ["$JS.API.>", "_INBOX.>"]
            }
          }
        },
        {
          user: "CN=serviceradar-otel,OU=Kubernetes,O=ServiceRadar,L=San Francisco,ST=CA,C=US"
          permissions: {
            publish: {
              allow: ["events.otel.>", "$JS.API.>"]
            }
            subscribe: {
              allow: ["$JS.API.>", "_INBOX.>"]
            }
          }
        },
        {
          user: "CN=serviceradar-mapper,OU=Kubernetes,O=ServiceRadar,L=San Francisco,ST=CA,C=US"
          permissions: {
            publish: {
              allow: [">"]
            }
            subscribe: {
              allow: [">"]
            }
          }
        },
        {
          user: "CN=serviceradar-trapd,OU=Kubernetes,O=ServiceRadar,L=San Francisco,ST=CA,C=US"
          permissions: {
            publish: {
              allow: ["snmp.traps", "$JS.API.STREAM.INFO.events", "$JS.API.STREAM.CREATE.events", "$JS.API.>"]
            }
            subscribe: {
              allow: ["$JS.API.>", "_INBOX.>"]
            }
          }
        },
        {
          user: "O=ServiceRadar"
          permissions: {
            publish: {
              allow: [">"]
            }
            subscribe: {
              allow: [">"]
            }
          }
        }
        ]
      }
    }
    
    # Set system account
    system_account: "SYS"

    # Logging settings
    debug: true
    trace: false

  otel.toml: |
    # ServiceRadar OTEL Collector Configuration for Kubernetes Deployment
    
    [server]
    # Address to bind the OTEL collector to
    bind_address = "0.0.0.0"
    # Port to listen on for OTEL traces
    port = 4317
    
    [nats]
    # NATS server URL with mTLS (Kubernetes deployment)
    url = "tls://serviceradar-nats:4222"
    
    # Subject to publish traces to (default: events.otel)
    subject = "events.otel"
    
    # JetStream stream name (default: events)
    stream = "events"
    
    # Timeout for NATS operations in seconds (default: 30)
    timeout_secs = 30
    
    # mTLS configuration for NATS
    [nats.tls]
    cert_file = "/etc/serviceradar/certs/otel.pem"
    key_file = "/etc/serviceradar/certs/otel-key.pem"
    ca_file = "/etc/serviceradar/certs/root.pem"
    
    [grpc_tls]
    cert_file = "/etc/serviceradar/certs/otel.pem"
    key_file = "/etc/serviceradar/certs/otel-key.pem"
    ca_file = "/etc/serviceradar/certs/root.pem"

  trapd.json: |
    {
      "listen_addr": "0.0.0.0:162",
      "nats_url": "tls://serviceradar-nats:4222",
      "stream_name": "events",
      "subject": "snmp.traps",
      "nats_security": {
        "cert_file": "/etc/serviceradar/certs/trapd.pem",
        "key_file": "/etc/serviceradar/certs/trapd-key.pem",
        "ca_file": "/etc/serviceradar/certs/root.pem"
      },
      "grpc_listen_addr": "0.0.0.0:50043",
      "grpc_security": {
        "cert_file": "/etc/serviceradar/certs/trapd.pem",
        "key_file": "/etc/serviceradar/certs/trapd-key.pem",
        "ca_file": "/etc/serviceradar/certs/root.pem"
      },
      "otel": {
        "enabled": true,
        "endpoint": "serviceradar-otel:4317",
        "service_name": "serviceradar-trapd",
        "tls": {
          "cert_file": "/etc/serviceradar/certs/trapd.pem",
          "key_file": "/etc/serviceradar/certs/trapd-key.pem",
          "ca_file": "/etc/serviceradar/certs/root.pem",
          "server_name": "serviceradar-otel"
        }
      }
    }

  mapper.json: |
    {
      "workers": 20,
      "timeout": "30s",
      "retries": 3,
      "max_active_jobs": 100,
      "result_retention": "24h",
      "mapper_agent_id": "k8s-mapper",
      "mapper_instance_id": "serviceradar-mapper-k8s",
      "default_credentials": {
        "version": "v2c",
        "community": "public"
      },
      "oids": {
        "basic": [
          ".1.3.6.1.2.1.1.1.0",
          ".1.3.6.1.2.1.1.2.0",
          ".1.3.6.1.2.1.1.5.0",
          ".1.3.6.1.2.1.1.4.0",
          ".1.3.6.1.2.1.1.6.0",
          ".1.3.6.1.2.1.1.3.0"
        ],
        "interfaces": [
          ".1.3.6.1.2.1.2.2.1",
          ".1.3.6.1.2.1.31.1.1.1",
          ".1.3.6.1.2.1.4.20.1"
        ],
        "topology": [
          ".1.0.8802.1.1.2.1",
          ".1.3.6.1.4.1.9.9.23.1"
        ]
      },
      "stream_config": {
        "device_stream": "sweep_results",
        "interface_stream": "discovered_interfaces",
        "topology_stream": "topology_discovery_events",
        "agent_id": "k8s-snmp-discovery-agent",
        "publish_batch_size": 100,
        "publish_retries": 3,
        "publish_retry_interval": "5s"
      },
      "credentials": [
        {
          "targets": ["192.168.1.0/24", "192.168.2.0/24"],
          "version": "v2c",
          "community": "public"
        }
      ],
      "scheduled_jobs": [
        {
          "name": "k8s-lan-discovery",
          "interval": "2h",
          "enabled": true,
          "seeds": ["192.168.1.1", "192.168.2.1"],
          "type": "full",
          "credentials": {
            "version": "v2c",
            "community": "public"
          },
          "concurrency": 10,
          "timeout": "45s",
          "retries": 2,
          "options": {
            "trigger_discovery": "false"
          }
        }
      ],
      "unifi_apis": [],
      "security": {
        "mode": "mtls",
        "cert_dir": "/etc/serviceradar/certs",
        "role": "checker",
        "server_name": "localhost",
        "tls": {
          "cert_file": "/etc/serviceradar/certs/mapper.pem",
          "key_file": "/etc/serviceradar/certs/mapper-key.pem",
          "ca_file": "/etc/serviceradar/certs/root.pem",
          "client_ca_file": "/etc/serviceradar/certs/root.pem"
        }
      },
      "logging": {
        "level": "info",
        "debug": false,
        "output": "stdout",
        "time_format": "",
        "otel": {
          "enabled": true,
          "endpoint": "serviceradar-otel:4317",
          "service_name": "serviceradar-mapper",
          "batch_timeout": "5s",
          "insecure": false,
          "headers": {},
          "tls": {
            "cert_file": "/etc/serviceradar/certs/mapper.pem",
            "key_file": "/etc/serviceradar/certs/mapper-key.pem",
            "ca_file": "/etc/serviceradar/certs/root.pem",
            "server_name": "serviceradar-otel"
          }
        }
      }
    }

  # KV Service Configuration
  kv.json: |
    {
      "listen_addr": "0.0.0.0:50057",
      "nats_url": "tls://serviceradar-nats:4222",
      "security": {
        "mode": "mtls",
        "cert_dir": "/etc/serviceradar/certs",
        "server_name": "serviceradar-nats",
        "role": "kv",
        "tls": {
          "cert_file": "kv.pem",
          "key_file": "kv-key.pem",
          "ca_file": "root.pem",
          "client_ca_file": "root.pem"
        }
      },
      "rbac": {
        "roles": [
          {"identity": "CN=serviceradar-agent,OU=Kubernetes,O=ServiceRadar,L=San Francisco,ST=CA,C=US", "role": "reader"},
          {"identity": "CN=serviceradar-zen,OU=Kubernetes,O=ServiceRadar,L=San Francisco,ST=CA,C=US", "role": "reader"},
          {"identity": "CN=serviceradar-core,OU=Kubernetes,O=ServiceRadar,L=San Francisco,ST=CA,C=US", "role": "admin"},
          {"identity": "CN=serviceradar-debug-client,OU=Kubernetes,O=ServiceRadar,L=San Francisco,ST=CA,C=US", "role": "reader"}
        ]
      },
      "bucket": "serviceradar-kv"
    }
